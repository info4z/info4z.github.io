[{"title":"shell编程","url":"/2023/02/03/shell%E7%BC%96%E7%A8%8B/","content":"\n熟练掌握shell的语法, 写出优雅的脚本\n\n一 : 多命令执行符\n\n\n多命令执行符\n格式\n作用\n\n\n\n;\n命令1;命令2\n多个命令顺序执行, 命令之间没有任何逻辑联系\n\n\n&amp;&amp;\n命令1&amp;&amp;命令2\n当命令1正确执行($?&#x3D;0), 则命令2才会执行; 当命令1执行不正确($? ≠ 0), 则命令2不会执行\n\n\n&#96;\n\n&#96;\n\n\n示例\n# 判断命令是否正确执行[root@localhost ~]# ls &amp;&amp; echo yes || echo no\n\n\n\n二 : 数值运算的方法在 linux 中, 所有变量的默认类型是字符串型, 如果我需要进行数值运算, 可以采用的方式有三种\n推荐使用 $((运算式)) 的方式\n(一) $((运算式))或$[运算式]代码示例\n# 变量 ff 的值是 aa 和 bb 的和[root@localhost ~]# aa=11[root@localhost ~]# bb=22[root@localhost ~]# ff=$(( $aa+$bb ))[root@localhost ~]# echo $ff33# 变量 gg 的值是 aa 和 bb 的和[root@localhost ~]# gg=$[ $aa+$bb ][root@localhost ~]# echo $gg33\n\n(二) 数值运算工具 expr 或 letexpr 命令要求运算符左右两侧必须有空格, 否则运算不执行\n# 给变量aa和变量bb赋值[root@localhost ~]# aa=11[root@localhost ~]# bb=22# dd的值是aa和bb的和。注意&quot;+&quot;号左右两侧必须有空格[root@localhost ~]# dd=$(expr $aa + $bb)[root@localhost ~]# echo $dd 33\n\nlet 命令对格式要求比较宽松, 所以推荐使用 let 命令进行数值运算\n#给变量 aa 和变量 bb 赋值[root@localhost ~]# aa=11[root@localhost ~]# bb=22#变量 ee 的值是 aa 和 bb 的和[root@localhost ~]# let ee=$aa+$bb[root@localhost ~]# echo $ee33#定义变量 n[root@localhost ~]# n=20#变量 n 的值等于变量本身再加 1[root@localhost ~]# let n+=1[root@localhost ~]# echo $n21\n\n(三) 声明变量类型 declare既然所有变量的默认类型是字符串型, 那么只要把变量声明为整数型不就可以了吗? 使用 declare 命令就可以实现声明变量的类型\n[root@localhost ~]# declare [+/-][选项] 变量名选项:    -\t: 给变量设定类型属性    +\t: 取消变量的类型属性        -a\t: 将变量声明为数组型(array)    -i\t: 将变量声明为整数型(integer)     -r\t: 讲变量声明为只读变量(readonly)。        注意, 一旦设置为只读变量, 既不能修改变量的值, 也不能删除变量, 甚至不能通过+r 取消只读属性    -x\t: 将变量声明为环境变量    -p\t: 显示指定变量的被声明的类型\n\n代码示例, 了解即可\n# 给变量 aa 和 bb 赋值[root@localhost ~]# aa=11[root@localhost ~]# bb=22# 声明变量 cc 的类型是整数型, 它的值是 aa 和 bb 的和[root@localhost ~]# declare -i cc=$aa+$bb# 这下终于可以相加了[root@localhost ~]# echo $cc33\n\n\n\n二 : 条件判断 test(一) 文件类型相关参数 \n\n\n\n选项\n英文\n作用\n\n\n\n-b 文件\nblock\n判断该文件是否存在, 并且是否为块设备文件(是块设备文件为真)\n\n\n-c 文件\ncharacter\n判断该文件是否存在, 并且是否为字符设备文件(是字符设备文件为真)\n\n\n-d 文件\ndirectory\n判断该文件是否存在, 并且是否为目录文件(是目录为真)\n\n\n-e 文件\nexists\n判断该文件是否存在(存在为真)\n\n\n-f 文件\nfile\n判断该文件是否存在, 并且是否为普通文件(是普通文件为真)\n\n\n-L 文件\nlink\n判断该文件是否存在, 并且是否为符号链接文件(是符号链接文件为真)\n\n\n-p 文件\npipe\n判断该文件是否存在, 并且是否为管道文件(是管道文件为真)\n\n\n-s 文件\nsize &gt; 0\n判断该文件是否存在, 并且是否为非空(非空为真)\n\n\n-S 文件\nsocket\n判断该文件是否存在, 并且是否为套接字文件(是套接字文件为真)\n\n\n代码示例\n# 命令格式[root@localhost ~]# test -e /root/sh/# 通常我们喜欢使用另一种格式,而且更通用,如下[root@localhost ~]# [ -e /root/sh/ ][root@localhost ~]# echo $?0 #判断结果为 0,/root/sh/目录是存在的[root@localhost ~]# [ -e /root/test ][root@localhost ~]# echo $? 1 #在/root/下并没有test文件或目录,所以&quot;$?&quot;的返回值为非零# 也可以用&amp;&amp;和||[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; \n\n\n\n(二) 文件权限相关参数 \n\n\n\n选项\n作 用\n\n\n\n-r 文件\n判断该文件是否存在, 并且是否该文件拥有读权限(有读权限为真)\n\n\n-w 文件\n判断该文件是否存在, 并且是否该文件拥有写权限(有写权限为真)\n\n\n-x 文件\n判断该文件是否存在, 并且是否该文件拥有执行权限(有执行权限为真)\n\n\n-u 文件\n判断该文件是否存在, 并且是否该文件拥有 SUID 权限(有 SUID 权限为真)\n\n\n-g 文件\n判断该文件是否存在, 并且是否该文件拥有 SGID 权限(有 SGID 权限为真)\n\n\n-k 文件\n判断该文件是否存在, 并且是否该文件拥有 SBit 权限(有 SBit 权限为真)\n\n\n代码示例\n[root@localhost ~]# ll null.txt -rw-r--r-- 1 root root 0 Nov 16 18:45 null.txt#判断文件是拥有写权限的[root@localhost ~]# [ -w null.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; yes\n\n(三) 文件比较如何进行两个文件之间的比较\n\n\n\n测试选项\n英文\n作用\n\n\n\n文件1 -nt 文件2\nnew\n判断文件1的修改时间是否比文件2的新(如果新则为真)\n\n\n文件1 -ot 文件2\nold\n判断文件1的修改时间是否比文件2的旧(如果旧则为真)\n\n\n文件1 -ef 文件2\nequal\n判断文件1是否和文件2的Inode号一致,可以理解为两个文件是否为同一个文件(硬链接)\n\n\n代码示例 : 判断两个文件是否是硬链接呢\n#创建个硬链接吧[root@localhost ~]# ln /root/student.txt /tmp/stu.txt#用 test 测试下,果然很有用[root@localhost ~]# [ /root/student.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; yes\n\n(四) 整数比较如何在两个整数之间进行比较\n\n\n\n测试选项\n作用\n\n\n\n整数1 -eq 整数2\n判断整数1是否和整数2相等(相等为真)\n\n\n整数1 -ne 整数2\n判断整数1是否和整数2不相等(不相等位置)\n\n\n整数1 -gt 整数2\n判断整数1是否大于整数2(大于为真)\n\n\n整数1 -lt 整数2\n判断整数1是否小于整数2(小于位置)\n\n\n整数1 -ge 整数2\n判断整数1是否大于等于整数2(大于等于为真)\n\n\n整数1 -le 整数2\n判断整数1是否小于等于整数2(小于等于为真)\n\n\n代码示例\n#判断 23 是否大于等于 22,当然是了[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; yes#判断 23 是否小于等于 22,当然不是了[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; no\n\n(五) 字符串判断字符串的判断\n\n\n\n测试选项\n英文\n作用\n\n\n\n-z 字符串\nlength zero\n判断字符串是否为空(空为真)\n\n\n-n 字符串\nnonzero\n判断字符串是否为非空(非空为真)\n\n\n字串1 == 字串2\n\n判断字符串1是否和字符串2相等(相等为真)\n\n\n字串1 != 字串2\n\n判断字符串1是否和字符串2不相等(不等为真)\n\n\n代码示例\n# 判断name变量是否为空[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; # 给变量 aa 和变量 bb 赋值[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; \n\n(六) 多重条件判断多重条件判断是什么样子的\n\n\n\n测试选项\n作用\n\n\n\n判断1 -a 判断2\n逻辑与, 判断1和判断2都成立, 最终的结果才为真\n\n\n判断1 -o 判断2\n逻辑或, 判断1和判断2有一个成立, 最终的结果就为真\n\n\n! 判断\n逻辑非, 使原始的判断式取反\n\n\n代码示例 : \n# 判断变量aa是否为空且是否大于 23[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;# 本来&quot;-n&quot;选项是变量aa不为空,加&quot;!&quot;后相当于&quot;-z&quot;[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; \n\n\n注意 : ! 和 -n 之间必须加入空格,否则会报错的。\n\n三 : 条件判断(一) 单分支 if单分支条件语句最为简单, 就是只有一个判断条件, 如果符合条件则执行某个程序, 否则什么事情都不做; 语法如下 : \nif [ 条件判断式 ];then\t程序fi\n\n需要注意几个点 : \n\nif 语句使用 fi 结尾, 和一般语言使用大括号结尾不同\n\n[ 条件判断式 ] 就是使用 test 命令判断,所以中括号和条件判断式之间必须有空格\n\nthen 后面跟符合条件之后执行的程序, 可以放在 [] 之后用 ; 分割。也可以换行写入, 就不需要 ; 了, 比如单分支 if 语句还可以这样写 : \nif [ 条件判断式 ]    then  \t\t程序fi\n\n代码示例\n[root@localhost ~]# vi sh/if1.sh#!/bin/bash# 统计根分区使用率#把根分区使用率作为变量值赋予变量 raterate=$(df -h | grep &quot;/dev/vda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)#判断 rate 的值如果大于等于 80,则执行 then 程序if [ $rate -ge 80 ]    then     \techo &quot;Warning! /dev/sda3 is full!!&quot;fi\n\n(二) 双分支 if 条件语句语法格式\nif [ 条件判断式 ]    then    \t条件成立时,执行的程序    else    \t条件不成立时,执行的另一个程序fi\n\n代码示例 : 我们写一个数据备份的例子, 来看看双分支 if 条件语句。\n# 备份 mysql 数据库[root@localhost ~]# vi sh/bakmysql.sh#!/bin/bash#备份 mysql 数据库#同步系统时间ntpdate asia.pool.ntp.org &amp;&gt;/dev/null#把当前系统时间按照&quot;年月日&quot;格式赋予变量 datedate=$(date +%y%m%d)#统计 mysql 数据库的大小,并把大小赋予 size 变量size=$(du -sh /var/lib/mysql)#判断备份目录是否存在,是否为目录if [ -d /tmp/dbbak ]\t#如果判断为真,执行以下脚本    then    \t#把当前日期写入临时文件        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt        #把数据库大小写入临时文件        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt        #进入备份目录        cd /tmp/dbbak        #打包压缩数据库与临时文件,把所有输出丢入垃圾箱(不想看到任何输出)        tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null        #删除临时文件        rm -rf /tmp/dbbak/dbinfo.txt    else    \t#如果判断为假,则建立备份目录        mkdir /tmp/dbbak        #把日期和数据库大小保存如临时文件        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt        #压缩备份数据库与临时文件        cd /tmp/dbbak        tar -zcf mysql-lib-$date.tar.gz dbinfo.txt /var/lib/mysql &amp;&gt;/dev/null        #删除临时文件        rm -rf /tmp/dbbak/dbinfo.txtfi\n\n\n注意 : 解释一下 &amp;&gt;/dev/null 这个命令, &amp;&gt; 输出, /dev/null 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 &amp;&gt;/dev/null, 用于屏蔽命令的提示信息\n\n实例 : 在工作当中,服务器上的服务经常会宕机。如果我们对服务器监控不好,就会造成服务器中服务宕机了,而管理员却不知道的情况, 这时我们可以写一个脚本来监听本机的服务,如果服务停止或宕机了,可以自动重启这些服务。我们拿 apache 服务来举例 : \n# 判断 apache 是否启动,如果没有启动则自动启动[root@localhost ~]# vi sh/autostart.sh#!/bin/bash#判断 apache 是否启动,如果没有启动则自动启动# Author: Bob (E-mail: Bob@163.com)#使用nmap命令扫描服务器公网ip,并截取 apache 服务的状态,赋予变量 portport=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)#如果变量 port 的值是&quot;open&quot;if [ &quot;$port&quot; == &quot;open&quot; ]\tthen\t\t#则证明 apache 正常启动,在正常日志中写入一句话即可\t\techo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log\telse\t\t#否则证明 apache 没有启动,自动启动 apache\t\t/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null\t\t#并在错误日志中记录自动启动 apche 的时间\t\techo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.logfi\n\n\n我们使用 nmap 端口扫描命令, 它的原理是给指定服务器所有的端口发送请求, 看它是否回复, nmap 命令格式如下 : \n[root@localhost ~]# nmap -sT 域名或IP(一般用公网IP)选项 :     -s 扫描    -T 扫描所有开启的 TCP 端口\n\n这条命令的执行结果如下 : \n# 可以看到这台服务器开启了如下的服务[root@localhost ~]# nmap -sT 192.168.4.210Starting Nmap 5.51 ( http://nmap.org ) at 2018-11-25 15:11 CSTNmap scan report for 192.168.4.210Host is up (0.0010s latency).Not shown: 994 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http #apache 的状态是 open111/tcp open rpcbind139/tcp open netbios-ssn445/tcp open microsoft-ds3306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 0.49 seconds\n\n知道了 nmap 命令的用法,我们在脚本中使用的命令就是为了截取 http 的状态,只要状态是 open 就证明 apache 启动正常,否则证明 apache 启动错误。来看看脚本中命令的结果 : \n# 扫描指定计算机,提取包含 tcp 的行,在提取包含 httpd 的行,截取第二列[root@localhost ~]# nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;open# 把截取的值赋予变量 port\n\n(三) 多分支 if 条件语句语法格式\nif [ 条件判断式 1 ]    then    \t当条件判断式 1 成立时,执行程序 1elif [ 条件判断式 2 ]    then        当条件判断式 2 成立时,执行程序 2 # …省略更多条件…else\t当所有条件都不成立时,最后执行此程序fi\n\n代码示例 : 判断用户输入的是什么文件\n[root@localhost ~]# vi sh/if-elif.sh#!/bin/bash#判断用户输入的是什么文件#接收键盘的输入,并赋予变量 fileread -p &quot;Please input a filename: &quot; file#判断 file 变量是否为空if [ -z &quot;$file&quot; ]\tthen        #如果为空,执行程序 1,也就是输出报错信息        echo &quot;Error,please input a filename&quot;        #退出程序,并返回值为 1(把返回值赋予变量$?)\t\texit 1#判断 file 的值是否存在elif [ ! -e &quot;$file&quot; ]\tthen\t\t#如果不存在,则执行程序 2\t\techo &quot;Your input is not a file!&quot;        #退出程序,把并定义返回值为 2        exit 2#判断 file 的值是否为普通文件elif [ -f &quot;$file&quot; ]\tthen\t\t#如果是普通文件,则执行程序 3        echo &quot;$file is a regulare file!&quot;#判断 file 的值是否为目录文件elif [ -d &quot;$file&quot; ]\tthen\t\t#如果是目录文件,则执行程序 4\t\techo &quot;$file is a directory!&quot;else\t#如果以上判断都不是,则执行程序 5\techo &quot;$file is an other file!&quot;fi\n\n(四) case 条件语句case 语句和 if…elif…else 语句一样都是多分支条件语句, 不过和 if 多分支条件语句不同的是, case 语句只能判断一种条件关系, 而 if 语句可以判断多种条件关系。case 语句语法如下 : \ncase $变量名 in    &quot;值1&quot;)    如果变量的值等于值 1,则执行程序 1    ;;    &quot;值2&quot;)    如果变量的值等于值 2,则执行程序 2    ;;    …省略其他分支…     *)    如果变量的值都不是以上的值,则执行此程序    ;;esac\n\n注意以下内容 : \n\ncase 语句, 会取出变量中的值, 然后与语句体中的值逐一比较; 如果数值符合, 则执行对应的程序, 如果数值不符, 则依次比较下一个值。如果所有的值都不符合,则执行 *) 中的程序;  *  代表所有其他值\ncase 语句以 case 开头, 以 esac 结尾; 每一个分支程序之后要通过 ;; 双分号结尾, 代表该程序段结束(千万不要忘记)。\n\n代码示例\n[root@localhost ~]# vi sh/case.sh#!/bin/bash#判断用户输入#在屏幕上输出&quot;请选择 yes/no&quot;,然后把用户选择赋予变量 choread -p &quot;Please choose yes/no: &quot; -t 30 cho#判断变量 cho 的值case $cho in\t#如果是 yes    &quot;yes&quot;)    \t#执行程序 1        echo &quot;Your choose is yes!&quot;        ;;\t#如果是 no    &quot;no&quot;)\t\t#执行程序 2        echo &quot;Your choose is no!&quot;        ;;\t#如果既不是 yes,也不是 no    *)    \t#则执行此程序        echo &quot;Your choose is error!&quot;        ;;esac\n\n四 : 循环(一) for 循环for 循环是固定循环, 也就是在循环时已经知道需要进行几次的循环, 有时也把 for 循环称为计数循环。for 的语法有两种 : \n语法一\nfor 变量 in 值1 值2 值3…    do    \t程序    done\n\n\n这种语法中 for 循环的次数, 取决于 in 后面值的个数(空格分隔), 有几个值就循环几次, 并且每次循环都把值赋予变量。也就是说,假设 in 后面有三个值, 就会循环三次, 第一次循环会把值1赋予变量, 第二次循环会把值2赋予变量, 以此类推。\n\n语法二\nfor (( 初始值;循环控制条件;变量变化 ))    do    \t程序    done\n\n语法二中需要注意 : \n\n初始值 : 在循环开始时, 需要给某个变量赋予初始值, 如 i&#x3D;1;  \n循环控制条件 : 用于指定变量循环的次数,如 i&lt;&#x3D;100, 则只要 i 的值小于等于 100, 循环就会继续; \n变量变化 : 每次循环之后, 变量该如何变化,如 i&#x3D;i+1; 代表每次循环之后, 变量 i 的值都加 1。\n\n代码示例\n[root@localhost ~]# vi sh/for.sh#!/bin/bash# 打印时间for time in morning noon afternoon evening\tdo\t\techo &quot;This time is $time!&quot;\tdone\n\n[root@localhost ~]# vi sh/auto-tar.sh#!/bin/bash# 批量解压缩脚本# 进入压缩包目录cd /lamp# 列出.tar.gz的值,有多少个文件,就会循环多少次,每次循环把文件名赋予变量ifor i in $(ls *.tar.gz)\tdo\t\t#解压缩,并把所有输出都丢弃\t\ttar -zxf $i &amp;&gt;/dev/null\tdone\n\n#!/bin/bash#从1加到100s=0# 定义循环 100 次for (( i=1;i&lt;=100;i=i+1 ))    do    \t# 每次循环给变量 s 赋值        s=$(( $s+$i ))    done# 输出1加到100的和echo &quot;The sum of 1+2+...+100 is : $s&quot;\n\n[root@localhost ~]# vi useradd.sh#!/bin/bash# 批量添加指定数量的用户# 让用户输入用户名,把输入保存入变量 nameread -p &quot;Please input user name: &quot; -t 30 name# 让用户输入添加用户的数量,把输入保存入变量 numread -p &quot;Please input the number of users: &quot; -t 30 num # 让用户输入初始密码,把输入保存如变量 passread -p &quot;Please input the password of users: &quot; -t 30 pass# 判断三个变量不为空if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot; ]    then    \t# 定义变量的值为后续命令的结果    \t# 后续命令作用是,把变量num的值替换为空。如果能替换为空,证明 num 的值为数字    \t# 如果不能替换为空,证明 num 的值为非数字。我们使用这种方法判断变量 num 的值为数字    \ty=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)        # 如果变量 y 的值为空,证明 num 变量是数字        if [ -z &quot;$y&quot; ]            then                # 循环 num 变量指定的次数                for (( i=1;i&lt;=$num;i=i+1 ))                    do                         # 添加用户,用户名为变量 name 的值加变量 i 的数字                        /usr/sbin/useradd $name$i &amp;&gt;/dev/null                        # 给用户设定初始密码为变量 pass 的值                        echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null                    done        fi fi\n\n[root@localhost ~]# vi sh/userdel.sh#!/bin/bash#批量删除用户#读取用户信息文件,提取可以登录用户,排除root用户,截取第一列就是用户名user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; |cut -d &quot;:&quot; -f 1)#循环,有多少个普通用户,循环多少次for i in $user    do     \t#每次循环,删除指定普通用户        userdel -r $i    done\n\n(二) while 循环对 while 循环来讲, 只要条件判断式成立, 循环就会一直继续, 直到条件判断式不成立, 循环才会停止\nwhile [ 条件判断式 ]    do    \t程序    done\n\n代码示例 : 1 加到 100\n#!/bin/bash# 从 1 加到 100# 给变量 i 和变量 s 赋值i=1s=0# 如果变量 i 的值小于等于 100,则执行循环while [ $i -le 100 ]    do        s=$(( $s+$i ))        i=$(( $i+1 ))    doneecho &quot;The sum is: $s&quot; \n\n(三) until 循环和 while 循环相反, until 循环时只要条件判断式不成立则进行循环, 并执行循环程序; 一旦循环条件成立,则终止循环\nuntil [ 条件判断式 ]    do   \t\t程序    done\n\n还是写从 1 加到 100 这个例子, 注意和 while 循环的区别 : \n# 从 1 加到 100[root@localhost ~]# vi sh/until.sh #!/bin/bash#从 1 加到 100#给变量i和s赋值i=1s=0#循环直到变量i的值大于100,就停止循环until [ $i -gt 100 ]    do        s=$(( $s+$i ))        i=$(( $i+1 ))    doneecho &quot;The sum is: $s&quot;\n\n\n\n五 : 退出(一) exit 语句系统是有 exit 命令的,用于退出当前用户的登录状态。可是在 Shell 脚本中, exit 语句是用来退出当前脚本的。也就是说, 在 Shell 脚本中, 只要碰到了 exit 语句, 后续的程序就不再执行, 而直接退出脚本。\nexit 的语法如下 : \nexit [返回值]\n\n\n如果 exit 命令之后定义了返回值, 那么这个脚本执行之后的返回值就是我们自己定义的返回值; 可以通过查询 $? 这个变量来查看返回值; 如果 exit 之后没有定义返回值, 脚本执行之后的返回值是执行 exit 语句之前, 最后执行的一条命令的返回值。\n\n代码示例 \n[root@localhost ~]# vi sh/exit.sh#!/bin/bash#接收用户的输入,并把输入赋予numread -p &quot;Please input a number: &quot; -t 30 num #如果变num的值是数字,则把num的值替换为空,否则不替换#把替换之后的值赋予变量 yy=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)#判断变量 y 的值如果不为空,输出报错信息,退出脚本,退出返回值为 18[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18#如果没有退出脚本,则打印变量 num 中的数字echo &quot;The number is: $num&quot;\n\n\n注意 : 这里的字符串变量要用 &quot;&quot; 引一下\n\n(二) break 语句再来看看特殊流程控制语句 break 的作用, 当程序执行到 break 语句时, 会结束整个当前循环; 而 continue 语句也是结束循环的语句, 不过 continue 语句单次当前循环, 而下次循环会继续。\n代码示例 : \n[root@localhost ~]# vi sh/break.sh#!/bin/bash#演示 break 跳出循环#循环十次for (( i=1;i&lt;=10;i=i+1 ))    do     \t#如果变量 i 的值等于 4        if [ &quot;$i&quot; -eq 4 ]            then            \t#退出整个循环                break        fi         echo $i        #输出变量 i 的值    done\n\n测试结果 : 输出1,2,3后停止脚本\n(三) continue 语句再来看看 continue 语句, continue 也是结束流程控制的语句; 如果在循环中, continue 语句只会结束单次当前循环\n还是用刚刚的脚本,不过退出语句换成 continue 语句,看看会发生什么情况 : \n[root@localhost ~]# vi sh/continue.sh#!/bin/bash#演示 continue 语句for (( i=1;i&lt;=10;i=i+1 ))    do         if [ &quot;$i&quot; -eq 4 ]             then            \t#退出语句换成 continue                continue        fi         echo $i    done\n\n测试结果 : 只有4不会被输出\n六 : 函数语法格式\nfunction 函数名 () &#123;\t程序&#125;\n\n代码示例\n[root@localhost ~]# vi sh/function.sh#!/bin/bash#接收用户输入的数字,然后从1加到这个数字#定义函数 sumfunction sum () &#123;    s=0     #循环直到i大于$1为止。$1是函数sum的第一个参数    #在函数中也可以使用位置参数变量,不过这里的$1指的是函数的第一个参数    for (( i=0;i&lt;=$1;i=i+1 ))        do         \ts=$(( $i+$s ))        done\t#输出1加到$1 的和    echo &quot;The sum of 1+2+3...+$1 is : $s&quot;&#125;#接收用户输入的数字,并把值赋予变量numread -p &quot;Please input a number: &quot; -t 30 num #把变量num的值替换为空,并赋予变量yy=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)#判断变量y是否为空,以确定变量 num 中是否为数字if [ -z &quot;$y&quot; ]    then    \t#调用sum函数,并把变量num的值作为第一个参数传递给 sum 函数        sum $numelse\t#如果变量 num 的值不是数字,则输出报错信息\techo &quot;Error!! Please input a number!&quot;fi\n\n\n\n七 : 接收键盘输入用来从标准输入读取单行数据; 这个命令可以用来读取键盘输入, 当使用重定向的时候, 可以读取文件中的一行数据; 命令格式 : \n[root@localhost ~]# read [选项] [变量名]选项:    -p &quot;message&quot;: 在等待 read 输入时, 输出提示信息(message)    -t second\t: read 命令会一直等待用户输入, 使用此选项可以指定等待时间(秒数)    -n number\t: read 命令只接受指定的字符数(number), 就会执行    -s \t\t\t: 隐藏输入的数据, 适用于机密信息的输入变量名:    变量名可以自定义, 如果不指定变量名, 会把输入保存入默认变量 REPLY    如果只提供了一个变量名, 则整个输入行赋予该变量    如果提供了一个以上的变量名, 则输入行分为若干字, 一个接一个地赋予各个变量, 而命令行上的最后一个变量取得剩余的所有字\n\n还是写个例子来解释下 read 命令:\n[root@localhost sh]# vi read.sh #!/bin/bash# Author: Bob (E-mail: Bob@163.com)# 提示&quot;请输入姓名&quot;并等待 30 秒, 把用户的输入保存入变量 name 中read -t 30 -p &quot;Please input your name: &quot; name# 看看变量&quot;$name&quot;中是否保存了你的输入echo &quot;Name is $name&quot;# 提示&quot;请输入年龄&quot;并等待30秒, 把用户的输入保存入变量age中 # 年龄是隐私, 所以我们用&quot;-s&quot;选项隐藏输入read -s -t 30 -p &quot;Please enter your age: &quot; age# 调整输出格式,如果不输出换行,一会儿的年龄输出不会换行echo -e &quot;\\n&quot;# 提示&quot;请选择性别&quot;并等待 30 秒, 把用户的输入保存入变量 gender# 使用&quot;-n 1&quot;选项只接收一个输入字符就会执行(都不用输入回车)echo &quot;Age is $age&quot;read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; genderecho -e &quot;\\n&quot;echo &quot;Sex is $gender&quot;\n\n\n\n八 : 输入输出重定向(一) Bash 的标准输入输出\n\n\n设备\n设备文件名\n文件描述符\n类型\n\n\n\n键盘\n&#x2F;dev&#x2F;stdin\n0\n标准输入\n\n\n显示器\n&#x2F;dev&#x2F;stdout\n1\n标准输出\n\n\n显示器\n&#x2F;dev&#x2F;stderr\n2\n标准错误输出\n\n\n(二) 输出重定向标准输出重定向\n\n\n\n符号\n作用\n\n\n\n命令 &gt; 文件\n以覆盖的方式, 把命令的正确输出输出到指定的文件或设备当中\n\n\n命令 &gt;&gt; 文件\n以追加的方式, 把命令的正确输出输出到指定的文件或设备当中\n\n\n标准错误输出重定向\n\n\n\n符号\n作用\n\n\n\n错误命令 2&gt;文件\n以覆盖的方式, 把命令的错误输出输出到指定的文件或设备当中\n\n\n错误命令 2&gt;&gt;文件\n以追加的方式, 把命令的错误输出输出到指定的文件或设备当中\n\n\n正确输出和错误输出同时保存\n\n\n\n符号\n作用\n\n\n\n命令 &gt; 文件 2&gt;&amp;1\n以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中\n\n\n命令 &gt;&gt; 文件 2&gt;&amp;1\n以追加的方式, 把正确输出和错误输出都保存到同一个文件当中\n\n\n命令 &amp;&gt;文件\n以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中\n\n\n命令 &amp;&gt;&gt;文件\n以追加的方式, 把正确输出和错误输出都保存到同一个文件当中\n\n\n命令 &gt;&gt;文件1  2&gt;&gt;文件2\n把正确的输出追加到文件 1 中, 把错误的输出追加到文件 2 中\n\n\n\n注意: 错误输出2和&gt;之间不能有空格, 至于&gt;之后有没有空格无所谓, 为了方便记忆, 错误输出前后都不要加空格了\n\n(三) 输入重定向同时也支持输入重定向\n代码示例 : 在文件 var.ini 中统一定义变量, 通过脚本读出\na=1b=2c=3\n\n#!/bin/bash# 中心思想就是把a=1,b=2,c=3引入进来声明,这里用到read命令做重定向,可以一次读取一行# eval命令用于重新运算求出参数的内容,还可读取一连串的参数，然后再依参数本身的特性来执行while read line;do\teval $linedone &lt; var.iniecho $aecho $becho $c\n\n代码示例 : 统计 err.log 的行数,单词数和字节数\n[root@localhost ~]# wc &lt; err.log\n\n(四) 垃圾桶解释一下比较常用的 &amp;&gt;/dev/null 这个命令  \n&amp;&gt; 输出, /dev/null 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 &amp;&gt;/dev/null, 用于屏蔽命令的提示信息\njava -jar xxx.jar &amp;&gt;/dev/null\n\n\n\n\n","categories":["服务器"],"tags":["shell"]},{"title":"shell入门","url":"/2023/01/27/shell%E5%85%A5%E9%97%A8/","content":"\nLinux三剑客, grep主打查找功能, sed主要是编辑, awk主要是分割处理\n\n一 : Shell 概述(一) 什么是 ShellShell 是一个用 C 语言编写的程序, 它是用户使用 Linux 的桥梁。Shell 既是一种命令语言, 又是一种程序设计语言。\nShell 是指一种应用程序, 这个应用程序提供了一个界面, 用户通过这个界面访问操作系统内核的服务。\n硬件 &#x3D;&gt; 内核 &#x3D;&gt; shell命令解释器 &#x3D;&gt; 外层应用程序\nKen Thompson 的 sh 是第一种 Unix Shell, Windows Explorer 是一个典型的图形界面 Shell。\n(二) Shell 脚本Shell 脚本(shell script), 是一种为 shell 编写的脚本程序。\n业界所说的 shell 通常都是指 shell 脚本, 但读者朋友要知道, shell 和 shell script 是两个不同的概念。\n由于习惯的原因, 简洁起见, 本文出现的 “shell编程” 都是指 shell 脚本编程, 不是指开发 shell 自身。\nshell命令解释器 : 把命令翻译成机器语言, 再把结果翻译成命令\n(三) shell 的分类\n\n\nShell 类别\n易学性\n可移植性\n编辑性\n快捷性\n\n\n\nBourne Shell (sh)\n容易\n好\n较差\n较差\n\n\nKorn Shell (ksh)\n较难\n较好\n好\n较好\n\n\nBourne Again (Bash)\n难\n较好\n好\n好\n\n\nPOSIX Shell (psh)\n较难\n好\n好\n较好\n\n\nC Shell (csh)\n较难\n差\n较好\n较好\n\n\nTC Shell (tcsh)\n难\n差\n好\n好\n\n\nShell 的两种主要语法类型有 Bourne 和 C, 这两种语法彼此不兼容。\n\nBourne 家族主要包括 sh、ksh、Bash、psh、zsh；\nC 家族主要包括:csh、tcsh (Bash 和 zsh 在不同程度上支持 csh 的语法)。\n\n我们可以通过 /etc/shells 文件来查询 Linux 支持的 Shell。命令如下 :\n[root@localhost ~]# vi /etc/shells/bin/sh/bin/Bash/sbin/nologin/bin/tcsh/bin/csh\n\n\n\n二 : 特殊符号\n\n\n符 号\n作 用\n\n\n\n‘’\n单引号。在单引号中所有的特殊符号, 如”$”和”&#96;”(反引号)都没有特殊含义。\n\n\n“”\n双引号。在双引号中特殊符号都没有特殊含义, 但是”$”、”&#96;”和”\\“是例外, 拥有”调用变量的值”、”引用命令”和”转义符”的特殊含义。\n\n\n&#96;&#96;\n反引号。反引号括起来的内容是系统命令, 在 Bash 中会先执行它。和$()作用一样, 不过推荐使用$(), 因为反引号非常容易看错。\n\n\n$\n用于调用变量的值, 如需要调用变量 name 的值时, 需要用 $name 的方式得到变量的值。\n\n\n${}\n括号里面写变量, 相当于 $name\n\n\n$()\n和反引号作用一样, 用来引用系统命令。例如: $(df -h)\n\n\n$[]\n括号里面运算式, 也可以用 $((...)), 例如: $[1+2]\n\n\n$(())\n括号里面写运算式, 和 $[] 作用一样, 例如: $((1+2))\n\n\n()\n用于一串命令执行时, ()中的命令会在子 Shell 中运行\n\n\n{}\n用于一串命令执行时, {}中的命令会在当前 Shell 中执行。也可以用于变量变形与替换。\n\n\n[]\n用于变量的测试。\n\n\n#\n在 Shell 脚本中, #开头的行代表注释。\n\n\n\\\n转义符, 跟在 \\ 之后的特殊符号将失去特殊含义, 变为普通字符。如 \\$ 将输出”$”符号, 而不当做是变量引用。\n\n\n三 : 变量(一) 用户自定义变量这种变量是最常见的变量, 由用户自由定义变量名和变量的值。\n注意变量定义的时候 : 变量名不能以数字开头, =两边不要写空格, 变量值必须是连续的字符串\n#变量名不能用数字开头[root@localhost ~]# 2name=&quot;Bob Han&quot;-bash: 2name=Bob: command not found#等号左右两侧不能有空格[root@localhost ~]# name = &quot;Bob Han&quot;-bash: name: command not found#变量的值如果有空格, 必须用引号包含[root@localhost ~]# name=Bob Han-bash: Han: command not found\n\n变量调用就直接使用 $变量名 即可\n#输出变量 name 的值[root@localhost ~]# echo $nameBob\n\n变量查看 : 直接使用 set 命令, 会查询系统中所有的变量, 包含用户自定义变量和环境变量\n[root@localhost ~]# set [选项]选项:-u: 如果设定此选项, 调用未声明变量时会报错(默认无任何提示)-x: 如果设定此选项, 在命令执行之前, 会把命令先输出一次\n\n删除变量 : unset\n# 注意: 直接写变量名,不加$符号[root@localhost ~]# unset name\t\n\n(二) 环境变量这种变量中主要保存的是和系统操作环境相关的数据, 比如当前登录用户, 用户的家目录, 命令的提示符等\n\n环境变量的变量名可以自由定义, 但是一般对系统起作用的环境变量的变量名是系统预先设定好的\n系统自带的环境变量 : 命令是确定的, 作用是确定的, 但内容可以自定义\n用户自定义的环境变量 : 命令, 作用和内容都可以自定义\n环境变量名建议大写, 便于区分\n\n环境变量设置\n# 使用 export 声明的变量即是环境变量[root@localhost ~]# export age=&quot;18&quot;\n\n环境变量查询和删除\n# 查询环境变量gender,env 命令只能查看环境变量,而set命令可以查看所有变量[root@localhost ~]# env | grep gender# 删除环境变量gender[root@localhost ~]# unset gender\n\n系统默认环境变量 PATH : 系统查找命令的路径\n# PATH变量的值是用&quot;:&quot;分割的路径,这些路径就是系统查找命令的路径[root@localhost ~]# echo $PATH/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\n\n\n也就是说, 如果将test.sh放到 /root/bin (其中一个目录)下, 程序也可以直接执行; 或者定义 PATH=$PATH:/root/sh 将脚本所在目录追加进去\n\n系统默认环境变量 PS1 : 命令提示符设置\n# 默认的提示符是显示&quot;[用户名@简写主机名 最后所在目录]提示符&quot;[root@localhost ~]# echo $PS1[\\u@\\h \\W]\\$\n\n\n如果需要永久修改, 可以写入配置文件 /etc/bashrc\n\n系统默认环境变量 LANG : 语系变量\n[root@localhost src]# echo $LANGzh_CN.UTF-8# 查询支持的语系[root@localhost src]# locale -a | more# 查询当前系统的语系(当前系统使用的语系)[root@localhost src]# localeLANG=zh_CN.UTF-8LC_CTYPE=&quot;zh_CN.UTF-8&quot;LC_NUMERIC=&quot;zh_CN.UTF-8&quot;LC_TIME=&quot;zh_CN.UTF-8&quot;LC_COLLATE=&quot;zh_CN.UTF-8&quot;LC_MONETARY=&quot;zh_CN.UTF-8&quot;LC_MESSAGES=&quot;zh_CN.UTF-8&quot;LC_PAPER=&quot;zh_CN.UTF-8&quot;LC_NAME=&quot;zh_CN.UTF-8&quot;LC_ADDRESS=&quot;zh_CN.UTF-8&quot;LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;LC_ALL=# 查询系统的默认语系(下次重启之后系统所使用的语系)[root@localhost src]# cat /etc/sysconfig/i18n LANG=&quot;zh_CN.UTF-8&quot;\n\n(三) 位置参数变量这种变量主要是用来向脚本当中传递参数或数据的, 变量名不能自定义, 变量作用是固定的; 只有内容可以自定义\n\n\n\n位置参数变量\n作用\n\n\n\n$n\nn 为数字, $0 代表命令本身, $1-$9 代表第一到第九个参数, 十以上的参数需要用大括号包含, 如${10}\n\n\n$*\n这个变量代表命令行中所有的参数, $*把所有的参数看成一个整体\n\n\n$@\n这个变量也代表命令行中所有的参数, 不过**$@把每个参数区分对待**\n\n\n$#\n这个变量代表命令行中所有参数的个数\n\n\n(四) 预定义变量是 Bash 中已经定义好的变量, 变量名不能自定义, 变量作用也是固定的; 只有内容可以自定义\n\n\n\n预定义变量\n作 用\n\n\n\n$?\n最后一次执行的命令的返回状态。如果这个变量的值为 0, 证明上一个命令正确执行；如果这个变量的值为非 0(具体是哪个数, 由命令自己来决定), 则证明上一个命令执行不正确了\n\n\n$$\n当前进程的进程号(PID)\n\n\n$!\n后台运行的最后一个进程的进程号(PID)\n\n\n四 : 通配符和正则表达式(一) 通配符\n\n\n通配符\n作 用\n示例\n\n\n\n?\n匹配一个任意字符\n\n\n\n*\n匹配 0 个或任意多个任意字符, 也就是可以匹配任何内容\n\n\n\n[]\n匹配中括号中任意一个字符\n[abc] 代表一定匹配一个字符, 或者是 a, 或者是 b, 或者是 c\n\n\n[-]\n匹配中括号中任意一个字符, -代表一个范围\n[a-z]代表匹配一个小写字母。\n\n\n[^]\n逻辑非, 表示匹配不是中括号内的一个字符\n[^0-9]代表匹配一个不是数字的字符\n\n\n(二) 正则表达式(regex)\n\n\n元字符\n作用\n示例\n\n\n\n*\n前一个字符匹配 0 次或任意多次\naa* 查询a出现1次及以上\n\n\n.\n匹配除了换行符外任意一个字符\ns..d 会匹配在s和d这两个字母之间一定有两个字符的单词\n\n\n^\n匹配行首\n^hello 会匹配以 hello 开头的行\n\n\n$\n匹配行尾\nhello$ 会匹配以 hello 结尾的行\n\n\n[]\n匹配中括号中指定的任意一个字符, 只匹配一个字符\n[aeiou] 匹配任意一个元音字母, [0-9] 匹配任意一位数字, [a-z][0-9]匹配小写字和一位数字构成的两位字符\n\n\n[^]\n匹配除中括号的字符以外的任意一个字符。\n[^0-9] 匹配任意一位非数字字符, [^a-z]表示任意一位非小写字母\n\n\n\\\n转义符。用于取消特殊符号的含义\n\\.$ 查找以字符 . 结尾的行\n\n\n\\&#123;n\\&#125;\n表示其前面的字符恰好出现 n 次\n[0-9]\\&#123;4\\&#125; 匹配 4 位数字, [1][3-8][0-9]\\&#123;9\\&#125; 匹配手机号码\n\n\n\\&#123;n,\\&#125;\n表示其前面的字符出现不小于 n 次\n[0-9]\\&#123;2,\\&#125; 表示两位及以上的数字\n\n\n\\&#123;n,m\\&#125;\n表示其前面的字符至少出现n次, 最多出现m次\n[a-z]\\&#123;6,8\\&#125; 匹配 6~8 位的小写字母\n\n\n(三) 总结通常 : 正则表达式和通配符使用的场景是不同的\n\n\n\n名称\n作用\n\n\n\n正则表达式\n用来在文件内容中匹配符合条件的字符串\n\n\n通配符\n用来匹配符合条件的文件名\n\n\n其实这种区别只在 Shell 当中适用, 因为用来在文件当中搜索字符串的命令, 如 grep, awk, sed 等命令可以支持正则表达式; 而在系统当中搜索文件的命令, 如 ls, find, cp 这些命令不支持正则表达式, 所以只能使用 shell 自己的通配符来进行匹配了\n五 : 常用指令grep, awk, sed 也被称为Linux三剑客, grep主打查找功能，sed主要是编辑，awk主要是分割处理; 基础中的基础, 重点中的重点\n(一) 行提取 grep命令格式\n[root@localhost ~]# grep [选项] &quot;搜索内容&quot; 文件名选项:    -A 数字: 列出符合条件的行,并列出后续的n行     -B 数字: 列出符合条件的行,并列出前面的n行     -c: 统计找到的符合条件的字符串的次数    -i: 忽略大小写    -n: 输出行号    -v: 反向查找    --color=auto 搜索出的关键字用颜色显示\n\n代码示例\n# 查找用户信息文件/etc/passwd 中, 有多少可以登录的用户[root@localhost ~]# grep &quot;/bin/bash&quot; /etc/passwd# 查找包含有&quot;root&quot;的行, 并列出后续的3行[root@localhost ~]# grep -A 3 &quot;root&quot; /etc/passwd# 查找可以登录的用户, 并显示行号[root@localhost ~]# grep -n &quot;/bin/bash&quot; /etc/passwd# 查找不含有&quot;/bin/bash&quot;的行, 其实就是列出所有的伪用户[root@localhost ~]# grep -v &quot;/bin/bash&quot; /etc/passwd \n\n(二) 文本截取 awkawk 是一个强大的文本分析工具, 相对于 grep 的查找, sed 的编辑, awk 在其对数据分析并生成报告时, 显得尤为强大。\n简单来说awk 就是把文件逐行的读入, 以空格为默认分隔符将每行切片, 切开的部分再进行各种分析处理。\n[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;…&#x27; 文件名条件(Pattern) :     x &gt; 10 \t: 判断变量 x 是否大于 10    x == y \t: 判断变量 x 是否等于变量 y    A ~ B \t: 判断字符串 A 中是否包含能匹配 B 表达式的子字符串    A !~ B \t: 判断字符串 A 中是否不包含能匹配 B 表达式的子字符串动作(Action) :     格式化输出    流程控制语句\n\nawk 提供了一些内置变量\n\n\n\nawk 内置变量\n作用\n\n\n\n$0\n代表目前 awk 所读入的整行数据。我们已知 awk 是一行一行读入数据的, $0 就代表当前读入行的整行数据\n\n\n$n\n代表目前读入行的第 n 个字段\n\n\nNF\n当前行拥有的字段(列)总数\n\n\nNR\n当前 awk 所处理的行, 是总数据的第几行\n\n\nFS\n用户定义分隔符。awk 的默认分隔符是任何空格, 如果想要使用其他分隔符(如” : “), 就需要 FS 变量定义\n\n\nARGC\n命令行参数个数\n\n\nARGV\n命令行参数数组\n\n\nFNR\n当前文件中的当前记录数(对输入文件起始为 1)\n\n\nOFMT\n数值的输出格式(默认为%.6g)\n\n\nOFS\n输出字段的分隔符(默认为空格)\n\n\nORS\n输出记录分隔符(默认为换行符)\n\n\nRS\n输入记录分隔符(默认为换行符)\n\n\n简单代码示例\n# 输出第1列和第3列[root@localhost ~]# df -h | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;# 查询可以登录的用户的用户名和 UID[root@localhost ~]# awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\\t&quot; $3 &#125;&#x27; /etc/passwd\n\nawk 还提供了保留字, 保留字可以看作是条件的一种, 必须大写\n\n\n\n保留字\n说明\n\n\n\nBEGIN\n在 awk 程序一开始时,尚未读取任何数据之前执行; BEGIN 后的动作只在程序开始时执行一次\n\n\nEND\n在 awk 程序处理完所有数据,即将结束时执行; END 后的动作只在程序结束时执行一次\n\n\n保留字代码示例\n# BEGIN和END都只会执行一次[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;开始&quot;&#125; &#123;print $1 &quot;:&quot; $3&#125; END&#123;print &quot;完毕&quot;&#125;&#x27; # awk命令只要检测不到完整的单引号不会执行,所以这个命令的换行不用加入&quot;\\&quot;,就是一行命令[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;统计开始:&quot;&#125; &gt; &#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125; END&#123;print &quot;统计完毕&quot;&#125;&#x27;\n\nawk 的条件 : 关系运算符\n\n\n\n条件\n说明\n\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&#x3D;&#x3D;\n等于。用于判断两个值是否相等,如果是给变量赋值,请使用=号\n\n\n!&#x3D;\n不等于\n\n\nA~B\n判断字符串 A 中是否包含能匹配 B 表达式的子字符串, 比字符串要加 //, 例如 : $2 ~ /shell/\n\n\nA!~B\n判断字符串 A 中是否不包含能匹配 B 表达式的子字符串\n\n\n条件示例代码\n# 输出使用大于0的分区及使用情况[root@localhost ~]# df -h | grep -v Used | awk &#x27;$3&gt;0&#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;# 输出vda的使用情况[root@localhost ~]# df -h | grep -v Used | awk &#x27;$1 ~ /vda/ &#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;# 如果在//中可以写入字符,也可以支持正则表达式,查询包含有vda的行,并打印第一字段和第五字段[root@localhost ~]# df -h | awk &#x27;/vda[0-9]/ &#123;printf $1 &quot;\\t&quot; $5 &quot;\\n&quot;&#125; &#x27;\n\nawk 流程控制\n# 统计 PHP 成绩的总分 [root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;totle=php1+php2+php3;print &quot;totle php is &quot; totle&#125;&#x27; awk_test.txt\n\nawk 编程也允许在编程时使用函数(不常用)\n# 定义函数test,包含两个参数,函数体的内容是输出这两个参数的值[root@localhost ~]# awk &#x27;function test(a,b) &#123; printf a &quot;\\t&quot; b &quot;\\n&quot; &#125; #调用函数 test,并向两个参数传递值&#123; test($2,$6) &#125; &#x27; student.txt\n\nawk 调用脚本(-f)\n# 编写脚本[root@localhost ~]# vi pass.awkBEGIN &#123;FS=&quot;:&quot;&#125;&#123; print $1 &quot;\\t&quot; $3&#125;# 调用脚本 -f[root@localhost ~]# awk -f pass.awk /etc/passwd\n\n在 awk 编程中,因为命令语句非常长, 在输入格式时需要注意以下内容 : \n\n多个 条件&#123;动作&#125; 可以用空格分割, 也可以用回车分割\n在一个动作中, 如果需要执行多个命令, 需要用 ; 分割, 或用回车分割\n在 awk 中, 变量的赋值与调用都不需要加入 $ 符\n条件中判断两个值是否相同, 请使用==, 以便和变量赋值进行区分\n\n(三) 文本操作 sedsed 主要是用来将数据进行选取, 替换, 删除, 新增的命令\n[root@localhost ~]# sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...选项 :     -n : 把经过sed处理的结果输出到屏幕(只查看sed命令操作的数据,如果不加则把所有数据都输出到屏幕)。    -e : 允许对输入数据应用多条sed命令编辑,中间用&quot;;&quot;隔开。    -r :  在 sed 中支持扩展正则表达式。    -i :  用 sed 的修改结果直接修改读取数据的文件,而不是由屏幕输出    -f 脚本文件名 : 从 sed 脚本中读入 sed 操作。和 awk 命令的 -f 非常类似。动作 :     a \\ : 追加(append),在当前行后添加一行或多行; 添加多行时,除最后一行外,每行末尾需要用&quot;\\&quot;代表数据未完结。    c \\ : 行替换(replace),用 c 后面的字符串替换原数据行; 替换多行时,除最后一行外,每行末尾需用&quot;\\&quot;代表数据未完结    i \\ : 插入(insert),在当期行前插入一行或多行; 插入多行时,除最后一行外每行末尾需要用&quot;\\&quot;代表数据未完结    d :  删除(delete),删除指定的行    p :  打印(print),输出指定的行    s :  字串替换,用一个字符串替换另外一个字符串;格式为&quot;行范围s/旧字串/新字串/&quot;(和vim中的替换格式类似)\n\n\n注意 : sed 所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出,这种情况连文件都没有), 而是把修改结果只显示到屏幕上, 除非使用 -i 选项才会直接修改文件。\n\n代码示例\n# 打印第二行[root@localhost ~]# sed -n &#x27;2p&#x27; /etc/passwd# 删除第二行到第四行的数据,但是文件本身并不会发生改变[root@localhost ~]# sed &#x27;2,4d&#x27; /etc/passwd# 在第二行后加入hello[root@localhost ~]# sed &#x27;2a hello&#x27; /etc/passwd# 如果需要多插几行,则需要用\\换行[root@localhost ~]# sed &#x27;2a hello \\&gt; world&#x27; /etc/passwd# 在第二行前插入hello,如果需要插入多行也需要\\[root@localhost ~]# sed &#x27;2i hello&#x27; /etc/passwd# 将第二行数据替换掉[root@localhost ~]# sed &#x27;2c hello world&#x27; /etc/passwd # 将第二行的bin替换成hello[root@localhost ~]# sed &#x27;2s/bin/hello/&#x27; /etc/passwd# 将第二行注释掉[root@localhost ~]# sed &#x27;2s/^/#/&#x27; /etc/passwd# 将第二行和第四行注释掉,用;隔开[root@localhost ~]# sed &#x27;2s/bin/hello/;3s/daemon/world/&#x27; /etc/passwd\n\n(四) 列提取 cutcut 命令的默认分隔符是制表符, 也就是 tab 键, 不支持空格\n[root@localhost ~]# cut OPTION... [FILE]...选项 : -f column_number \t: 提取第几列-d separate \t\t: 按照指定分隔符分割列(默认分隔符是制表符)-c number \t\t\t: 不依赖分隔符来区分列,而是通过字符范围(行首为0)来进行字段提取(了解)\t\t\t\t\t\t&quot;n-&quot;表示从第n个字符到行尾; \t\t\t\t\t\t&quot;n-m&quot;从第n个字符到第m个字符; \t\t\t\t\t\t&quot;-m&quot;表示从第1个字符到第m个字符。\n\n代码示例\n# 提取第二列内容[root@localhost ~]# cut -f 2 test.txt# 那如果想要提取多列呢? 只要列号直接用&quot;,&quot;分开[root@localhost ~]# cut -f 2,3 cut_test.txt # 查询普通用户的用户名和用户ID[yuelu@localhost ~]$ grep &quot;/bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1,3# 按照字符进行提取,c表示character,后面跟表达式,8-代表的是提取所有行的第8个字符开始到行尾(10-20代表提取所有行的第10个字符到第20个字符,-8代表提取所有行从行首到第8个字符) [root@localhost ~]# cut -c 8- cut_test.txt \n\n(五) 排序命令 sort[root@localhost ~]# sort [选项] 文件名选项 : -f :  忽略大小写-b :  忽略每行前面的空白部分-n :  以数值型进行排序,默认使用字符串型排序-r :  反向排序-u :  删除重复行。就是 uniq 命令-t :  指定分隔符,默认是分隔符是制表符-k n[,m] :  按照指定的字段范围排序。从第n字段开始,m字段结束(默认到行尾)\n\n代码示例\n# 排序用户信息文件,默认是用每行开头第一个字符来进行排序[root@localhost ~]# sort /etc/passwd# 反向排序-r[root@localhost ~]# sort -r /etc/passwd# 指定分隔符是&quot;:&quot;,排序范围是第三个(用第三字段开头,第三字段结尾排序)[root@localhost ~]# sort -t &quot;:&quot; -k 3,3 /etc/passwd\n\n(六) 去重命令 uniquniq 命令是用来取消重复行的命令, 其实和 sort -u 选项是一样的\n[root@localhost ~]# uniq [选项] 文件名选项 : \t-i :  忽略大小写\n\n(七) 统计命令 wc[root@localhost ~]# wc [选项] 文件名选项 :     -l : 只统计行数(print the newline counts)    -w : 只统计单词数(print the word counts)    -m : 只统计字符数(print the character counts)    -c : print the byte counts\n\n\n\n","categories":["服务器"],"tags":["shell"]},{"title":"服务器内存占用过高","url":"/2023/01/20/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/","content":"\n服务器内存占用过高, 缓存不释放导致死机,  重启后持续几天再次占满\n\n一 : 故障现象\n服务器内存占用过高, 导致死机\n服务器硬重启 3-5 天再次占满\n\n二 : 问题排查\ncpu 使用率 : top\n定时任务 crontab -l\n文件的读取和写入 : ftp, log\n\n三 : 解决方案(一) 手动清理\n可手动清理页文件缓存\n# To free pagecache:echo 1 &gt; /proc/sys/vm/drop_caches\n\n清理可回收 slab 对象(slab 分配算法采用 cache 存储内核对象, 当需要内核数据结构的对象时, 可以直接从cache 上直接获取, 并将对象初始化为使用) \n# To free reclaimable slab objects (includes dentries and inodes):# reclaimable: 可回收echo 2 &gt; /proc/sys/vm/drop_caches\n\n清理 slab 对象和 pagecache\n# To free slab objects and pagecache:echo 3 &gt; /proc/sys/vm/drop_caches\n\n(二) 设置最低剩余内存\n修改 sysctl.conf 配置文件\nvim /etc/sysctl.conf# 最后加入一行vm.min_free_kbytes = 2097152\n\n使配置文件生效\n$ sudo sysctl -p\n\n第一种方法直接清空缓存, 可能会造成数据丢失, 我们选用第二种\n\n\n","categories":["服务器"],"tags":["内存"]},{"title":"Arthas","url":"/2023/01/13/arthas/","content":"\njava 诊断工具, 用于生产环境调错\n\n一 : 概述(一) 概述Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。\n(二) 背景通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 IDE 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。\n开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。\n如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 JVM 重新启动，它可能无法复现，如上文所述。\nArthas 旨在解决这些问题。开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。\n(三) 用途Arthas 是 Alibaba 开源的 Java 诊断工具。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：\n\n这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？\n我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n是否有一个全局视角来查看系统的运行状况？\n有什么办法可以监控到 JVM 的实时运行状态？\n怎么快速定位应用的热点，生成火焰图？\n怎样直接从 JVM 内查找某个类的实例？\n\n二 : 快速入门(一) 下载启动\n下载 jar 包\n$ curl -O https://arthas.aliyun.com/arthas-boot.jar\n\n启动\n# 执行该程序的用户需要和目标进程具有相同的权限$ java -jar arthas-boot.jar# 可以执行如下命令来查看帮助$ java -jar arthas-boot.jar -h\n\n选择应用 : 数据对应程序的编号, 然后回车即可\n\n未进入指定程序退出 : ctrl + c\n\n进入指定程序后退出 : ctrl + d\n\n\n(二) 常用操作\ndashboard : 选择指定程序后, 输入 dashboard 后回车, 即可进入看板, 按 ctrl+c 可以中断执行\n$ dashboard\n\n\n主要涉及到当前执行的线程, 内存情况和运行环境\n\n\nthread : 查看当前线程, 命令 : thread ID\n$ thread 1 | grep &#x27;main(&#x27;    at demo.MathGame.main(MathGame.java:17)\n\njad : 反编译工具, 通过 jad 来反编译 Main Class\n$ jad demo.MathGame\n\nwatch : 查看具体函数的参数和返回值\n$ watch demo.MathGame primeFactors returnObj\n\n(三) 退出\n如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。\n如果想完全退出 arthas，可以执行stop命令。\n\n","categories":["服务器"],"tags":["监控","诊断"]},{"title":"mysql数据统计","url":"/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/","content":"\n统计数据占用磁盘空间的大小\n\n一 : 库表结构\nMySQL 的 information_schema 数据库, 保存着数据库的容量和使用信息, 可查询数据库中每个表占用的空间, 表记录的行数\n\nTABLES 表结构\nCREATE TEMPORARY TABLE `TABLES` (  `TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_NAME` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_TYPE` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `ENGINE` varchar(64) DEFAULT NULL,  `VERSION` bigint(21) unsigned DEFAULT NULL,  `ROW_FORMAT` varchar(10) DEFAULT NULL,  `TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,  `AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_FREE` bigint(21) unsigned DEFAULT NULL,  `AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,  `CREATE_TIME` datetime DEFAULT NULL,  `UPDATE_TIME` datetime DEFAULT NULL,  `CHECK_TIME` datetime DEFAULT NULL,  `TABLE_COLLATION` varchar(32) DEFAULT NULL,  `CHECKSUM` bigint(21) unsigned DEFAULT NULL,  `CREATE_OPTIONS` varchar(255) DEFAULT NULL,  `TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &#x27;&#x27;) ENGINE=MEMORY DEFAULT CHARSET=utf8\n\n重点字段说明\n\n\n\n字段\n解释\n\n\n\nTABLE_SCHEMA\n数据库名\n\n\nTABLE_NAME\n表名\n\n\nENGINE\n存储引擎\n\n\nTABLE_ROWS\n记录数\n\n\nDATA_LENGTH\n数据大小(单位B)\n\n\nINDEX_LENGTH\n索引大小\n\n\n\n\n二 : 查询示例(一) 数据总占用量\n求和 &#x3D;&gt; 单位转换 &#x3D;&gt; 加单位\nselect \tconcat(round(sum(DATA_LENGTH/1024/1024/1024),2),&#x27;GB&#x27;) as data from information_schema.TABLES\n\n(二) 每个表占用量\ntable_name, table_rows, data_length\nselect \ttable_name, \tconcat(round(sum(data_length/1024/1024/1024),2),&#x27;G&#x27;) as data from information_schema.tables where table_schema=&#x27;dbname&#x27; group by table_name order by data desc;\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"netty零拷贝","url":"/2020/07/31/netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/","content":"\n使用ByteBuf是Netty高性能很重要的一个原因 !\n\n一 : ByteBufByteBuf 是为解决 ByteBuffer 的问题和满足网络应用程序开发人员的日常需求而设计的。\nJDK ByteBuffer的缺点︰\n\n无法动态扩容 : 长度是固定, 不能动态扩展和收缩, 当数据大于ByteBuffer容量时, 会发生索引越界异常。\nAPI使用复杂 : 读写的时候需要手工调用flip()和rewind()等方法, 使用时需要非常谨慎的使用这些api,否则很容出现错误\n\nByteBuf 做了哪些增强\n\nAPI操作便捷性\n动态扩容\n多种 ByteBuf实现\n高效的零拷贝机制\n\n二 : ByteBuf 操作ByteBuf 三个重要属性 : capacity容量、readerIndex读取位置、writerIndex写入位置。\n提供了两个指针变量来支持顺序读和写操作, 分别是readerIndex和写操作writerIndex\n常用方法定义\n\n随机访问索引 getByte\n顺序读read*\n顺序写write*\n清除已读内容discardReadBytes\n清除缓冲区clear\n搜索操作\n标记和重置\n引用计数和释放\n\n下图显示了一个缓冲区是如何被两个指针分割成三个区域的\n \n代码示例\npublic class ByteBufDemo &#123;    @Test    public void apiTest() &#123;        // 1.创建一个非池化的ByteBuf, 大小为10个字节        ByteBuf buf = Unpooled.buffer(10);        System.out.println(&quot;原始ByteBuf为====================&gt;&quot; + buf.toString());        System.out.println(&quot;1.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 2.写入一段内容        byte[] bytes = &#123;1, 2, 3, 4, 5&#125;;        buf.writeBytes(bytes);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());        System.out.println(&quot;2.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 3.读取一段内容        byte b1 = buf.readByte();        byte b2 = buf.readByte();        System.out.println(&quot;读取的bytes为====================&gt;&quot; + Arrays.toString(new byte[]&#123;b1, b2&#125;));        System.out.println(&quot;读取一段内容后ByteBuf为===========&gt;&quot; + buf.toString());        System.out.println(&quot;3.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 4.将读取的内容丢弃        buf.discardReadBytes();        System.out.println(&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot; + buf.toString());        System.out.println(&quot;4.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 5.清空读写指针        buf.clear();        System.out.println(&quot;将读写指针清空后ByteBuf为==========&gt;&quot; + buf.toString());        System.out.println(&quot;5.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 6.再次写入一段内容, 比第一段内容少        byte[] bytes2 = &#123;1, 2, 3&#125;;        buf.writeBytes(bytes2);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes2));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());        System.out.println(&quot;6.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 7.将ByteBuf清零        buf.setZero(0, buf.capacity());        System.out.println(&quot;将内容清零后ByteBuf为==============&gt;&quot; + buf.toString());        System.out.println(&quot;7.ByteBuf中的内容为================&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 8.再次写入一段超过容量的内容        byte[] bytes3 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;        buf.writeBytes(bytes3);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes3));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());        System.out.println(&quot;8.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        //  随机访问索引 getByte        //  顺序读 read*        //  顺序写 write*        //  清除已读内容 discardReadBytes        //  清除缓冲区 clear        //  搜索操作        //  标记和重置        //  完整代码示例：参考        // 搜索操作 读取指定位置 buf.getByte(1);        //    &#125;&#125;\n\n三 : ByteBuf 动态扩容capacity默认值:256字节、最大值:Integer.MAX_VALUE ( 2GB)\nwrite* 方法调用时, 通过 AbstractByteBuf.ensureWritable0 进行检查。\n容量计算方法 : AbstractByteBufAllocator. calculateNewCapacity (新capacity的最小要求, capacity最大值), 根据新capacity的最小值要求, 对应有两套计算方法:\n\n没超过4兆 : 从64字节开始, 每次增加一倍, 直至计算出来的newCapacity满足新容量最小要求。示例 : 当前大小256, 已写250, 继续写10字节数据, 需要的容量最小要求是261, 则新容量是  64 * 2 * 2 * 2&#x3D;512\n超过4兆 : 新容量 &#x3D; 新容量最小要求&#x2F;4兆 * 4兆＋4兆; 示例:当前大小3兆, 已写3兆, 继续写2兆数据, 需要的容量最小要求是5兆, 则新容量是9兆(不能超过最大值)。\n\n四 : ByteBuf 的具体实现3个维度, 8种实现\n \nunsafe意味着不安全的操作。但是更底层的操作会带来性能提升和特殊功能, Netty中会尽力使用unsafe。\nJava语言很重要的特性是“一次编写到处运行”, 所以它针对底层的内存或者其他操作, 做了很多封装。而unsafe提供了一系列我们操作底层的方法, 可能会导致不兼容或者不可知的异常。\n\nInfo.仅返回一些低级的内存信息 : addressSize, pageSize\nObjects.提供用于操作对象及其字段的方法 : allocatelnstance, objectFieldOffset\nClasses.提供用于操作类及其静态字段的方法 : staticFieldoffset, defineClass, defineAnonymousClass, ensureClassInitialized\nSynchronization.低级的同步原语 : monitorEnter, tryMonitorEnter, monitorExit, compareAndSwaplnt, putOrderedInt\nMemory.直接访问内存方法 : allocateMemory, copyMemory, freeMemory, getAddress, getln, tputlnt\nArrays.操作数组 : arrayBaseOffset, arrayIndexScale\n\n在使用中, 都是通过 ByteBufAllocator 分配器进行申请, 同时分配器具备有内存管理的功能\n代码示例\n/** * 堆外内存的常规API */public class DirectByteBufDemo &#123;    @Test    public void apiTest() &#123;        // 1.创建一个非池化的ByteBuf, 大小为10个字节        ByteBuf buf = Unpooled.directBuffer(10);        System.out.println(&quot;原始ByteBuf为====================&gt;&quot; + buf.toString());        // System.out.println(&quot;1.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 2.写入一段内容        byte[] bytes = &#123;1, 2, 3, 4, 5&#125;;        buf.writeBytes(bytes);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());        //System.out.println(&quot;2.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 3.读取一段内容        byte b1 = buf.readByte();        byte b2 = buf.readByte();        System.out.println(&quot;读取的bytes为====================&gt;&quot; + Arrays.toString(new byte[]&#123;b1, b2&#125;));        System.out.println(&quot;读取一段内容后ByteBuf为===========&gt;&quot; + buf.toString());       //System.out.println(&quot;3.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 4.将读取的内容丢弃        buf.discardReadBytes();        System.out.println(&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot; + buf.toString());        //System.out.println(&quot;4.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 5.清空读写指针        buf.clear();        System.out.println(&quot;将读写指针清空后ByteBuf为==========&gt;&quot; + buf.toString());        //System.out.println(&quot;5.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 6.再次写入一段内容, 比第一段内容少        byte[] bytes2 = &#123;1, 2, 3&#125;;        buf.writeBytes(bytes2);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes2));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());       // System.out.println(&quot;6.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 7.将ByteBuf清零        buf.setZero(0, buf.capacity());        System.out.println(&quot;将内容清零后ByteBuf为==============&gt;&quot; + buf.toString());       // System.out.println(&quot;7.ByteBuf中的内容为================&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);        // 8.再次写入一段超过容量的内容        byte[] bytes3 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;        buf.writeBytes(bytes3);        System.out.println(&quot;写入的bytes为====================&gt;&quot; + Arrays.toString(bytes3));        System.out.println(&quot;写入一段内容后ByteBuf为===========&gt;&quot; + buf.toString());       // System.out.println(&quot;8.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\\n&quot;);    &#125;&#125;\n\n五 : PooledByteBuf 对象、内存复用PoolThreadCache : PooledByteBufAllocator 实例维护的一个线程变量。\n多种分类的 MemoryRegionCache 数组用作内存缓存，MemoryRegionCache内部是链表，队列里面存Chunk\nPoolChunk里面维护了内存引用，内存复用的做法就是把 buf 的 memory 指向 chunk 的 memory\nPooledByteBufAllocator.ioBuffer运作过程梳理\n \n六 : 零拷贝机制Netty的零拷贝机制，是一种应用层的实现。和底层JVM、操作系统内存机制并无过多关联。\nCompositeByteBuf，将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝\n  \nCompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();ByteBuf newBuffer = compositeByteBuf.addComponents(true, buffer1, buffer2);\n\nwrapedBuffer()方法，将byte[]数组包装成ByteBuf对象。\n \nByteBuf newBuffer = Unpooled.wrappedBuffer(new byte[]&#123;1,2,3,4,5]);\n\nslice()方法。将一个ByteBuf对象切分成多个ByteBuf对象。\n \nByteBuf buffer1 = Unpooled.wrappedBuffer(&quot;hello&quot;.getBytes());ByteBuf newBuffer = buffer1.slice(1,2);\n\n代码示例\n/** * 零拷贝 */public class ZeroCopyTest &#123;    @org.junit.Test    public void wrapTest() &#123;        byte[] arr = &#123;1, 2, 3, 4, 5&#125;;        ByteBuf byteBuf = Unpooled.wrappedBuffer(arr);        System.out.println(byteBuf.getByte(4));        arr[4] = 6;        System.out.println(byteBuf.getByte(4));    &#125;    @org.junit.Test    public void sliceTest() &#123;        ByteBuf buffer1 = Unpooled.wrappedBuffer(&quot;hello&quot;.getBytes());        ByteBuf newBuffer = buffer1.slice(1, 2);        newBuffer.unwrap();        System.out.println(newBuffer.toString());    &#125;    @org.junit.Test    public void compositeTest() &#123;        ByteBuf buffer1 = Unpooled.buffer(3);        buffer1.writeByte(1);        ByteBuf buffer2 = Unpooled.buffer(3);        buffer2.writeByte(4);        CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();        CompositeByteBuf newBuffer = compositeByteBuf.addComponents(true, buffer1, buffer2);        System.out.println(newBuffer);    &#125;&#125;\n\n","categories":["高性能编程"],"tags":["高并发网络编程","Netty"]},{"title":"netty责任链","url":"/2020/07/24/netty%E8%B4%A3%E4%BB%BB%E9%93%BE/","content":"\nnetty的责任链称为pipeline, 类似流水线作业, 一定要结合源码, 多看几遍\n\n一 : 设计模式 - 责任链模式责任链模式(Chain of Responsibility Pattern)为请求创建了一个处理对象的链。发起请求和具体处理请求的过程进行解耦 : 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可, 无须关心请求的处理细节和请求的传递\n\n(一) : 实现责任链模式实现责任链模式4个要素 : \n\n处理器抽象类\n具体的处理器实现类\n保存处理器信息\n处理执行\n\n伪代码示例\n// 集合形式存储: 类似tomcat中filters// 1.处理器抽象类class AbstractHandler &#123;     void doHandler(Object arg0); &#125;// 2.处理器具体实现类class Handler1 extends AbstractHandler &#123; assert coutinue; &#125;class Handler2 extends AbstractHandler &#123; assert coutinue; &#125;class Handler3 extends AbstractHandler &#123; assert coutinue; &#125;// 3.创建集合并存储所有处理器实例信息List handlers = new List();handlers.add(handler1, handler2, handler3);// 4.处理请求，调用处理器()void Process(request)&#123;    for( handler in handlers)&#123;        handler.doHandler(request) ;    &#125;&#125;// 发起请求调用，通过责任链处理请求call.process(request);\n\n//链表形式调用: 参考netty的实现形式// 1.处理器抽象类class AbstractHandler &#123;    AbstractHandle next;//下一个节点    void doHandler (Object argo); // handler方法&#125;// 2.处理器具体实现类class Handler1 extends AbstractHandler &#123; assert coutinue; &#125;class Handler2 extends AbstractHandler &#123; assert coutinue; &#125;class Handler3 extends AbstractHandler &#123; assert coutinue;&#125;// 3.将处理器串成链表存储// pipeline=头[ handler1 -&gt; handler2 -&gt;handler3]尾// 4.处理请求，调用处理器(从头到尾)void Process( request)&#123;    handler = pipeline.findOne;    //查找第一个    while(hand != null)&#123;        handler.doHandler(request);        handler = handler.next();    &#125;&#125;\n\n\n\n(二) : Netty 中的 ChannelPipeline 责任链Pipeline管道保存了通道所有处理器信息。\n创建新channel时自动创建一个专有的pipeline。入站事件和出站操作会调用pipeline上的处理器\n \n二 : 事件(一) 入站事件和出站事件入站事件 : 通常指I&#x2F;O线程生成了入站数据。(通俗理解:从socket底层自己往上冒上来的事件都是入站)\n比如EventLoop收到selector的OP_READ事件，入站处理器调用socketChannel.read(ByteBuffer)接收到数据后，这将导致通道的ChannelPipeline中包含的下一个中的channelRead方法被调用。\n出站事件 : 经常是指I&#x2F;O线程执行实际的输出操作。(通俗理解:想主动往socket底层操作的事件的都是出站)\n比如bind方法用意是请求server socket绑定到给定的SocketAddress，这将导致通道的ChannelPipeline中包含的下一个出站处理器中的bind方法被调用。\n(二) Netty 中事件的定义入站事件(inbound)\n\n\n\n事件\n描述\n\n\n\nfireChannelRegistered\nchannel注册事件\n\n\nfireChannelUnregistered\nchannel解除注册事件\n\n\nfireChannelActive\nchannel活跃事件\n\n\nfireChannelInactive\nchannel非活跃事件\n\n\nfireExceptionCaught\n异常事件\n\n\nfireUserEventTriggered\n用户自定义事件\n\n\nfireChannelRead\nchannel读事件\n\n\nfireChannelReadComplete\nchannel读完成事件\n\n\nfireChannelWritabilityChanged\nchannel写状态变化事件\n\n\n出站事件(outbound)\n\n\n\n事件\n描述\n\n\n\nbind\n端口绑定事件\n\n\nconnect\n连接事件\n\n\ndisconnect\n断开连接事件\n\n\nclose\n关闭事件\n\n\nderegister\n解除注册事件\n\n\nflush\n刷新数据到网络事件\n\n\nread\n读事件，用于注册OP_READ到selector\n\n\nwrite\n写事件\n\n\nwriteAndFlush\n写出数据事件\n\n\n三 : 处理器(一) Pipeline 中的 handler 是什么ChannelHandler : 用于处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作, 并转发到 ChannelPipeline 中的下一个处理器; 这个顶级接口定义功能很弱, 实际使用时会去实现以下两大子接口 : 处理入站 I&#x2F;O 事件的 ChannelInBoundHandler, 处理出站 I&#x2F;O 操作的 ChannelOutBoundHandler\n适配器类 : 为了开发方便, 避免所有 handler 去实现一遍接口方法, Netty 提供了简单的实现类\n\n处理入站 I&#x2F;O 事件 : ChannelInboundHandlerAdapter\n处理出站 I&#x2F;O 事件 : ChannelOutboundHandlerAdapter\n同时处理入站和出站事件 : ChannelDuplexHandler\n\nChannelHandlerContext : 实际存储在 Pipeline 中的对象并非 ChannelHandler, 而是上下文对象; 将 handler 包裹在上下文对象中, 通过上下文对象与它所属的 ChannelPipeline 交互, 向上或向下传递事件或者修改 pipeline 都是通过上下文对象\n(二) 维护 Pipeline 中的 handlerChannelPipeline是线程安全的，ChannelHandler可以在任何时候添加或删除。\n例如，你可以在即将交换敏感信息时插入加密处理程序，并在交换后删除它。\n一般操作，初始化的时候增加进去，较少删除。\nPipeline 中管理 handler 的API\n\n\n\n方法名称\n描述\n\n\n\naddFirst\n最前面插入\n\n\naddLast\n最后面插入\n\n\naddBefore\n插入到指定处理器前面\n\n\naddAfter\n插入到指定处理器后面\n\n\nremove\n移除指定处理器\n\n\nremoveFirst\n移除第一个处理器\n\n\nremoveLast\n移除最后一个处理器\n\n\nreplace\n替换指定的处理器\n\n\n伪代码示例\nChannelPipeline p = ...;p.addLast(&quot;1&quot;, new InboundHandlerA());p.addLast(&quot;2&quot;, new InboundHandlerB());p.addLast(&quot;3&quot;, new OutboundHandlerA());p.addLast(&quot;4&quot;, new OutboundHandlerB());p.addLast(&quot;5&quot;, new InboundOutboundHandlerX()); // 聚合处理器\n\n(三) handler 的执行分析按之前伪代码逻辑, 现在的责任链如图所示\n \n由此可以推断 : \n\n当入站事件时, 执行顺序是 : 1 &#x3D;&gt; 2 &#x3D;&gt; 3 &#x3D;&gt; 4 &#x3D;&gt; 5\n当出站事件时, 执行顺序是 : 5 &#x3D;&gt; 4 &#x3D;&gt; 3 &#x3D;&gt; 2 &#x3D;&gt; 1\n\n在这一原则之上, ChannelPipeline在执行时会进行选择3和4为出站处理器, 因此, 实际执行是 :\n\n入站事件的执行顺序是 1 &#x3D;&gt; 2 &#x3D;&gt; 5, 1和2为入站处理器\n出站事件的执行顺序是 5 &#x3D;&gt; 4 &#x3D;&gt; 3\n\n不同的入站事件会触发handler不同的方法执行 : \n\n上下文对象中 fire** 开头的方法, 代表入站事件传播和处理\n\n其余的方法代表出站事件的传播和处理。\n\n\n四 : 分析(一) 分析 registered 入站事件的处理 \nServerSocketChannel.pipeline的变化\n \n(二) 分析 bind 出站事件的处理 \n(三) 分析 accept 入站事件的处理 \n这是一个分配的过程，main Group负责accept，然后分配sub Group负责read\n(四) 分析 read 入站事件的处理pipeline分析的关键4要素:什么事件、有哪些处理器、哪些会被触发、执行顺序\n \n五 : 小结用户在管道中有一个或多个 channelhandler 来接收 I&#x2F;O 事件(例如读取)和请求 I&#x2F;O 操作(例如写入和关闭)\n一个典型的服务器在每个通道的管道中都有以下处理程序, 但是根据协议和业务逻辑的复杂性和特征, 可能会有所不同\n\n协议解码器 : 将二进制数据(例如 ByteBuf)转换为 Java 对象\n\n协议编码器 : 将 Java 对象转换为二进制数据\n\n业务逻辑处理程序 : 执行实际的业务逻辑(例如数据库访问)\n\n\n","categories":["高性能编程"],"tags":["高并发网络编程","Netty"]},{"title":"Netty线程模型","url":"/2020/07/17/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","content":"\n了解netty的组成结构, 同时要结合源码学习它的设计模式\n\n一 : Netty 简介Netty 是一个高性能, 高可扩展性的异步事件驱动的网络应用程序框架, 它极大地简化了 TCP 和 UDP 客户端和服务器开发等网络编程\n官网 : https://netty.io/\nNetty 重要的四个内容\n\nReactor 线程模型 : 一种高性能的多线程程序设计思路\nNetty 中自己定义的 Channel 概念 : 增强版的通道概念\nChannelPipeline 责任链设计模式 : 事件处理机制\n内存管理 : 增强的 ByteBuffer 缓冲区\n\n二 : Netty 整体结构 \n可以看出包含三大块 \n\n支持 Socket 等多种传输方式\n提供了多种协议的编解码实现\n核心设计包含事件处理模型, API的使用, ByteBuffer 的增强\n\n三 : Netty 线程模型为了让 NIO 处理更好的利用多线程特性, Netty 实现了 Reactor 线程模型\n \nReactor 模型中有四个核心概念 : \n\nResources 资源(请求&#x2F;任务)\nSynchronous Event Demutiplexer 同步事件复用器\nDispatcher 分配器\nRequest Handler 请求处理器\n\n四 : EventLoopGroup 初始化过程如图所示, 两组 EventLoopGroup (Main&amp;Sub) 处理不同通道的事件\n \n源码示例 : example\npublic final class EchoServer &#123;    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;));    public static void main(String[] args) throws Exception &#123;        // Configure SSL.        final SslContext sslCtx = ServerUtil.buildSslContext();        // Configure the server.        // 创建EventLoopGroup: accept线程组 NioEventLoop        EventLoopGroup bossGroup = new NioEventLoopGroup(1);// 指定线程数量,否则采用默认值        // 创建EventLoopGroup: I/O线程组        EventLoopGroup workerGroup = new NioEventLoopGroup();        final EchoServerHandler serverHandler = new EchoServerHandler();        try &#123;            // 服务端启动引导工具类            ServerBootstrap b = new ServerBootstrap();            // 配置服务端处理的reactor线程组以及服务端的其他配置            b.group(bossGroup, workerGroup)                .channel(NioServerSocketChannel.class)                .option(ChannelOption.SO_BACKLOG, 100)                .handler(new LoggingHandler(LogLevel.INFO))                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    public void initChannel(SocketChannel ch) throws Exception &#123;                        ChannelPipeline p = ch.pipeline();                        if (sslCtx != null) &#123;                            p.addLast(sslCtx.newHandler(ch.alloc()));                        &#125;                        //p.addLast(new LoggingHandler(LogLevel.INFO));                        p.addLast(serverHandler);                    &#125;                &#125;);            // Start the server. 通过bind启动服务            ChannelFuture f = b.bind(PORT).sync();            // Wait until the server socket is closed. 阻塞主线程,知道网络服务被关闭            f.channel().closeFuture().sync();        &#125; finally &#123;            // Shut down all event loops to terminate all threads. 关闭线程组            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;\n\n\n\n五 : EventLoop 的启动EventLoop 自身实现了 Executor 接口, 当调用 executor 方法提交任务时, 则判断是否启动, 未启动则调用内置的 executor 创建新线程来触发 run() 执行\n \n六 : Bind 绑定端口过程如图所示\n  \n七 : Channel 概念netty 中的 Channel 是一个抽象的概念, 可以理解为对 JDK NIO Channel 的增强和拓展; \n增强了很多属性和方法, 完整信息可以看源码, 下面罗列几个常见的属性和方法\npublic abstract class AbstractChannel extends DefaultAttributeMap implements Channel &#123;    // 通道内时间处理链路    private final DefaultChannelPipeline pipeline;     // 绑定的EventLoop,用于执行操作    private volatile AbstractChannel.PausableChannelEventLoop eventLoop;    // 提供IO相关操作的封装    private final Unsafe unsafe;    // 父类方法,返回通道配置信息    ChannelConfig config();    // 开始读数据,触发读取链路调用    @Override    public Channel read() &#123;        pipeline.read();        return this;    &#125;    // 写数据,触发链路调用    @Override    public ChannelFuture write(Object msg) &#123;        return pipeline.write(msg);    &#125;    // 绑定    @Override    public ChannelFuture bind(SocketAddress localAddress) &#123;        return pipeline.bind(localAddress);    &#125;&#125;\n\n\n\n八 : 小结毕竟抽象的设计模式, 在学习过程中会有难懂的地方, 所以着重需要结合代码理解\n这里的目的有两个 : 领会 Reactor 的理念, 掌握代码示例中具体的写法\n重点关注服务端开发, 因为服务端要应对海量连接, 难度大, 而客户端仅仅是一个连接\nReactor 多线程模式的设计, 是 Netty 高性能很重要的一个原因\n","categories":["高性能编程"],"tags":["高并发网络编程","Netty"]},{"title":"NIO非阻塞网络编程","url":"/2020/07/10/NIO/","content":"\nNIO : New IO, No Blocking IO, 提供了非阻塞IO, 线程利用率大大提高, 在Tomcat8中已经完全取代了BIO\n\n一 : java NIO始于 java 1.4, 提供了新的 JAVA IO 操作非阻塞 API; 用意是替代 Java IO 和 Java Networking 相关的 API\nNIO 中有三个核心组件 : Buffer, Channel, Selector\n二 : Buffer 缓冲区缓冲区本质上是一个可以写入数据的内存块(类似数组), 然后可以再次读取; 此内存块包含在 NIO Buffer 对象中, 该对象提供了一组方法, 可以更轻松地使用内存块; \n相比较直接对数组的操作, Buffer API 更加容易操作和管理; \n使用 Buffer 进行数据写入与读取, 需要进行如下四个步骤 : \n\n将数据写入缓冲区\n调用 buffer.flip(), 转换为读取模式\n缓冲区读取数据\n调用 buffer.clear() 或 buffer.compact() 清除缓冲区\n\n代码示例\npublic class BufferDemo &#123;    public static void main(String[] args) &#123;        // 构建一个byte字节缓冲区，容量是4        ByteBuffer byteBuffer = ByteBuffer.allocate(4);        // 默认写入模式，查看三个重要的指标        System.out.println(String.format(&quot;初始化：capacity容量：%s, position位置：%s, limit限制：%s&quot;, byteBuffer.capacity(),                byteBuffer.position(), byteBuffer.limit()));        // 写入2字节的数据        byteBuffer.put((byte) 1);        byteBuffer.put((byte) 2);        byteBuffer.put((byte) 3);        // 再看数据        System.out.println(String.format(&quot;写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s&quot;, byteBuffer.capacity(),                byteBuffer.position(), byteBuffer.limit()));        // 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)        System.out.println(&quot;#######开始读取&quot;);        byteBuffer.flip();        byte a = byteBuffer.get();        System.out.println(a);        byte b = byteBuffer.get();        System.out.println(b);        System.out.println(String.format(&quot;读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s&quot;, byteBuffer.capacity(),                byteBuffer.position(), byteBuffer.limit()));        // 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据        // clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式        byteBuffer.compact(); // buffer : 1 , 3        byteBuffer.put((byte) 3);        byteBuffer.put((byte) 4);        byteBuffer.put((byte) 5);        System.out.println(String.format(&quot;最终的情况，capacity容量：%s, position位置：%s, limit限制：%s&quot;, byteBuffer.capacity(),                byteBuffer.position(), byteBuffer.limit()));        // rewind() 重置position为0        // mark() 标记position的位置        // reset() 重置position为上次mark()标记的位置    &#125;&#125;\n\n\n\n(一) Buffer 工作原理Buffer 三个重要属性 \n\n\n\n名称\n描述\n\n\n\ncapacity\n作为一个内存块, Buffer 具有一定的固定大小, 也称为容量\n\n\nposition\n写入模式时代表写数据的位置; 读取模式时代表读取数据的位置\n\n\nlimit\n写入模式, 限制等于 buffer 的容量; 读取模式下, limit 等于写入的数据量\n\n\n读写模式\n \n(二) ByteBuffer 内存类型ByteBuffer 为性能关键型代码提供了**直接内存(direct堆外)和非直接内存(heap堆)**两种实现\n堆外内存获取的方式: \n//堆内存(非直接内存)ByteBuffer byteBuffer = ByteBuffer.allocate(4);//直接内存(堆外内存)ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(4);\n\n好处 : \n\n进行网络 IO 或者文件 IO 时比 heapBuffer 少一次拷贝(file&#x2F;socket &#x3D;&gt; OS memory &#x3D;&gt; jvm heap); GC 会移动对象内存, 在写 file 或 socket 的过程中, jvm 的实现中, 会先把数据复制到堆外, 再进行写入\nGC 范围之外, 降低 GC 压力, 但实现了自动管理; DirectByteBuffer 中有一个 Cleaner 对象(PhantomReference), Cleaner 被 GC 前会执行 clean(), 触发 DirectByteBuffer 中定义的 Deallocator\n\n建议 : \n\n性能确实可观的时候才去使用; 分配给大型, 长寿命的对象或应用(网络传输, 文件读写场景)\n通过虚拟机参数 MaxDirectMemorySize 限制大小, 防止耗尽整个及其的内存\n\n三 : Channel 通道在 BIO 编程中一切网络操作是通过 socket + io 两者组合进行操作的, 也就是需要 io 包和 net 包; 而在 NIO 中则只需要 nio 包即可\n \nChannel 的 API 涵盖了 UDP&#x2F;TCP 网络和文件 IO\n\nFileChannel\nDatagramChannel\nSocketChannel\nServerSocketChannel\n\n和标准 IO Stream 操作的区别\n\n在一个通道内进行读取和写入\nstream 通常是单向的(inupt 或 ouput)\n可以非阻塞读取和写入通道\n通道始终读取或写入缓冲区\n\n(一) SocketChannelSocketChannel 用于建立 TCP 网络连接, 类似 java.net.Socket; \n有两种创建 SocketChannel 形式 :\n\n客户端主动发起和服务器的连接\n服务端获取的新连接\n\n代码示例\npublic class NIOClient &#123;    public static void main(String[] args) throws Exception &#123;        // 客户端主动发起连接的方式        SocketChannel socketChannel = SocketChannel.open();        socketChannel.configureBlocking(false); // 设置为非阻塞模式        socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8080));        while (!socketChannel.finishConnect()) &#123;            // 没连接上,则一直等待            Thread.yield();        &#125;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入：&quot;);        // 发送内容        String msg = scanner.nextLine();        ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());        while (buffer.hasRemaining()) &#123;            // 发送请求数据 - 向通道写入数据            socketChannel.write(buffer);        &#125;        // 读取响应        System.out.println(&quot;收到服务端响应:&quot;);        ByteBuffer requestBuffer = ByteBuffer.allocate(1024);        // 读取服务端返回 - 读取缓冲区的数据: int bytesRead = socketChannel.read(byteBuffer)        while (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -1) &#123;            // 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)            if (requestBuffer.position() &gt; 0) break;        &#125;        requestBuffer.flip();        byte[] content = new byte[requestBuffer.limit()];        requestBuffer.get(content);        System.out.println(new String(content));        scanner.close();        // 关闭连接        socketChannel.close();    &#125;&#125;\n\n\nwrite 写 : write() 在尚未写入任何内容时就可能返回了; 需要在循环中调用 write()\nread 读 : read() 可能直接返回而根本不读取任何数据, 根据返回的 int 值判断读取了多少字节\n\n(二) ServerSocketChannelServerSocketChannel 可以监听新建的 TCP 连接通道, 类似 ServerSocket\npublic class NIOServer &#123;    public static void main(String[] args) throws Exception &#123;        // 创建网络服务端        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.configureBlocking(false); // 设置为非阻塞模式        serverSocketChannel.socket().bind(new InetSocketAddress(8080)); // 绑定端口        System.out.println(&quot;启动成功&quot;);        while (true) &#123;            SocketChannel socketChannel = serverSocketChannel.accept(); // 获取新tcp连接通道            // tcp请求 读取/响应            if (socketChannel != null) &#123;                System.out.println(&quot;收到新连接 : &quot; + socketChannel.getRemoteAddress());                socketChannel.configureBlocking(false); // 默认是阻塞的,一定要设置为非阻塞                try &#123;                    ByteBuffer requestBuffer = ByteBuffer.allocate(1024);                    while (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -1) &#123;                        // 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)                        if (requestBuffer.position() &gt; 0) break;                    &#125;                    if(requestBuffer.position() == 0) continue; // 如果没数据了, 则不继续后面的处理                    requestBuffer.flip();                    byte[] content = new byte[requestBuffer.limit()];                    requestBuffer.get(content);                    System.out.println(new String(content));                    System.out.println(&quot;收到数据,来自：&quot;+ socketChannel.getRemoteAddress());                    // 响应结果 200                    String response = &quot;HTTP/1.1 200 OK\\r\\n&quot; +                            &quot;Content-Length: 11\\r\\n\\r\\n&quot; +                            &quot;Hello World&quot;;                    ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());                    while (buffer.hasRemaining()) &#123;                        socketChannel.write(buffer);// 非阻塞                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        /*         * 这种低效的循环检查,会是NIO服务端的正确开发方式吗 ?         * 用到了非阻塞的API,在设计上,和BIO可以有很大的不同,需要仅需改进         * 其实可以有这样一种思路,如果有连接,则将连接存起来,在没有连接的时候进行数据的读取和处理         */    &#125;&#125;\n\nserverSocketChannel.accept(), 如果该通道处于非阻塞模式, 那么如果没有挂起的连接, 该方法将立即返回 null ; 必须检查返回的 SocketChannel 是否为 null\n四 : Selector 选择器Selector 是一个 java NIO 组件, 可以检查一个或多个 NIO 通道, 并确定哪些通道已准备好进行读取或写入; 实现单个线程可以管理多个通道, 从而管理多个网络连接\n  \n一个线程使用 Selector 监听多个 channel 的不同事件(四个事件分别对应 SelectionKey 四个常量) : \n\n\n\n名称\n描述\n常量\n\n\n\nOP_CONNECT\nConnect 连接\nSelectionKey.OP_CONNECT\n\n\nOP_ACCEPT\nAccept 准备就绪\nSelectionKey.OP_ACCEPT\n\n\nOP_READ\nRead 读取\nSelectionKey.OP_READ\n\n\nOP_WRITE\nWrite 写入\nSelectionKey.OP_WRITE\n\n\n实现一个线程处理多个通道的核心概念理解 : 事件驱动机制\n非阻塞的网络通道下, 开发者通过 Selector 注册对于通道感兴趣的事件类型, 线程通过监听事件来触发相应的代码执行\n拓展 : 更底层是操作系统的多路复用机制\nSelector selector = Selector.open();channel.configureBlocking(false);// 注册感兴趣的事件SelectionKey key = channel.register(selector, SelectionKey.OP_READ);// 由 accept 轮询, 变成了事件通知的方式while(true)&#123;    // select 收到新的事件, 方法才会返回    int readyChannels = selector.select();    if(readyChannels == 0) continue;    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKey();    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();    while(keyIterator.hasNext())&#123;        SelectionKey key = keyIterator.next();        // 判断不同的事件类型, 执行对应的逻辑处理        // key.isAcceptable()        // key.isConnectable()        // key.isReadable()        // key.isWritable()        keyIterator.remove()    &#125;&#125;\n\n代码示例(服务端)\npublic class NIOServerV2 &#123;    public static void main(String[] args) throws Exception &#123;        // 1. 创建网络服务端ServerSocketChannel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.configureBlocking(false); // 设置为非阻塞模式        // 2. 构建一个Selector选择器,并且将channel注册上去        Selector selector = Selector.open();        // 将serverSocketChannel注册到selector        SelectionKey selectionKey = serverSocketChannel.register(selector, 0, serverSocketChannel);        // 对serverSocketChannel上面的accept事件感兴趣(serverSocketChannel只能支持accept操作)        selectionKey.interestOps(SelectionKey.OP_ACCEPT);         // 3. 绑定端口        serverSocketChannel.socket().bind(new InetSocketAddress(8080));        System.out.println(&quot;启动成功&quot;);        while (true) &#123;            // 不再轮询通道,改用下面轮询事件的方式.select方法有阻塞效果,直到有事件通知才会有返回            selector.select();            // 获取事件            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            // 遍历查询结果e            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();            while (iter.hasNext()) &#123;                // 被封装的查询结果                SelectionKey key = iter.next();                iter.remove();                // 关注 Read 和 Accept两个事件                if (key.isAcceptable()) &#123;                    ServerSocketChannel server = (ServerSocketChannel) key.attachment();                    // 将拿到的客户端连接通道,注册到selector上面                    SocketChannel clientSocketChannel = server.accept(); // mainReactor 轮询accept                    clientSocketChannel.configureBlocking(false);                    clientSocketChannel.register(selector, SelectionKey.OP_READ, clientSocketChannel);                    System.out.println(&quot;收到新连接 : &quot; + clientSocketChannel.getRemoteAddress());                &#125;                if (key.isReadable()) &#123;                    SocketChannel socketChannel = (SocketChannel) key.attachment();                    try &#123;                        ByteBuffer requestBuffer = ByteBuffer.allocate(1024);                        while (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -1) &#123;                            // 长连接情况下,需要手动判断数据有没有读取结束(此处做一个简单的判断:超过0字节就认为请求结束了)                            if (requestBuffer.position() &gt; 0) break;                        &#125;                        if(requestBuffer.position() == 0) continue; // 如果没数据了, 则不继续后面的处理                        requestBuffer.flip();                        byte[] content = new byte[requestBuffer.limit()];                        requestBuffer.get(content);                        System.out.println(new String(content));                        System.out.println(&quot;收到数据,来自：&quot; + socketChannel.getRemoteAddress());                        // TODO 业务操作 数据库 接口调用等等                        // 响应结果 200                        String response = &quot;HTTP/1.1 200 OK\\r\\n&quot; +                                &quot;Content-Length: 11\\r\\n\\r\\n&quot; +                                &quot;Hello World&quot;;                        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());                        while (buffer.hasRemaining()) &#123;                            socketChannel.write(buffer);                        &#125;                    &#125; catch (IOException e) &#123;                        // e.printStackTrace();                        key.cancel(); // 取消事件订阅                    &#125;                &#125;            &#125;            selector.selectNow();        &#125;    &#125;&#125;\n\n问题: 此处一个selector监听所有事件,一个线程处理所有请求事件. 会成为瓶颈! 要有多线程的运用\n五 : NIO 对比 BIOBIO 线程模型\n \n\n阻塞 IO , 线程等待时间长\n一个线程负责一个连接处理\n线程多且利用率低\n\nNIO 线程模型\n \n\n非阻塞 IO , 线程利用率更高\n一个线程处理多个连接事件\n性能更强大\n\n总结 : 如果你的程序需要支撑大量的连接, 使用 NIO 是最好的方式; Tomcat8 中, 已经完全取出 BIO 相关的网络处理代码, 默认采用 NIO 进行网络处理\n六 : NIO 与多线程结合的改进方案Doug Lea 的著名文章《Scalable IO in Java》; 地址 : http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\nWorker Thread Pools : Reactor 线程接收请求 &#x3D;&gt; 分发给线程池处理请求\n \nUsing Multiple Reactors : mainReactor 接收 &#x3D;&gt; 分发给 subReactor 读写 &#x3D;&gt; 具体业务逻辑分发给单独的线程池处理\n \n代码示例 : NIO selector 多路复用reactor线程模型\npublic class NIOServerV3 &#123;    /** 处理业务操作的线程 */    private static ExecutorService workPool = Executors.newCachedThreadPool();    /**     * 封装了selector.select()等事件轮询的代码     */    abstract class ReactorThread extends Thread &#123;        Selector selector;        LinkedBlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;&gt;();        /**         * Selector监听到有事件后,调用这个方法         */        public abstract void handler(SelectableChannel channel) throws Exception;        private ReactorThread() throws IOException &#123;            selector = Selector.open();        &#125;        volatile boolean running = false;        @Override        public void run() &#123;            // 轮询Selector事件            while (running) &#123;                try &#123;                    // 执行队列中的任务                    Runnable task;                    while ((task = taskQueue.poll()) != null) &#123;                        task.run();                    &#125;                    selector.select(1000);                    // 获取查询结果                    Set&lt;SelectionKey&gt; selected = selector.selectedKeys();                    // 遍历查询结果                    Iterator&lt;SelectionKey&gt; iter = selected.iterator();                    while (iter.hasNext()) &#123;                        // 被封装的查询结果                        SelectionKey key = iter.next();                        iter.remove();                        int readyOps = key.readyOps();                        // 关注 Read 和 Accept两个事件                        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;                            try &#123;                                SelectableChannel channel = (SelectableChannel) key.attachment();                                channel.configureBlocking(false);                                handler(channel);                                if (!channel.isOpen()) &#123;                                    key.cancel(); // 如果关闭了,就取消这个KEY的订阅                                &#125;                            &#125; catch (Exception ex) &#123;                                key.cancel(); // 如果有异常,就取消这个KEY的订阅                            &#125;                        &#125;                    &#125;                    selector.selectNow();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        private SelectionKey register(SelectableChannel channel) throws Exception &#123;            // 为什么register要以任务提交的形式，让reactor线程去处理？            // 因为线程在执行channel注册到selector的过程中，会和调用selector.select()方法的线程争用同一把锁            // 而select()方法实在eventLoop中通过while循环调用的，争抢的可能性很高，为了让register能更快的执行，就放到同一个线程来处理            FutureTask&lt;SelectionKey&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; channel.register(selector, 0, channel));            taskQueue.add(futureTask);            return futureTask.get();        &#125;        private void doStart() &#123;            if (!running) &#123;                running = true;                start();            &#125;        &#125;    &#125;    private ServerSocketChannel serverSocketChannel;    // 1、创建多个线程 - accept处理reactor线程 (accept线程)    private ReactorThread[] mainReactorThreads = new ReactorThread[1];    // 2、创建多个线程 - io处理reactor线程  (I/O线程)    private ReactorThread[] subReactorThreads = new ReactorThread[8];    /**     * 初始化线程组     */    private void newGroup() throws IOException &#123;        // 创建IO线程,负责处理客户端连接以后socketChannel的IO读写        for (int i = 0; i &lt; subReactorThreads.length; i++) &#123;            subReactorThreads[i] = new ReactorThread() &#123;                @Override                public void handler(SelectableChannel channel) throws IOException &#123;                    // work线程只负责处理IO处理，不处理accept事件                    SocketChannel ch = (SocketChannel) channel;                    ByteBuffer requestBuffer = ByteBuffer.allocate(1024);                    while (ch.isOpen() &amp;&amp; ch.read(requestBuffer) != -1) &#123;                        // 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)                        if (requestBuffer.position() &gt; 0) break;                    &#125;                    if (requestBuffer.position() == 0) return; // 如果没数据了, 则不继续后面的处理                    requestBuffer.flip();                    byte[] content = new byte[requestBuffer.limit()];                    requestBuffer.get(content);                    System.out.println(new String(content));                    System.out.println(Thread.currentThread().getName() + &quot;收到数据,来自：&quot; + ch.getRemoteAddress());                    // TODO 业务操作 数据库、接口...                    workPool.submit(() -&gt; &#123;                    &#125;);                    // 响应结果 200                    String response = &quot;HTTP/1.1 200 OK\\r\\n&quot; +                            &quot;Content-Length: 11\\r\\n\\r\\n&quot; +                            &quot;Hello World&quot;;                    ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());                    while (buffer.hasRemaining()) &#123;                        ch.write(buffer);                    &#125;                &#125;            &#125;;        &#125;        // 创建mainReactor线程, 只负责处理serverSocketChannel        for (int i = 0; i &lt; mainReactorThreads.length; i++) &#123;            mainReactorThreads[i] = new ReactorThread() &#123;                AtomicInteger incr = new AtomicInteger(0);                @Override                public void handler(SelectableChannel channel) throws Exception &#123;                    // 只做请求分发，不做具体的数据读取                    ServerSocketChannel ch = (ServerSocketChannel) channel;                    SocketChannel socketChannel = ch.accept();                    socketChannel.configureBlocking(false);                    // 收到连接建立的通知之后，分发给I/O线程继续去读取数据                    int index = incr.getAndIncrement() % subReactorThreads.length;                    ReactorThread workEventLoop = subReactorThreads[index];                    workEventLoop.doStart();                    SelectionKey selectionKey = workEventLoop.register(socketChannel);                    selectionKey.interestOps(SelectionKey.OP_READ);                    System.out.println(Thread.currentThread().getName() + &quot;收到新连接 : &quot; + socketChannel.getRemoteAddress());                &#125;            &#125;;        &#125;    &#125;    /**     * 初始化channel,并且绑定一个eventLoop线程     *     * @throws IOException IO异常     */    private void initAndRegister() throws Exception &#123;        // 1、 创建ServerSocketChannel        serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.configureBlocking(false);        // 2、 将serverSocketChannel注册到selector        int index = new Random().nextInt(mainReactorThreads.length);        mainReactorThreads[index].doStart();        SelectionKey selectionKey = mainReactorThreads[index].register(serverSocketChannel);        selectionKey.interestOps(SelectionKey.OP_ACCEPT);    &#125;    /**     * 绑定端口     *     * @throws IOException IO异常     */    private void bind() throws IOException &#123;        //  1、 正式绑定端口，对外服务        serverSocketChannel.bind(new InetSocketAddress(8080));        System.out.println(&quot;启动完成，端口8080&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        NIOServerV3 nioServerV3 = new NIOServerV3();        // 1.创建main和sub两组线程        nioServerV3.newGroup();         // 2.创建serverSocketChannel，注册到mainReactor线程上的selector上        nioServerV3.initAndRegister();        // 3.为serverSocketChannel绑定端口        nioServerV3.bind();     &#125;&#125;\n\n\n\n七 : 小结NIO 为开发者提供了功能丰富及强大的 IO 处理 API, 但是在应用于网络应用开发的过程中, 直接使用 JDK 提供的 API, 比较繁琐; 而且要想将性能进行提升, 光有 NIO 还不够, 还需要将多线程技术与之结合起来\n因为网络编程本身的复杂性, 以及 JDK API 开发的使用难度较高, 所以在开源社区中, 捅出来很多 JDK NIO 进行封装, 增强后的网络编程框架, 例如 : Netty, Mina等 \n","categories":["高性能编程"],"tags":["高并发网络编程","NIO网络编程"]},{"title":"BIO阻塞式网络编程","url":"/2020/07/03/BIO/","content":"\nBIO : Blocking IO, 阻塞式IO\n\n一 : 简单 C&#x2F;S 程序服务端示例\npublic class BIOServer &#123;    public static void main(String[] args) throws Exception &#123;        ServerSocket serverSocket = new ServerSocket(8080);        System.out.println(&quot;服务器启动成功&quot;);        while (!serverSocket.isClosed()) &#123;            Socket request = serverSocket.accept();// 阻塞            System.out.println(&quot;收到新连接 : &quot; + request.toString());            try &#123;                // 接收数据、打印                InputStream inputStream = request.getInputStream(); // net + i/o                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;utf-8&quot;));                String msg;                while ((msg = reader.readLine()) != null) &#123; // 没有数据，阻塞                    if (msg.length() == 0) &#123;                        break;                    &#125;                    System.out.println(msg);                &#125;                System.out.println(&quot;收到数据,来自：&quot;+ request.toString());            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; finally &#123;                try &#123;                    request.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        serverSocket.close();    &#125;&#125;\n\n客户端示例\npublic class BIOClient &#123;    private static Charset charset = Charset.forName(&quot;UTF-8&quot;);    public static void main(String[] args) throws Exception &#123;        Socket s = new Socket(&quot;localhost&quot;, 8080);        OutputStream out = s.getOutputStream();        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入：&quot;);        String msg = scanner.nextLine();        out.write(msg.getBytes(charset)); // 阻塞，写完成        scanner.close();        s.close();    &#125;&#125;\n\n\n\n二 : Http 协议代码示例(和浏览器交互)\n// 使用多线程技术public class BIOServer1 &#123;    private static ExecutorService threadPool = Executors.newCachedThreadPool();    public static void main(String[] args) throws Exception &#123;        ServerSocket serverSocket = new ServerSocket(8080);        System.out.println(&quot;tomcat 服务器启动成功&quot;);        while (!serverSocket.isClosed()) &#123;            Socket request = serverSocket.accept();            System.out.println(&quot;收到新连接 : &quot; + request.toString());            threadPool.execute(() -&gt; &#123;                try &#123;                    // 接收数据、打印                    InputStream inputStream = request.getInputStream();                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;utf-8&quot;));                    String msg;                    while ((msg = reader.readLine()) != null) &#123; // 阻塞                        if (msg.length() == 0) &#123;                            break;                        &#125;                        System.out.println(msg);                    &#125;                    System.out.println(&quot;收到数据,来自：&quot;+ request.toString());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    try &#123;                        request.close();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;        serverSocket.close();    &#125;&#125;\n\n\n\n请求数据包解析\n# 第一部分: 请求行,请求类型,资源路径以及HTTP版本GET /servlet-demo-1.0.0/index HTTP/1.1# 第二部分: 请求头部,紧接着请求行(即第一行)之后的部分,用来说明服务器要使用的附加信息Cache-Control: max-age=OAccept: text/htmlAccept-Language: zh-Hans-CN,zh-Hans;q=0.5Upgrade-Insecure-Requests: 1User-Agent: Chrome/64.0.3282.140Accept-Encoding: gzip, deflateHost: 127.0.0.1:8080Connection: Keep-Alive# 第三部分: 空行,请求头部后面的空行是必须的请求头部和数据主体之间必须有换行# 第四部分: 请求数据也叫主体,可以添加任意的数据(没有则不显示)\n\n响应数据包解析 \n# 第一部分: 状态行。HTTP版本、状态码、状态消息HTTP/1.1 200 OK# 第二部分: 响应报头部,紧接着请求行（即第一行)之后的部分,用来说明服务器要使用的附加信息Content-Length: 11# 第三部分:空行,头部后面的空行是必须的头部和数据主体之间必须有换行# 第四部分:响应正文。可以添加任意的数据。例如“Hello World”Hello World\n\n响应状态码\n\n\n\n状态码\n类型\n描述\n\n\n\n1xx\n临时响应\n表示临时响应并需要请求者继续执行操作的状态代码\n\n\n2xx\n成功\n表示成功处理了请求的状态代码\n\n\n3xx\n重定向\n表示要完成请求,需要进一步操作; 通常这些状态代码用来重定向\n\n\n4xx\n请求错误\n这些状态代码表示请求可能出错,妨碍了服务器的处理\n\n\n5xx\n服务器错误\n这些状态码表示服务器在尝试处理请求时发生内部错误; 这些错误可能是服务器本身的错误, 而不是请求出错\n\n\n三 : 服务端升级版代码示例(和浏览器交互, 返回 Http 内容)\npublic class BIOServer2 &#123;    private static ExecutorService threadPool = Executors.newCachedThreadPool();    public static void main(String[] args) throws Exception &#123;        ServerSocket serverSocket = new ServerSocket(8080);        System.out.println(&quot;服务器启动成功&quot;);        while (!serverSocket.isClosed()) &#123;            Socket request = serverSocket.accept();            System.out.println(&quot;收到新连接 : &quot; + request.toString());            threadPool.execute(() -&gt; &#123;                try &#123;                    // 接收数据、打印                    InputStream inputStream = request.getInputStream();                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;utf-8&quot;));                    String msg;                    while ((msg = reader.readLine()) != null) &#123;                        if (msg.length() == 0) &#123;                            break;                        &#125;                        System.out.println(msg);                    &#125;                    System.out.println(&quot;收到数据,来自：&quot;+ request.toString());                    // 响应结果 200                    OutputStream outputStream = request.getOutputStream();                    outputStream.write(&quot;HTTP/1.1 200 OK\\r\\n&quot;.getBytes());                    outputStream.write(&quot;Content-Length: 11\\r\\n\\r\\n&quot;.getBytes());                    outputStream.write(&quot;Hello World&quot;.getBytes());                    outputStream.flush();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    try &#123;                        request.close();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;        serverSocket.close();    &#125;&#125;\n\n四 : BIO - 阻塞IO的含义阻塞(blocking) IO : 资源不可用时, IO 请求一致阻塞, 直到反馈结果(有数据或超时)\n非阻塞(non-blocking) IO : 资源不可用时, IO 请求离开返回, 返回数据标识资源不可用\n同步(synchronous) IO : 应用阻塞在发送或接受数据的状态, 直到数据成功传输或返回失败\n异步(asynchronous) IO : 应用发送或接受数据后立刻返回, 实际处理时异步执行的\n总结 : 阻塞和非阻塞是获取资源的方式, 同步和异步是程序如何处理资源的逻辑设计; \n\n代码中使用的 API: ServerSocket#accept, InputStream#read 都是阻塞的 API\n操作系统地层 API 中, 默认 Socket 操作都是 Blocking 型, send&#x2F;recv 等接口都是阻塞的\n\n带来的问题 : 阻塞导致在处理网络 I&#x2F;O 时, 一个线程只能处理一个网络连接\n","categories":["高性能编程"],"tags":["高并发网络编程","NIO网络编程"]},{"title":"TCP/UDP协议","url":"/2020/06/19/TCP&UDP/","content":"\nTCP协议和UDP协议为传输层提供了可靠的端口到端口的数据传输服务\n\n一 : OSI 网络七层模型为使不同计算机厂家的计算机能够互相通信, 以便在更大的范围内建立计算机网络, 有必要建立一个国际范围的网络体系结构标准\n \n也就是说 101010111100 中包含的数据内容为 : MAC 头部 + LLC 头部 + IP 头部 + TCP 头部 + 数据\n二 : 各层的主要功能低三层 \n\n物理层 : 使原始的数据比特流能在物理介质上传输\n数据链路层 : 通过校验, 确认和反馈重发等手段, 形成稳定的数据链路(01010101)\n网络层 : 进行路由选择和流量控制(IP 协议)\n\n中间层\n\n传输层 : 提供可靠的端口到端口的数据传输服务(TCP&#x2F;UDP协议)\n\n高三层\n\n会话层 : 负责建立 , 管理和终止进程之间的会话和数据交换\n表示层 : 负责数据格式转换, 数据加密与解密, 压缩与解压缩等\n应用层 : 为用户的应用进程提供网络服务\n\n三 : 传输控制协议 TCP传输控制协议(TCP) 使 Internet 一个重要的传输层协议; TCP 提供面向连接, 可靠, 有序, 字节流传输服务; 应用程序在使用 TCP 之前, 必须先建立 TCP 连接\n \n标志位说明\n\n\n\n标志位\n说明\n\n\n\nURG\n紧急指针\n\n\nACK\n确认序号\n\n\nPSH\n有 DATA 数据传输\n\n\nRST\n连接重置\n\n\nSYN\n建立连接\n\n\nFIN\n关闭连接\n\n\n四 : TCP 握手机制三次握手过程\n \n四次挥手过程\n \n五 : 用户数据报协议 UDP用户数据报协议 UDP 是 Internet 传输层协议; 提供无连接, 不可靠, 数据报尽力传输服务\n \n开发应用人员在 UDP 上构建应用, 关注以下几点 : \n\n应用进程更容易控制发送什么数据以及何时发送\n无需建立连接\n无连接状态\n首部开销小\n\n六 : UDP 和 TCP 比较\n\n\nTCP\nUDP\n\n\n\n面向连接\n无连接\n\n\n提供可靠性保证\n不可靠\n\n\n慢\n快\n\n\n资源占用多\n资源占用少\n\n\n什么时候会用到UDP呢? 对数据可靠性要求不高的情况, 例如音视频聊天, 物联网数据上报之类; 也就是说我们的关注点是现在发生了什么而不是过去发生了什么\n七 : Socket 编程Internet 中应用最广泛的网络应用编程接口, 实现与 3 种底层协议接口:\n\n数据报类型套接字 SOCK_DGRAM (面向 UDP 接口)\n流式套接字 SOCK_STREAM (面向 TCP 接口)\n原始套接字 SOCK_RAW (面向网络层协议接口 IP, ICMP 等)\n\n主要 socket API 及其调用过程 :\n创建套接字 =&gt; 端点绑定 =&gt; 发送数据 =&gt; 接收数据 =&gt; 释放套接字\n\nSocket API 函数定义\n\nlisten(), accept() 函数只能用于服务器端\nconnect() 函数只能用于客户端\nsocket(), bind(), send(), recv(), sendto(), recvfrom(), close()\n\n","categories":["高性能编程"],"tags":["高并发网络编程","NIO网络编程"]},{"title":"FutureTask源码剖析","url":"/2020/06/12/FutureTask/","content":"\n通过Future了解到Callable和Runnable的内在区别\n\n一 : FutureFuture 表示异步计算的结果, 提供了用于检查计算是否完成, 等待计算完成以及获取结果的方法\n\nFuture 和 Callable\n\nCallable 和 Runnable 一样的业务定义, 但本质上有区别(返回值, 异常定义), 表面的区别并不是最重要的, 重要的是我们要看内在, 内在的一个本质上的点是 Callable 是被 Runnable 调用的, 也就是说 call() 运行在 run() 里面\n// Thread并不能传入Callable, 但是我们可以通过FutureTask来使用callableCallable&lt;Object&gt; callable = new Callalbe&lt;Object&gt;&#123;    @Override    public Object call throws Exception &#123;        return null;    &#125;&#125;FutureTask&lt;Object&gt; futureTask = new FutureTask&lt;&gt;(callable);new Thread(futureTask).start();\n\n// 当然也可以用线程池直接使用ExecutorService executorService = Executors.newCachedThreadPool();executorService.submit(callable);\n\n在线程执行完后可以直接在 futureTask 中拿结果\nfutureTask.get();\n\n二 : FutureTask 应用 \n总的执行时间, 取决于执行最慢的逻辑\n逻辑之间无依赖关系, 可同时执行, 则可以应用多线程技术进行优化\n代码示例\n@Servicepublic class UserServiceFutureTask &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    @Autowired    private RestTemplate restTemplate;    /**     * 查询多个系统的数据，合并返回     */    public Object getUserInfo(String userId) throws ExecutionException, InterruptedException &#123;        // Future &lt; &gt;  Callable        // 和runnable一样的业务定义,但是本质上是有区别的: 返回值 异常 call run.        Callable&lt;JSONObject&gt; callable = new Callable&lt;JSONObject&gt;() &#123;            @Override            public JSONObject call() throws Exception &#123;                // 1. 先从调用获取用户基础信息的http接口                long userinfoTime = System.currentTimeMillis();                String value = restTemplate.getForObject(&quot;http://www.tony.com/userinfo-api/get?userId=&quot; + userId, String.class);                JSONObject userInfo = JSONObject.parseObject(value);                System.out.println(&quot;userinfo-api用户基本信息接口调用时间为&quot; + (System.currentTimeMillis() - userinfoTime));                return userInfo;            &#125;        &#125;;        // 通过多线程运行callable        FutureTask&lt;JSONObject&gt; userInfoFutureTask = new FutureTask&lt;&gt;(callable);        new Thread(userInfoFutureTask).start();        FutureTask&lt;JSONObject&gt; intergralInfoTask = new FutureTask(() -&gt; &#123;            // 2. 再调用获取用户积分信息的接口            long integralApiTime = System.currentTimeMillis();            String intergral = restTemplate.getForObject(&quot;http://www.tony.com/integral-api/get?userId=&quot; + userId,                    String.class);            JSONObject intergralInfo = JSONObject.parseObject(intergral);            System.out.println(&quot;integral-api积分接口调用时间为&quot; + (System.currentTimeMillis() - integralApiTime));            return intergralInfo;        &#125;);        new Thread(intergralInfoTask).start();        // 3. 合并为一个json对象        JSONObject result = new JSONObject();        result.putAll(userInfoFutureTask.get()); // 会等待任务执行结束        result.putAll(intergralInfoTask.get());        return result;    &#125;&#125;\n\n\n\n三 : 线程安全性级别《Effective Java》- Joshua J.Block 提到, 工具类需要显示的说明它的安全性级别 :\n\n不可变的 : 这个类的实例是不可变的; 这样的例子包括 String, Long, BigInteger\n无条件的线程安全 : 这个类的实例是可变的, 但是这个类有组偶的内部同步; 例子包括 Random, ConcurrentHashMap\n有条件的线程安全 : 除了有些方法为进行安全的并发使用而需要外部同步之外, 这种线程安全级别与无条件相同; 例如包括: Collections.synchronized 包装返回的集合, 他们的迭代器要求外部同步\n非线程安全 : 这个类的实例是可变的; 为了并发使用它们, 客户必须利用自己选择的外部同步包围每个方法调用, 例子包括 ArrayList\n线程对立 : 这个类不能安全地被多个线程并发使用, 即使所有的方法调用都被外围同步包围\n\n四 : JDK 学习思路汇总积累 : 由基层知识再到封装的工具类, 足够多的 “因” 才能推理出 “果”; 基层不代表基础, 不代表简单;\n思路 : 从顶层看使用, 从底层看原理\n结语 : 多线程编程中, 不变的是内存模型和线程通信两个核心技术点, 变化的是各种程序设计想法(算法)\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"Fork/Join并发处理框架","url":"/2020/06/05/Fork&Join/","content":"\nResursiveAction, RecursiveTask\n\n一 : 用来做什么ForkJoinPool 是 ExecutorService 接口的实现, 它专为可以递归分解成小块的工作而设计; \nfork&#x2F;join 框架将任务分配给线程池中的工作线程, 充分利用多处理器的优势, 提高程序性能\n使用 fork&#x2F;join 框架的第一步是编写执行一部分工作的代码; 类似的伪代码如下\n如果(当前工作部分足够小)\t直接做这项工作其他\t把当前工作分成两部分\t调用这两个部分并等待结果\n\n将此代码包装在 ForkJoinTask 子类中, 通常是 RecursiveTask (可以返回结果) 或 RecursiveAction\n二 : 意图梳理关键点 :  : 分解任务fork出新任务, 汇集join任务执行结果\n\n三 : 经典网关场景, 查询多个系统数据移动互联网的情况\n\n一个接口请求要获取很多信息\n后端分布式系统, 拆分成多个子系统\n\n后端接口执行(大概流程)\n\n收到一个请求\n调用多个服务接口获取其他系统的数据\n最后汇总返回\n\n示例代码\n@Servicepublic class UserService &#123;    @Autowired    private RestTemplate restTemplate;    /**     * 查询多个系统的数据，合并返回     */    public Object getUserInfo(String userId) &#123;        // 1. 先从调用获取用户基础信息的http接口        long userinfoTime = System.currentTimeMillis();        String value = restTemplate.getForObject(&quot;http://172.16.0.1/userinfo-api/get?userId=&quot; + userId, String.class);        JSONObject userInfo = JSONObject.parseObject(value);        System.out.println(&quot;userinfo-api用户基本信息接口调用时间为&quot; + (System.currentTimeMillis() - userinfoTime));        // 2. 再调用获取用户积分信息的接口        long integralApiTime = System.currentTimeMillis();        String intergral = restTemplate.getForObject(&quot;http://172.16.0.1/integral-api/get?userId=&quot; + userId,                String.class);        JSONObject intergralInfo = JSONObject.parseObject(intergral);        System.out.println(&quot;integral-api积分接口调用时间为&quot; + (System.currentTimeMillis() - integralApiTime));        // 再调用一个接口 +n秒        // 3. 合并为一个json对象        JSONObject result = new JSONObject();        result.putAll(userInfo);        result.putAll(intergralInfo);        return result;    &#125;&#125;\n\n注意 : 代码逻辑涉及到串行的过程, 运行时间会发生累计, 随着需要调用的接口的数量的增多, 响应时间会越来越长\n针对于响应时间限制, 通常开发公司会有明确规定, 例如 : 内部调用的核心接口的响应时间通常为10ms, 对外可以扩展到50ms\n代码优化\n// 任务public class HttpJsonRequest extends RecursiveTask&lt;JSONObject&gt; &#123;    RestTemplate restTemplate;    ArrayList&lt;String&gt; urls;    int start;    int end;    HttpJsonRequest(RestTemplate restTemplate, ArrayList&lt;String&gt; urls, int start, int end) &#123;        this.restTemplate = restTemplate;        this.urls = urls;        this.start = start;        this.end = end;    &#125;    // 就是实际去执行的一个方法入口(任务拆分)    @Override    protected JSONObject compute() &#123;        int count = end - start; // 代表当前这个task需要处理多少数据        // 自行根据业务场景去判断是否是大任务,是否需要拆分        if (count == 0) &#123;            String url = urls.get(start);            // TODO 如果只有一个接口调用,立刻调用            long userinfoTime = System.currentTimeMillis();            String response = restTemplate.getForObject(url, String.class);            JSONObject value = JSONObject.parseObject(response);            System.out.println(Thread.currentThread() + &quot; 接口调用完毕&quot; + (System.currentTimeMillis() - userinfoTime) + &quot; #&quot; + url);            return value;        &#125; else &#123; // 如果是多个接口调用,拆分成子任务  7,8,   9,10            System.out.println(Thread.currentThread() + &quot;任务拆分一次&quot;);            int x = (start + end) / 2;            HttpJsonRequest httpJsonRequest = new HttpJsonRequest(restTemplate, urls, start, x);// 负责处理哪一部分?            httpJsonRequest.fork();            HttpJsonRequest httpJsonRequest1 = new HttpJsonRequest(restTemplate, urls, x + 1, end);// 负责处理哪一部分?            httpJsonRequest1.fork();            // join获取处理结果            JSONObject result = new JSONObject();            result.putAll(httpJsonRequest.join());            result.putAll(httpJsonRequest1.join());            return result;        &#125;    &#125;&#125;\n\n/** * 并行调用http接口 */@Servicepublic class UserServiceForkJoin &#123;    // 本质是一个线程池,默认的线程数量:CPU的核数    ForkJoinPool forkJoinPool = new ForkJoinPool(10, ForkJoinPool.defaultForkJoinWorkerThreadFactory,            null, true);    @Autowired    private RestTemplate restTemplate;    /**     * 查询多个系统的数据，合并返回     */    public Object getUserInfo(String userId) throws ExecutionException, InterruptedException &#123;        // fork/join        // forkJoinPool.submit()        ArrayList&lt;String&gt; urls = new ArrayList&lt;&gt;();        urls.add(&quot;http://172.16.0.1/userinfo-api/get?userId=&quot; + userId);        urls.add(&quot;http://172.16.0.1/integral-api/get?userId=&quot; + userId);        HttpJsonRequest httpJsonRequest = new HttpJsonRequest(restTemplate, urls, 0, urls.size() - 1);        ForkJoinTask&lt;JSONObject&gt; forkJoinTask = forkJoinPool.submit(httpJsonRequest);        JSONObject result = forkJoinTask.get();        return result;    &#125;&#125;\n\n\n\n四 : 实现思路每个 Worker 线程都维护一个任务队列, 即 ForkJoinWorkerThread 中的任务队列\n任务队列是双向队列, 这样可以同时实现 LIFO(last in first out, 后进先出) 和 FIFO(first in first out, 先进先出)\n子任务会被加入到原先任务所在 worker 线程的任务队列(workQueue); worker 线程用 LIFO 的方法取出任务, 后进队列的任务先取出来(子任务总是后加入队列, 但是需要先执行); 当任务队列为空, 会随机从其他的 worker 的队列中拿走一个任务执行(工作窃取: steal work);\n如果一个 worker 线程遇到了 join 操作, 而这时候, 正在处理其他任务, 会等到这个任务结束; 否则直接返回\n如果一个 worker 线程窃取任务失败, 它会用 yield 或者 sleep 之类的方法休息一会儿, 再尝试(如果所有线程都是空闲状态, 即没有任务运行, 那么该线程也会进入阻塞状态等待新任务的到来)\n五 : 适用使用尽可能少的线程池 : 再大多数情况下, 最好的决定是为每个应用程序或系统使用一个线程池\n如果不需要特定调整, 请使用默认的公共线程池\n使用合理的阈值将 ForkJoinTask 拆分为子任务\n避免在 ForkJoinTask 中出现任何阻塞\n适用场景 : 数据处理, 结果汇总, 统计等; \njava8实例 : java.util.Arrays 类用于其 parallelSort() 方法就用到了 fork&#x2F;join; 其目的是进行内存运算方面的操作, 因此不适合用于网络接口调用, 数据库查询, 文件操作等; 所以如果需要使用, 只定义一个 ForkJoinPool 就好, 线程数量尽量和 CPU 核数差不多, 主要进行非阻塞的代码处理\n六 : 结语总结 :\n\n本质上是一个线程池, 如果需要使用, 只需要定义一个 ForkJoinPool 即可\n线程数量尽量和 CPU 核心数差不多; 例如 8 核 CPU 就设置 8 个线程\n适用于非阻塞(non blocking)的代码处理; 如网络接口调用, 数据库查询, 文件操作等操作并不适用\n\n工作窃取带来的性能提升偏理论, API 的复杂性高, 实际研发中可控性来说不如其他 API, 非内存操作并不适用\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"并发容器类(二)","url":"/2020/05/29/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB2/","content":"\n单列容器主要涉及到List、Set和Queue \n\n一 : List单纯的 List 如果实际操作过程中, 不可以一边遍历一边删除, 这时就可以用到 CopyOnWriteArrayList\nCopyOnWriteArrayList 容器即写时复制的容器, 实现原理 :\n\n对当前 List 加锁\n将原先的 array 复制一个新的数组(newElements)\n对复制的数组进行修改\n对原有数组进行替换\n\n和 ArrayList 比较, 优点是并发安全, 缺点有两个 :\n\n多了内存占用: 写数据是 copy 一份完整的数据, 单独进行操作; 占用双份内存\n数据一致性: 数据写完之后, 其他线程不一定是马上读取到最新内容\n\n二 : Setset 和 list 重要区别 : 不重复; 重要 API 实现原理及特点\n\n\n\n实现\n原理\n特点\n\n\n\nHashSet\n通过 HashMap 进行存储, 将 value 作为 key, 从而实现了 Set 数据不重复的作用\n非线程安全\n\n\nCopyOnWriteArraySet\n基于 CopyOnWriteArrayList\n线程安全\n\n\nConcurrentSkipListSet\n基于 ConcurrentSkipListMap\n线程安全, 有序, 查询快\n\n\n三 : Queue重要 API 介绍\n\n\n\n方法\n作用\n描述\n\n\n\nadd\n增加一个元素\n如果队列已满, 则抛出一个 illealStateException 异常\n\n\nremove\n移除并返回队列头部的元素\n如果队列为空, 则抛出一个 NoSuchElementException 异常\n\n\nelement\n返回队列头部的元素\n如果队列为空, 则抛出一个 NoSuchElementException 异常\n\n\noffer\n添加一个元素并返回 true\n如果队列已满, 则返回 false\n\n\npoll\n移除并返回队列头部的元素\n如果队列为空, 则返回 null\n\n\npeek\n返回队列头部的元素\n如果队列为空, 则返回 null\n\n\nput\n添加一个元素\n如果队列满, 则阻塞\n\n\ntake\n移除并返回队列头部的元素\n如果队列为空, 则阻塞\n\n\nArrayBlockingQueue : 基于数组的阻塞循环队列, 此队列按FIFO(先进先出)原则对元素进行排序; 注意put和offer的区别: put会阻塞, offer不会阻塞直接返回false\nLinkedBlockingQueue : 基于链表的队列,此队列按 FIFO 排序; 如果有阻塞需求,用这个; 类似生产者消费者模式\nConcurrentLinkedQueue : 优势: 无锁; 注意: 批量操作不提供原子性保证(addAll,removeAll,retainAll,containsAll,equals,and toArray); 坑: size() 每次都是便利整个链表,最好不要频繁调用; 如果没有阻塞要求,用这个挺好(堆积数据)\nPriorityQueue : 是一个带优先级的队列,而不是先进先出; 元素按优先级顺序被移除,该队列也没有上限; 没有容量限制,自动扩容; 虽然在逻辑上是无界的,但是由于资源被耗尽,所以试图执行添加操作可能会导致OutOfMemoryError; 如果队列为空,那么取出元素的take操作就会阻塞,所以它的检索操作take是受阻的; 另外,加入该队列的元素要具有比较能力\nPriorityBlockingQueue : 封装了 PriorityQueue; 是一个带优先级的队列, 而不是先进先出队列; 元素按优先级顺序被移除, 该队列也没有上限; 没有容量限制的, 自动扩容; 芮苒此队列逻辑上是无界的, 但是由于资源被耗尽, 所以试图执行添加操作可能会导致 OutOfMemoryError; 但如果队列为空, 那么取元素的操作take就会阻塞, 所以它的检索操作take是受阻的; 另外, 加入队列中的元素要具有比较能力\nDelayQueue : 基于PriorityQueue来实现的, 是一个存放Delayed 元素的无界阻塞队列; 只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素; 如果延迟都还没有期满，则队列没有头部，并且poll将返回null; 当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时; 则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素\nSynchronousQueue : 这是一个神奇的队列, 因为他不存数据, 手把手的交互数据; 非阻塞方法无效, 只能使用阻塞方法 put&#x2F;take\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"并发容器类","url":"/2020/05/22/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/","content":"\n容器主要就分类单列和双列两种, 掌握Map是重中之重\n\n一 : 学习方法逻辑思维能力是梳理学习方法的基础; 养成线程思维: 两个或者多个给概念,像一条线串起来\n首先要经过演绎推导法进行因果推理; 比如java中网络编程只提供了BIO和NIO两种方式, 所以一切框架中, 涉及到网络处理的, 都可以用这两个知识点去探究原理\n然后采用归纳总结法提出可能正确的猜想; 比如线上10台服务器, 有三台总是每天会自动重启, 收集相关信息后, 发现是运维在修改监控系统配置的时候, 漏掉了提高这三台服务器的重启阈值\n最后要使用类比法进行思维固化; 比如集群概念就好像是马在拉车,一匹马拉不动的时候,就是用多匹马去拉; 分布式的概念, 就像是理发的过程中, 洗头发和剪头发是不同的人负责的\n二 : 推理 HashMap 的实现数据要存储\n\n涉及到数据结构 : 数组, 链表, 栈, 树, 队列\n\n数组的插入和查找\n\n顺序查找 : 插入时按先后顺序插入, 查找时轮询扫描进行对比\n二分查找 : 插入时进行排序; 查找时将 n 个元素分成大致相等的两部分, 减少复杂度\n分块查找 : 分块查找是二分查找和顺序查找的一种改进\n哈希表 : 对元素的关键信息进行 hash 计算, 求出下标后直接插入或查找; 常用的实现是除留余数法\n\n哈希冲突, 数组位置已存在值\n\nhash(key2) &#x3D; hash(key1); 链地址法; ReHash1(key2) 再次计算 hash;\n\n合理控制数组和链表的长度\n\n动态扩容 resize()\n\n三 : HashMapjdk1.7:\n\n数据结构 : 数组 + 链表, Entry&lt;K,V&gt;[] table;\n实现原理 : 计算key的hash值,然后根据数组长度进行除留余数法确定数组位置; 如果是存入,先判定key存在不存在,若存在覆盖value的值;若不存在,则放在链表的最后, 如果是读取采用顺序查找法进行比对\n扩容规则 : 初始容量 16, 扩容因子 0.75;\n如果有初始长度, 则会以最靠近指定长度的2的幂次进行定容,例如: 519则会定为1024\n如果储存的值超过容量的 0.75 倍, 以 2 倍方式进行扩容, 存储的元素会重新排列\n\n\n\njdk1.8:\n\n数据结构: Node&lt;K,V&gt;[] table; 别以为有啥变化, Node 和 Entry 结构一样; 在jdk1.7的基础上进行了改进,在数据结构上引入了树形结构\n链表阈值8, 最小容量 64\n如果单个链表容量超过 8, 该链表则自动转为红黑树\n如果链表达到8, 但是数组没有超过 64, 只会 resize 而不会生成树\n\n\n由于有扩容机制的存在, 所以用到红黑树的概率很低, 同时, 维护树也是对性能的消耗\n\n四 : ConcurrentHashMapjdk1.7\n\n数据结构 : Segment&lt;K,V&gt;[] segments;\nSegment是个啥? 每个存储单元称为segment, 结构上没有任何区别, 但是它继承了ReentrantLock, 每个segment中包含一个 HashEntry[]\n那HashEntry又是个啥? 主要包含hash值, key, value 和 next, 就是HashMap中的Entry呀! 那 Segment 不就是个map吗, 也就是说每个 segment 就是一个 HashMap\n\n\n设计原理 :\n也就是说 ConcurrentHashMap 不能扩容,但是 Segment 可以扩容\n这不是有病吗? 这设计太鬼才了! 是否会存在设计过度的嫌疑, 我感觉有点绕弯; Segment 的数量定死就是16个,还高大上的起了个名字叫分段锁, 但实质上也就只能支持16个并发量\n既然是为了提高并发操作的安全性, 那我为什么不在每个 HashMap 中的每个 Entry 上加一把锁呢\n\n\n扩容规则 : 和 HashMap 稍微有些区别, 数组的容量是固定的16个\n\njdk1.8\n\n数据结构 : Node&lt;K,V&gt; table; 数组 + 链表\n初始容量16, 扩容银子 0.75, 阈值也是 8, 最小容量 64\n设计原理 : 设计思路完全改变, 和HashMap是一样的; 那怎么保证线程安全和并发量的? synchronized? Lock接口? CAS?; 查看源码,初始化是通过CAS实现的, put 是 sync\n但是它是怎么保证线程安全的呢?\n初始化采用 cas 机制\nput 的时候, 如果当前位置为 null, 采用 cas 机制\n如果不为 null, 则使用同步关键字\n\n\n\n五 : ConcurrentSkipListMap特点 : 有序链表实现, 无锁实现; value 不能为空; 层级越高跳跃性越大, 数据越少, 查询理论变快;\n和 HashMap 的结构完全不一样, 跳表中包含了一个 index, 在 index 中存储 Node 节点的引用\nclass Index &#123;    Node node;    Index right; //先比对入口索引, 如果大于入口索引,则向右进行比对    Index down;  //如果小于右边的索引, 则向下比对&#125;class Node &#123;    String key;    String value;    Node next;&#125;\n\n插入 Node 节点的时候, 随机创建索引(创建一个随机数, 如果是偶数, 就创建索引); 如果数据量大, 索引量大也会导致查询效率降低, 这时候引入索引分级的概念\n索引分级: 根据生成的随机数的二进制数的连续为 1 的数量来确定 level ; 每层的元素, headIndex 固定为所有 node 中最小的\n查找数据时, 按照先从左到右, 后从上到下的顺序查找; 时间复杂度O(log n), 空间复杂度O(n); 性能提升思路就是常说的空间换时间, 数据库索引类似的概念, skiplist 在很多开源组件中有使用 (level DB, Redis)\n关于线程安全方面, 依然还是采用 CAS 机制\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"并发编程工具类","url":"/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"\nJ.U.C : java.util.concurrent包下的工具类\n\n一 : Semaphore又称信号量, 控制多个线程争抢许可\n核心API : \n\nacquire : 获取一个许可, 如果没有就等待\nrelease : 释放一个许可\navailablePermits : 方法得到可用的数目\n\n经典场景 : 代码并发处理限流\n示例代码\npublic class SemaphoreDemo &#123;    private static Semaphore semaphore = new Semaphore(2);    public static void main(String[] args) &#123;        /**         * 4个客人2个技师         */        for (int i = 1; i &lt;= 4; i++) &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot;来到红浪漫, 现有技师: &quot; + semaphore.availablePermits());                    if (semaphore.availablePermits() == 0) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;没技师了...&quot;);                    &#125;                    // 开始等                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + &quot;有技师, 准备按摩...&quot;);                    Thread.sleep(5000L);                    System.out.println(Thread.currentThread().getName() + &quot;按摩结束, 离开...&quot;);                    semaphore.release();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;, i + &quot;哥: &quot;).start();        &#125;    &#125;&#125;\n\n\n\n二 : CountDownLatchjava1.5 被引入的一个工具类, 常被成为倒计数器; 创建对象时, 传入指定数值作为线程参与的数量\nAPI\n\nawait : 方法等待计数器值变为 0, 在这之前, 线程进入等待状态\ncountdown : 计数器数值减一, 直到为 0\n\n适用场景 : 经常用于等待其他线程执行到某一节点, 再继续执行当前线程代码\n示例代码\npublic class CountDownLatchDemo &#123;    private static CountDownLatch countDownLatch = new CountDownLatch(3);    private static Map&lt;String, Integer&gt; record = new HashMap&lt;&gt;();    public static void main(String[] args) &#123;        Random random = new Random();        /**         * 4个运动员赛跑,未比完人数为0时,公布成绩         */        for (int i = 1; i &lt;= 4; i++) &#123;            new Thread(() -&gt; &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot;: 起跑...&quot;);                    int s = 9 + random.nextInt(3);                    Thread.sleep(s * 1000L);                    countDownLatch.countDown();                    record.put(Thread.currentThread().getName(), s);                    System.out.println(Thread.currentThread().getName() + &quot;: 跑完了...&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;, i + &quot;号运动员&quot;).start();        &#125;        try &#123;            countDownLatch.await();            System.out.println(&quot;比赛结束, 公布成绩: &quot; + record.toString());        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n真实场景\n\n统计线程执行情况\n压力测试中, 使用 countDownLatch 实现最大程度的并发处理\n多线程之间, 相互通信, 比如线程异步调用完接口, 结果通知\n\n三 : CyclicBarrierjava1.5 加入, 又称为线程栅栏; 创建对象时, 指定展览线程数量\nAPI\n\nawait : 等指定数量的线程都处于等待状态时, 继续执行后续代码\nbarrierAction : 线程数量到了指定量之后, 自动出发执行指定任务\n\n和 CountDownLatch 重要区别在于, CyclicBarrier 对象可以多次出发执行\n经典场景 :\n\n数据量比较大时, 实现批量插入数据到数据库\n数据统计, 30 个线程统计 30 天数据, 全部统计完毕后, 执行汇总\n\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"AQS抽象队列同步器","url":"/2020/05/08/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/","content":"\nAQS : abstract queue synchronizer, 抽象队列同步器\n\n一 : 同步锁的本质 - 排队同步的方式 : 独享锁 - 单个队列窗口, 共享锁 - 多个队列窗口\n抢锁的方式 : 公平锁(先来后到抢锁), 非公平锁(插队抢)\n没抢到锁的处理方式 : 快速尝试多次(CAS自旋), 阻塞等待\n唤醒阻塞线程的方式(叫号器) : 全部通知, 通知下一个\n二 : AQS 抽象队列同步器提供了对资源占用, 释放; 线程的等待, 唤醒等等接口和具体实现\n可以用在各种需要控制资源争用的场景中(ReentrantLock&#x2F;CountDownLatch&#x2F;Semahpore)\n\n其中定义的接口可以分为独占资源接口和共享资源接口两类; 其中独占资源接口包括 acquire, release, tryAcquire(未实现), tryRelease(未实现); 而共享资源接口则包括 acquireShared, releaseShared, tryAcquireShared(未实现), tryReleaseShared(未实现)\n\nacquire, acquireShared : 定义了资源争用的逻辑, 如果没拿到, 则等待\ntryAcquire, tryAcquireShared : 实际执行占用资源的操作, 如何判定一个由使用者具体去实现\nrelease, releaseShared : 定义释放资源的逻辑, 释放之后, 通知后续节点进行争抢\ntryRelease, tryReleaseShared : 实际执行资源释放的操作, 具体的 AQS 使用者去实现\n\nAQS 内部主体 : state(状态), exclusiveOwner(占有者), Node(锁的等待者链表, 从head &#x3D;&gt; tail)\n代码示例\npublic class AQSdemo &#123;    // 同步资源状态    volatile AtomicInteger state = new AtomicInteger(0);    // 当前锁的拥有者    protected volatile AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();    // java q 线程安全    public volatile LinkedBlockingQueue&lt;Thread&gt; waiters = new LinkedBlockingQueue&lt;&gt;();    public void acquire() &#123;        boolean addQ = true;        while (!tryAcquire()) &#123;            if (addQ) &#123;                // 塞到等待锁的集合中                waiters.offer(Thread.currentThread());                addQ = false;            &#125; else &#123;                // 挂起这个线程                LockSupport.park();                // 后续，等待其他线程释放锁，收到通知之后继续循环            &#125;        &#125;        waiters.remove(Thread.currentThread());    &#125;    public void release() &#123;        // cas 修改 owner 拥有者        if (tryRelease()) &#123;            Iterator&lt;Thread&gt; iterator = waiters.iterator();            while (iterator.hasNext()) &#123;                Thread waiter = iterator.next();                LockSupport.unpark(waiter); // 唤醒线程继续 抢锁            &#125;        &#125;    &#125;    // 判断量够不够    public void acquireShared() &#123;        boolean addQ = true;        while (tryAcquireShared() &lt; 0) &#123;            if (addQ) &#123;                // 塞到等待锁的集合中                waiters.offer(Thread.currentThread());                addQ = false;            &#125; else &#123;                // 挂起这个线程                LockSupport.park();                // 后续，等待其他线程释放锁，收到通知之后继续循环            &#125;        &#125;        waiters.remove(Thread.currentThread());    &#125;    public void releaseShared() &#123;        // cas 修改 owner 拥有者        if (tryReleaseShared()) &#123;            Iterator&lt;Thread&gt; iterator = waiters.iterator();            while (iterator.hasNext()) &#123;                Thread waiter = iterator.next();                LockSupport.unpark(waiter); // 唤醒线程继续 抢锁            &#125;        &#125;    &#125;    public boolean tryAcquire() &#123;        throw new UnsupportedOperationException();    &#125;    public boolean tryRelease() &#123;        throw new UnsupportedOperationException();    &#125;    public int tryAcquireShared() &#123;        throw new UnsupportedOperationException();    &#125;    public boolean tryReleaseShared() &#123;        throw new UnsupportedOperationException();    &#125;    public AtomicInteger getState() &#123;        return state;    &#125;    public void setState(AtomicInteger state) &#123;        this.state = state;    &#125;&#125;\n\n\n\n三 : 资源占用流程(acquire)\n","categories":["高性能编程"],"tags":["多线程并发编程","J.U.C并发编程包"]},{"title":"Lock接口和ReentrantLock/ReadWriteLock","url":"/2020/04/24/Lock%E6%8E%A5%E5%8F%A3/","content":"\nJAVA 还提供了锁相关的一些API, 可以更加灵活的实现控制锁的获取和释放\n\n一 : Lock 的核心APIsynchronized 关键字使用固然简单, 但是我们无法控制同步代码停止, 除非抛异常; \nLock 提供了很丰富的 API : \n\n\n\n方法\n描述\n\n\n\nlock\n获取锁的方法, 若锁被其他线程获取, 则等待(阻塞)\n\n\nlockInterruptibly\n在锁的获取过程中可以中断当前线程\n\n\ntryLock\n尝试非阻塞的获取锁, 立即返回\n\n\nunlock\n释放锁\n\n\n二 : ReentrantLock独享锁; 可重入锁; 支持公平锁, 非公平锁两种模式\npublic class Demo &#123;        Lock lock = new ReentrantLock();    public void a() &#123;        /*         * 如果需要正确中断等待锁的线程,必须将获取锁放在try&#123;&#125;外面;         * 否则会抛出 IllegalMonitorStateException,         * 由于finally却无论如何都要执行,而等待线程根本就没有拿到锁,也就是锁没有锁定监视器         */        lock.lock();        try &#123;            // ...method body            b(); // 此方法带锁, 同一线程可以重复进入        &#125; finally &#123; // 这里必须用finally将锁释放掉,否则一旦出现异常容易出现死锁            lock.unlock();         &#125;    &#125;    public void b() &#123;        lock.lock();        //...        lock.unlock();    &#125;&#125;\n\n执行过程 :\n\n初始化 : 未锁, ReentrantLock, 持有者(null), 计数(0)\n调用 a() : 第一次锁, ReentrantLock, 持有者(线程-0), 计数(1) \na() 中又调用 b() : 第二次锁, ReentrantLock, 持有者(线程-0), 计数(2)\nb() 执行完毕 : 解锁, ReentrantLock, 持有者(线程-0), 计数(1)\na() 执行完毕 : 解锁, ReentrantLock, 持有者(null), 计数(0)\n\n三 : ReadWriteLock维护一对关联锁, 一个用于只读操作, 一个用于写入; 读锁可以由多个读线程同时持有, 写锁是排他的; \n\n适用场景 : 适合读取线程比写入线程多的场景(读多写少), 改进互斥锁的性能\n示例场景 : 缓存组件, 集合的并发线程安全性改造\n\n代码示例 : \npublic class Demo &#123;    ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();    public static void main(String[] args) &#123;        final Demo demo = new Demo();        // 多线程同时读/写        new Thread(() -&gt; &#123;            demo.read(Thread.currentThread());        &#125;).start();        new Thread(() -&gt; &#123;            demo.read(Thread.currentThread());        &#125;).start();        new Thread(() -&gt; &#123;            demo.write(Thread.currentThread());        &#125;).start();    &#125;    // 多线程读,共享锁    public void read(Thread thread) &#123;        readWriteLock.readLock().lock();        try &#123;            long start = System.currentTimeMillis();            while (System.currentTimeMillis() - start &lt;= 1) &#123;                System.out.println(thread.getName() + &quot;正在进行“读”操作&quot;);            &#125;            System.out.println(thread.getName() + &quot;“读”操作完毕&quot;);        &#125; finally &#123;            readWriteLock.readLock().unlock();        &#125;    &#125;    // 写,独占锁    public void write(Thread thread) &#123;        readWriteLock.writeLock().lock();        try &#123;            long start = System.currentTimeMillis();            while (System.currentTimeMillis() - start &lt;= 1) &#123;                System.out.println(thread.getName() + &quot;正在进行“写”操作&quot;);            &#125;            System.out.println(thread.getName() + &quot;“写”操作完毕&quot;);        &#125; finally &#123;            readWriteLock.writeLock().unlock();        &#125;    &#125;&#125;\n\n锁降级指的是写锁降级成为读锁; 把持住当前拥有的写锁的同时, 再获取到读锁, 然后释放写锁的过程\n写锁是线程独占, 读锁是共享, 所以, 写 &#x3D;&gt; 读是升级(读 &#x3D;&gt; 写, 是不能实现的)\n四 : ConditionObject 中的 wait(), notify(), notifyAll() 方法是和 synchronized 配合使用的, 可以唤醒一个或者全部(单个等待集);\nCondition 是需要与 Lock 配合使用的, 提供多个等待集合, 更精确的控制; 底层是 park&#x2F;unpark 机制; 用于替代 wait&#x2F;notify; \n经典场景 : JDK 中的队列实现\n\n多线程读写队列 : 写入数据时, 唤醒读取线程继续执行; 读取数据后, 通知写入队列继续执行\n\n代码示例 : \n/** * condition 实现队列线程安全 */ public class QueueDemo &#123;    final Lock lock = new ReentrantLock();    // 指定条件的等待 - 等待有空位    final Condition notFull = lock.newCondition();    // 指定条件的等待 - 等待不为空    final Condition notEmpty = lock.newCondition();    // 定义数组存储数据    final Object[] items = new Object[100];    int putptr, takeptr, count;    // 写入数据的线程,写入进来    public void put(Object x) throws InterruptedException &#123;        lock.lock();        try &#123;            while (count == items.length) // 数据写满了                notFull.await(); // 写入数据的线程,进入阻塞            items[putptr] = x;            if (++putptr == items.length) putptr = 0;            ++count;            notEmpty.signal(); // 唤醒指定的读取线程        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    // 读取数据的线程,调用take    public Object take() throws InterruptedException &#123;        lock.lock();        try &#123;            while (count == 0)                notEmpty.await(); // 线程阻塞在这里,等待被唤醒            Object x = items[takeptr];            if (++takeptr == items.length) takeptr = 0;            --count;            notFull.signal(); // 通知写入数据的线程,告诉他们取走了数据,继续写入            return x;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"JAVA锁相关术语及同步关键字synchronized","url":"/2020/04/17/synchronized%E5%92%8C%E9%94%81/","content":"\n要使用多线程技术, 能够合理的使用锁总是绕不开的\n\n一 : java 中锁的概念自旋锁 : 为了不放弃 CPU 执行事件, 循环的使用 CAS 技术对数据尝试进行更新, 直至成功\n悲观锁 : 假定会发生并发冲突, 同步所有对数据的相关操作, 从读数据就开始上锁\n乐观锁 : 假定没有冲突, 在修改数据时如果发现数据和之前获取的不一致, 则读最新的数据, 修改后重试修改\n独享锁(写) : 给资源加上写锁, 线程可以修改资源, 其他线程不能再加锁;(单写)\n共享锁(读) : 给资源加上读锁后只能读不能改, 其他线程也只能加读锁, 不能加写锁;(多读)\n可重入锁, 不可重入锁 : 线程拿到一把锁之后, 可以自由进入同一把锁所同步的其他代码\n公平锁, 非公平锁 : 争抢锁的顺序, 如果是按先来后到, 则为公平\n几种重要的锁实现方式 : synchronized, ReentrantLock, ReentrantReadWriteLock\n二 : 同步关键字 synchronized属于最基本的线程通信机制, 基于对像监视器实现的; java中的每一个对象都与一个监视器相关联, 一个线程可以锁定或者解锁监视器; 一次只有一个线程可以锁定监视器; 试图锁定该监视器的任何其他线程都会被阻塞, 直到它们可以获得该监视器上的锁定为止\n特性 : 可重入, 独享, 悲观锁\n锁的范围 : 类锁, 对象锁, 锁消除, 锁粗化\npublic class SyncDemo &#123;    public synchronized /*static*/ void test() &#123;        try &#123;            System.out.println(Thread.currentThread() + &quot; 我开始执行&quot;);            Thread.sleep(3000L);            System.out.println(Thread.currentThread() + &quot; 我执行结束&quot;);        &#125; catch (InterruptedException e) &#123;                    &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; new SyncDemo().test()).start();        Thread.sleep(1000L); // 等1秒钟,让前一个线程启动起来        new Thread(() -&gt; new SyncDemo().test()).start();    &#125;&#125;\n\n运行结果 : 线程不会同步\n原理分析 : synchronized 的加锁原理是锁定对象监视器, 每个对象都对应各自的监视器\n解决方案 : \n\n加静态关键字 static, 提升为类锁\n为临界区添加同步代码块, 指定共用的锁, 但需要是类锁\n\n提示 : 同步关键字, 不仅是实现同步, 根据 JMM 规定还能保证可见性(读取最新主内存数据, 结束后写入主内存)\n三 : 同步关键字加锁原理HotSpot 中, 对象在内存中存储的布局可以分为三块区域 : 对象头(Header), 实例数据(Instance Data)和对齐填充(Padding)\n普通对象的对象头(Header)包括两部分 : Mark Word 和 Class Metadata Address (类型指针), 如果是数组对象还包括一个额外的 Array length 数组长度部分\n\n\n\n长度\n内容\n说明\n\n\n\n32&#x2F;64bit\nMark Word\n存储对象hashCode或锁信息等运行时数据。\n\n\n32&#x2F;64bit\nClass Metadata Address\n存储到对象类型数据的指针\n\n\n32&#x2F;64bit\nArray length\n数组的长度(如果当前对象是数组)\n\n\n其中 mark word 用于存储对象自身的运行时数据, 如: 哈希码(HashCode), GC分代年龄(age), 是否偏向锁(0&#x2F;1), 锁标志位(tag), 线程持有的锁状态(state), 偏向线程ID(Thread ID), 偏向时间戳等等(epoch); 占用内存大小与虚拟机位长一致(32&#x2F;64bit)\n|\t\tBitfield\t\t\t|Tag|\t\t\tState\t\t\t||\t\tHashCode\t|age|0\t|01\t|\tUnlocked\t\t\t\t||\tLock record address\t\t|00\t|\tLight-weight locked\t\t||\tMonitor address\t\t\t|10\t|\theavy-weight locked\t\t||\tForwarding address, etc\t|11\t|\tmarked for GC\t\t\t||\tThread ID|epoch\t|age|1\t|01\t|\tbiased/biasable\t\t\t|\n\n默认情况下 jvm 锁会经历 : 偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁\n参考文献 : \n\nhttps://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf \nhttps://wiki.openjdk.java.net/display/HotSpot/Synchronization\n\n(一) 轻量级锁对象初始化的时候是无锁的, mark word 记录的是 hashCode, age 和偏移状态\n加锁原理 : 线程栈开辟一个空间, 存储当前锁定对象的 mark word 信息; 这个空间就是 lock record, 它可以存储多个锁定的对象信息, 如果对象被锁定了, mark word 的内容会变为 lock record address\n加锁前\n \n加锁后\n \n使用 CAS 修改 mark word 完毕, 则 mark word 中的 tag 进入 00 状态\n解锁的过程, 则是一个逆向恢复 mark word 的过程\n(二) 偏向锁到轻量级锁偏向锁默认是开启的, 偏向锁其实也是无锁, tag 值和无锁对象一样, 都是 01, 若出现锁竞争会升迁到轻量级锁\n\n未锁定或不可偏向对象经过自旋重锁之后, 会升迁为轻量级锁, mark word 的内容会修改为线程栈的 lock record address, 同时 tag 会修改为 00, 如果锁再次升级, 就会编程重量级锁, mark word 内容会修改为 monitor address , 同时 tag 会修改为 10\n开启偏向锁的对象 mark word 内容为 thread ID|age|1 , tag 值仍然是 01, 这里需要注意的是 Thread ID 初始值为 0, 当第一个线程进行操作的时候, 会将 Thread ID 修改为自己的线程 ID, 一旦出现争抢会出现两种情况: 一种情况是如果对象没锁定, 则会变成未锁定且不偏向的对象, 也就是无锁对象; 如果对象已经锁定, 则会直接变成被轻量级锁定的对象\n总结 :\n\n偏向标记第一次有用, 出现过争用后就没有用了; \n-XX: -UseBiasedLocking # 禁用使用偏置锁定\n\n偏向锁, 本质就是无锁, 如果没有发生过任何多线程争抢锁的情况, jvm 认为就是单线程, 无需做同步(jvm 为了少干活: 同步在 jvm 底层是有很多操作来实现的, 如果是没有争用, 就不需要去做同步)\n\n\n(三) 重量级锁 - 监视器(monitor)修改 mark word 如果失败, 会自旋 CAS 一定次数, 该次数可以通过参数配置\n超过次数, 仍未抢到锁, 则锁升级为重量级锁, 进入阻塞\n\nmonitor 也叫做管程, 计算机操作系统原理中有提及类似概念, 一个对象会有一个对应的 monitor\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"CAS机制和Atomic相关类","url":"/2020/04/10/CAS%E6%9C%BA%E5%88%B6%E5%92%8CAtomic%E7%9B%B8%E5%85%B3%E7%B1%BB/","content":"\nCAS 虽然可以保证原子性操作, 但同时也存在其他的问题, 并非十全十美, 用的时候要结合具体情况 \n\n一 : CAS 机制Compare and swap 比较和交换; 属于硬件同步原语, 处理器提供了基本内存操作的原子性保证\nCAS 操作需要输入两个数值, 一个旧值 A (期望操作前的值)和一个新值 B, 在操作期间先比较下旧值有没有发生变化, 如果没有发生变化, 才交换成新值, 发生了变化则不交换\n \nJAVA 中的 sun.misc.Unsafe 类, 提供了 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法实现 CAS\n二 : JUC包内的原子操作封装类数值\n\nAtomicBoolean : 原子更新布尔类型\nAtomicInteger : 原子更新整型\nAtomicLong : 原子更新长整型\n\n数组\n\nAtomicIntegerArray : 原子更新整型数组数组里的元素\nAtomicLongArray : 原子更新长整型数组里的元素\nAtomicReferenceArray : 原子更新引用类型数组里的元素\n\n字段\n\nAtomicIntegerFieldUpdate : 原子更新整形的字段的更新器\nAtomicLongFieldUpdate : 原子更新长整型字段的更新器\nAtomicReferenceFieldUpdate : 原子更新引用类型里的字段\n\n引用类型\n\nAtomicReference : 原子更新引用类型\nAtomicStampedReference : 原子更新带有版本号的引用类型\nAtomicMarkableReference : 原子更新带有标记为的引用类型\n\njdk1.8 更新\n\n更新器 : DoubleAccumulator, LongAccumulator\n计数器 : DoubleAdder, LongAdder\n计数器增强版, 高并发下性能更好\n频繁更新但不太频繁读取的汇总统计信息时使用\n分成多个操作单元, 不同线程更新不同的单元\n只有需要汇总的时候才计算所有单元的操作\n\n三 : CAS 的三个问题\n循环 + CAS, 自旋的实现让所有线程都处于高频运行, 争抢 CPU 执行事件的状态; 如果操作长时间不成功, 会带来很大的 CPU 资源消耗\n仅针对单个变量的操作, 不能用于多个变量来实现原子操作\nABA 问题 : 简单来说就是 value&#x3D;A, 线程1将A改成B, 线程2又将B改成A, 这是线程3将A改成C, 这时线程3是不知道 value 的值曾经有过变动的\n\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"线程安全之原子操作","url":"/2020/04/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","content":"\n多线程操作共享资源时, 要保证数据的准确就要保证操作的原子性\n\n一 : 概述原子操作操作可以是一个步骤, 也可以是多个操作步骤, 但是其顺序不可以被打乱, 也不可以被切割而只执行其中的一部分(不可中断性); \n将整个操作视作一个整体是原子性的核心特征\n二 : 解决方案\n加锁\n循环 CAS\n\n三 : 示例示例代码\npublic class Demo &#123;    public int i = 0;    public void incr() &#123;        i++;     &#125;&#125;\n\n这里是三个步骤 : \n\n加载 i\n计算 i+1 \n赋值 i\n\n存在竟态条件, 线程不安全, 需要转变为原子操作才能安全; \npublic synchronized void incr() &#123;    i++; &#125;\n\n上例只是针对一个变量的原子操作改进, 我们也可以实现更大逻辑的原子操作\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"线程安全之共享资源/不可变性/竟态条件/临界区","url":"/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/","content":"\n线程安全之共享资源&#x2F;不可变性&#x2F;竟态条件&#x2F;临界区\n\n一 : 竟态条件与临界区多个线程访问了相同的资源, 向这些资源做了写操作时, 对执行顺序有要求\npublic class Demo &#123;    public int i = 0;    public void incr() &#123;        i++;    &#125;&#125;\n\n临界区 : incr() 内部就是临界区域, 关键部分代码的多线程并发执行, 会对执行结果产生影响\n竟态条件 : 可能发生在临界区域内的特殊条件; 多线程执行 incr() 中的 i++ 关键代码时, 产生了竟态条件\n二 : 共享资源如果一段代码是线程安全的, 则它不包含竟态条件; 只有当多个线程更新共享资源时, 才会发生竟态条件\n栈封闭时, 不会在线程之间共享的变量, 都是线程安全的\n局部对象引用本身不共享, 但是引用的对象存储在共享堆中; 如果方法内创建的对象, 只是在方法中传递, 并且不对其他线程可用, 那么也是线程安全的\npublic void someMethod()&#123;\tLocalObject localObject = new LocalObject();    localObject.callMethod();    method2(localObject);&#125;public void method2(LocalObject localObject)&#123;    localObject.setValue(&quot;value&quot;);&#125;\n\n规则判定 : 如果创建, 使用和处理资源, 永远不会逃脱单个线程的控制, 该资源的使用时线程安全的\n三 : 不可变对象创建不可变的共享对象来保证对象在线程间共享时不会被修改, 从而实现线程安全; \npublic class Demo &#123;    private int value = 0;    public Demo(int value)&#123;        this.value = value;    &#125;    public int getValue()&#123;        return this.value;    &#125;&#125;\n\n实例被创建, value 变量就不能在被修改, 这就是不可变性\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"使用volatile解决可见性问题及阻止指令重排序","url":"/2020/03/20/volatile/","content":"\n使用 volatile 解决可见性问题及阻止指令重排序, 了解 volatile 在 jmm 中的具体实现\n\n一 : 线程操作的定义操作定义\n\nwrite : 要写的变量以及要写的值\nread : 要读的变量以及可见的写入值(由此, 我们可以确定可见的值)\nlock : 要锁定的管程(监视器 monitor)\nunlock : 要解锁的管程\n外部操作(socket等等…)\n启动和终止\n\n程序顺序 : 如果一个程序没有数据竞争, 那么程序的所有执行看起来都是顺序一致的\n二 : 对于同步的规则定义\n对于监视器 m 解锁与所有后续操作对于 m 的加锁同步\n对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步\n启动线程的操作与线程中的第一个操作同步\n对于每个属性写入默认值(0, false, null)与每个线程对其进行的操作同步\n线程 T1 的最后操作与线程 T2 发现线程 T1 已经结束同步(isAlive, join可以判断线程是否终结)\n如果线程 T1 中断了 T2, 那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步; 通过抛出 InterruptedException 异常, 或者调用 Thread.interrupted 或 Thread.isInterrupted\n\n三 : happens-before 先行发生原则happens-before 关系主要用于强调两个有冲突的动作之间的顺序, 以及定义数据争用的发生时机\n具体的虚拟机实现, 有必要确保以下原则的成立 : \n\n某个线程中的每个动作都 happens-before 该线程中该动作后面的动作\n某个管程上的 unlock 动作 happens-before 同一个管程上后续的 lock 动作\n对某个 volatile 字段的写操作 happens-before 每个后续对该 volatile 字段的读操作\n在某个线程对象上调用 start() 方法 happens-before 该启动了线程中的任意动作\n某个线程中的所有动作 happens-before 任意其他线程成功从该线程对象上的 join() 中返回\n如果某个动作 a happens-before 动作 b, 且 b happens-before 动作 c, 则有 a happens-before c\n\n当程序包含两个没有被 happens-before 关系排序的冲突访问时, 就称存在数据争用; 遵守了这个原则, 也就意味着有些代码不能进行重排序, 有些数据不能缓存\n四 : 使用 volatile 解决可见性问题及阻止指令重排序可见性问题 : 让一个线程对共享变量的修改, 能够及时的被其他先成功看到\n根据 jmm(Java Memory Model) 中规定的 happens-before 和同步原则\n\n对某个 volatile 字段的写操作 happens-before 每个后续对该 volitile 字段的读操作\n对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步\n\n要满足这些条件, 所以 volatile 关键字就有这些功能\n\n禁止缓存 : volatile 变量的访问控制符会加 ACC_VOLATILE\n对 volatile 变量相关的指令不做重排序\n\n五 : final 在 JMM 中的处理final 在对象的构造函数中设置对象的字段, 当线程看到该对象时, 将始终看到该对象的 final 字段的正确构造版本; 伪代码实例 : \npublic class FinalDemo &#123;    final int x;    int y;    static FinalDemo f;&#125;f = new finalDemo(); //读取到的 f.x 一定最新, x 为 final 字段\n\n如果在构造函数中设置字段后发生读取, 则会看到该 final 字段分配的值, 否则它将看到默认值; 伪代码示例:\npublic finalDemo()&#123;    x = 1;    y = x; // y等于1&#125;\n\n读取该共享对象的 final 成员变量之前, 先要读取共享对象; 伪代码示例:\nr = new ReferenceObj(); k = r.f; // 这两个操作不能重排序\n\n通常 static final 是不可以修改的字段; 然而 System.in, System.out 和 System.err 是 static final 字段, 遗留原因, 必须允许通过 set 方法改变, 我们将这些字段称为写保护, 以区别与普通 final 字段\n六 : word tearing 字节处理一个字段或元素的更新不得与任务其他字段或元素的读取或者更新交互; 特别是, 分别更新字节数组的相邻元素的两个线程不得干涉或交互, 也不需要同步以确保顺序一致性\n有些处理器(尤其是早期的 Alphas 处理器)没有提供写单个字节的功能; 在这样的处理器上更新 byte 数组, 若只是简单的读取整个额呢绒, 更新对应的字节, 然后将整个内容再写回内存, 将是不合法的\n这个问题有时候被称为**”字分裂(word tearing)”**, 在单独更新单个字节有难度的处理器上, 就需要寻求其他方式了\n基本不需要考虑这个, 了解就好\n七 : double 和 long 的特殊处理虚拟机规范中, 写64位的 double 和 long 分成了两次32位值的操作; 由于不是原子操作, 可能导致读取到某次写操作中 64 位的前 32 位, 以及另外一次写操作的后 32 位\n读写 volatile 的 long 和 double 总是原子的; 读写引用也总是原子的\n商业 jvm 不会存在这个问题, 虽然规范没有要求实现原子性, 但是考虑到实际应用, 大部分实现了原子性\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"线程安全之可见性问题","url":"/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/","content":"\n使用多线程技术总是避免不了要操作同一个变量, 这个时候会不会有什么看不见的情况出现呢 ?\n\n一 : 指令重排序(jit)Java 编程语言的语义允许编译器和微处理器执行优化，这些优化可以与不正确的同步代码交互，从而产生看似矛盾的行为。\n\n重排序\n \n\n等效交换\n\n\n\n通常 javac 将程序源码编译, 转换成 java 字节码(.class), jvm 通过解释字节码将其翻译成相应的机器指令, 逐条读入, 逐条解释翻译; 经过解释运行, 其运行速度必定会比可运行的二进制字节码程序慢; 为了提高运行速度, 引入了 jit 技术\n当 jit 编译启用时(默认是启用的), jvm 读入 .class 文件解释后, 将其发给 jit 编译器; jit 编译器将字节码编译成本机机器代码(汇编指令), 在执行时 jit 会把翻译过的机器码保存起来, 已备下次使用; 因此从理论上来说, 采用该 jit 技术能够接近曾经纯编译技术\n而 java 的指令重排序优化是在 jit 编译阶段, 因此 class 文件是看不出来的, 所以 javap 命令无法帮到你; 如果想要继续向下探索, 可以查看 jit 编译后的汇编代码\n# 通过设置 jvm 的参数, 可以打印出 jit 编译的内容(非class文件)server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log# 关闭jit优化-Djava.compiler=NONE\n\n这些优化可以与不正确的同步代码交互, 从而产生看似矛盾的行为; 这些优化是以单线程为角度的, 当发生多线程运行的时候可能会出现不确定的错误\n二 : Shared VariablesShared Variables : 共享变量\n可以在线程之间共享的内存称为共享内存或堆内存; 所有实例字段, 静态字段和数组元素都存储在堆内存中\n如果至少有一个访问是写的, 那么对同一个变量的两次访问(读或写)是冲突的\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"JVM内存模型","url":"/2020/03/06/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","content":"\n理解 jvm 内存模型可以有助于分析解决多线程种遇到的问题\n\n一 : 多线程中的问题\n所见非所得\n无法肉眼去检测程序的准确性\n不同的运行平台有不同的表现\n错误很难重现\n\n二 : 从内存结构到内存模型每个线程都有自己的工作内存; 如果想要数据共享, 需要存放在主内存中\n \n因为这种内存结构, 在多线程下数据交互会有各种情况出现\n三 : 工作内存缓存cpu 运行时, 与 cpu 交互的主要是 cpu 缓存, 此时可能会出现不同 cpu 缓存中的数据不一致的情况\n \n四 : 内存模型的含义内存模型描述程序的可能行为\njava 编程语言内存模型通过检查执行跟踪中的每个操作, 并根据某些规则检查该读操作观察到的写操作是否有效来工作\n只要程序的所有执行产生结果都可以由内存模型预测; 具体的实现者任意实现, 包括操作的重新排序和删除不必要的同步\n内存模型决定了在程序的每个点上可以读取什么值\n","categories":["高性能编程"],"tags":["多线程并发编程","线程安全"]},{"title":"线程池应用及实现原理剖析","url":"/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/","content":"\n多线程会提高处理速度不假, 但如果使用不合理, 也会造成资源浪费\n\n一 : 为什么要用线程池线程是不是越多越好?\n\n线程在 java 中是一个对象, 更是操作系统的资源, 线程创建和销毁需要时间; 如果创建时间 + 销毁时间 &gt; 执行任务时间就很不合算\njava 对象占用堆内存, 操作系统线程占用系统内存, 根据 jvm 规范, 一个线程默认最大栈大小 1M , 这个栈空间是需要从系统内存中分配的; 线程过多, 会消耗很多的内存\n操作系统需要频繁切换线程上下文, 影响性能\n\n线程池的推出, 就是为了方便的控制线程数量\n二 : 线程池 API三个接口两个实现类\n\n\n\n类型\n名称\n描述\n\n\n\n接口\nExecutor\n最上层的接口, 定义了执行任务的方法 execute\n\n\n接口\nExecutorService\n继承了 Executor 接口, 拓展了 Callable, Future, 关闭方法\n\n\n接口\nScheduledExecutorService\n继承了 ExecutorService, 增加了定时任务相关的方法\n\n\n实现类\nThreadPoolExecutor\n基础, 标准的线程池实现\n\n\n实现类\nScheduledThreadPoolExecutor\n继承了 ThreadPoolExecutor, 实现了 ScheduledExecutorService 中相关定时任务的方法, 可以认为时最丰富的实现类\n\n\n(一) ExecutorService\n方法定义和解释\n// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。awaitTermination(long timeout, TimeUnit unit);// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务，当所有任务完成或超时期满时(无论哪个首先发生)，返回保持任务状态和结果的 Future 列表。invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 执行给定的任务，如果某个任务已成功完成(也就是未抛出异常)，则返回其结果。invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成(也就是未抛出异常)，则返回其结果。invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 如果此执行程序已关闭，则返回 true。isShutdown();// 如果关闭后所有任务都已完成，则返回 true。isTerminated();// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。shutdown();// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。shutdownNow();// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。submit(Callable&lt;T&gt; task);// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。submit(Runnable task);// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。submit(Runnable task, T result)\n\n(二) ScheduledExecutorService\n方法定义和解释\n// 创建并执行在给定延迟后启用的 ScheduledFuture。schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);// 创建并执行在给定延迟后启用的一次性操作。schedule(Runnable command, long delay, TimeUnit unit);// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);\n\nschedule 方法\n\n创建并执行一个一次性任务; \n过了延迟时间就会被执行\n\n\nscheduleAtFixedRate 方法\n\n创建并执行一个周期任务; \n过了给定的初始延迟时间, 会第一次被执行; \n执行过程中发生了异常, 那么任务就停止; \n一次任务执行时长超过了周期时间, 下一次任务会等到该次任务执行结束后, 立刻执行, 这也是它和 scheduleWithFixedDelay 的重要区别\n\n\nscheduleWithFixedDelay 方法\n\n创建并执行一个周期性任务; \n过了初始延迟时间, 第一次被执行, 后续以给定的周期时间执行; \n执行过程中发生了异常, 那么任务就停止; \n一次任务执行时长超过了周期时间, 下一次任务会在该次任务执行结束的时间基础上, 计算执行延时;\n对于超过周期的长时间处理任务的不同处理方式, 这是它和scheduledFixedRate的重要区别\n\n\n\n(三) Executors 工具类你可以自己实例化线程池, 也可以用 Executors 创建线程池的工厂类, 常用方法如下: \n\nnewFixedThreadPool(int nThreads): 创建一个固定大小, 任务队列容量无界的线程池; 推荐: 核心线程数 &#x3D; 最大线程数\nnewCachedThreadPool(): 创建的是一个大小无界的缓冲线程池; 它的任务队列是一个同步队列; 任务加入到池中, 如果池中有空闲线程, 则用空闲线程执行, 如无则创建新线程执行; 池中的线程空闲超过60秒, 将被销毁释放; 线程数随任务的多少变化, 适用于执行耗时较小的异步任务; 池的核心线程数为0, 最大线程数&#x3D;Integer.MAX_VALUE\nnewSingleThreadExecutor(): 只有一个线程来执行无界任务队列的单一线程池; 该线程池确保任务被加入的顺序一个一个一次执行; 当唯一的线程因任务异常中止时, 将创建一个新的线程来继续执行后续的任务; 与 newFixedThreadPool(1)的区别在于, 单一线程池的池大小在 newSingleThreadExecutor() 中硬编码, 不能在改变的\nnewScheduledThreadPool(int corePoolSize): 能定时执行任务的线程池; 该池的核心线程数由参数指定, 最大线程数 &#x3D; Integer.MAX_VALUE\n\n三 : 线程池原理(一) 概念线程池管理器 : 用于创建并管理线程池; 包括创建线程池, 销毁线程池, 添加新任务\n工作线程 : 线程池中线程, 在没有任务时处于等待状态, 可以循环的执行任务\n任务接口 : 每个任务必须实现的接口, 以供工作线程调度任务的执行, 它主要规定了任务的入口, 任务执行完后的收尾工作, 任务的执行状态等\n任务队列 : 用于存放没有处理的任务; 提供一种缓冲机制\n(二) 执行过程首先, 是否达到核心线程数量? \n\n没达到, 创建一个工作线程来执行任务\n达到了, 进入工作队列\n\n其次, 工作队列是否已满? \n\n没满, 则将新提交的任务存储在工作队列里\n满了, 创建新的线程\n\n最后, 是否达到线程池最大数量? \n\n没达到, 则创建一个新的工作线程来执行任务\n达到了, 执行拒绝策略来处理这个任务\n\n过程梳理如图所示\n\n四 : 线程数量如何确定合适数量的线程? 要根据自己任务的类型进行判定\n\n计算型任务 : cpu 数量的1~2倍数\nIO型任务 : 相对比计算型任务, 需要多一些线程, 要根据具体的 IO 阻塞时长进行考量决定; 如 tomcat 中默认的最大线程数为: 200\n\n也可考虑根据需要在一个最小数量和最大数量间自动增减线程数\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程封闭之ThreadLocal和栈封闭","url":"/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/","content":"\n并不是所有多线程都会用到共享数据, 如果数据都是独享的, 就可以使用线程封闭技术\n\n一 : 线程封闭概念多线程访问共享可变数据时, 涉及到线程间数据同步的问题, 并不是所有时候, 都要用到共享数据, 所以线程封闭概念就提出来了\n数据都被封闭在各自的线程之中, 就不需要同步, 这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭\n线程封闭的具体实现有: ThreadLocal, 局部变量\n二 : ThreadLocalThreadLocal 是 java 里一种特殊的变量, 它是一个线程级别变量, 每个线程都有一个 ThreadLocal, 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了, 在并发模式下是绝对安全的变量\n用法: ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;(); 会自动在每一个线程上创建一个 T 的副本, 副本之间彼此独立, 互不影响; 可以用 ThreadLocal 存储一些参数, 以便在线程中多个方法中使用, 用来代替方法传参的做法; \n\n代码示例\npublic static ThreadLocal&lt;String&gt; value = new ThreadLocal&lt;&gt;();public void threadLocalTest() throws InterruptedException &#123;    value.set(&quot;123&quot;);    String v = value.get();    System.out.println(&quot;线程1执行之前,主线程取到的值: &quot; + v);    new Thread(()-&gt;&#123;        String s = value.get();        System.out.println(&quot;线程1取到的值: &quot; + s);        value.set(&quot;456&quot;);        s = value.get();        System.out.println(&quot;重新设置后,线程1取到的值: &quot; + s);    &#125;).start();    Thread.sleep(5000L);    v = value.get();    System.out.println(&quot;线程1执行之后,主线程取到的值: &quot; + v);&#125;public static void main(String[] args) throws InterruptedException &#123;    new ThreadLocalDemo().threadLocalTest();&#125;\n\n实在难以理解的, 可以理解为, jvm 维护了一个 Map&lt;Thread, T&gt;, 每个线程要用这个 T 的时候, 用当前的线程去 Map 里面取, 仅作为一个概念理解\n三 : 栈封闭局部变量的固有属性之一就是封闭在线程中\n它们位于执行线程的栈中, 其他线程无法访问这个栈\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程通信","url":"/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","content":"\n使用多线程技术往往会涉及到线程间的协同工作, 我们称为线程通信\n\n一 : 通信的方式要想实现多个线程之间的协同, 如: 线程执行先后顺序, 获取某个线程执行的结果等等\n涉及到线程之间相互通信, 分为四类:\n\n文件共享\n网络共享\n共享变量\nJDK 提供的线程协调 API (suspend&#x2F;resume, wait&#x2F;notify, park&#x2F;unpark)\n\n二 : 文件共享\n线程1在文件中写入数据, 线程2从文件中读取数据\n\n代码演示\npublic class Demo &#123;    public static void main(String[] args) &#123;        // 线程1 写入数据        new Thread(() -&gt; &#123;            try &#123;                Files.write(Paths.get(&quot;a.txt&quot;), (&quot;当前时间: &quot; + System.currentTimeMillis()).getBytes());                Thread.sleep(1000L);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 线程2 读数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    Thread.sleep(1000L);                    byte[] bytes = Files.readAllBytes(Paths.get(&quot;a.txt&quot;));                    System.out.println(new String(bytes));                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n\n三 : 变量共享\n线程-1在内存中写入数据, 线程-2从内存中读取数据\n\n代码演示\npublic class Demo &#123;    public static String content = &quot;&quot;;    public static void main(String[] args) &#123;        // 线程1 写入数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    content = &quot;当前时间: &quot; + System.currentTimeMillis();                    Thread.sleep(1000L);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 线程2 读取数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    Thread.sleep(1000L);                    System.out.println(content);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n\n四 : 线程协作-JDK APIJDK 中对于需要多线程协作完成某一任务的场景, 提供了对应API支持\n多线程协作的典型场景是 : 生产者 - 消费者模型(线程阻塞, 线程唤醒); \n\n(一) suspend&#x2F;resume 机制(弃用)\n作用: 调用 suspend 挂起目标线程, 通过 resume 可以恢复线程执行; 被弃用的主要原因是, 容易写出死锁的代码, 所以用 wait&#x2F;notify 和 park&#x2F;unpark 机制对它进行替代\npublic static Object baozi = null;/** * 买包子 =&gt; 如果没有包子 =&gt; 则进入等待 =&gt; 当生产出包子后通知消费者 */public void suspendResumeTest() throws Exception &#123;    Thread thread = new Thread(() -&gt; &#123;        if (baozi == null) &#123;            System.out.println(&quot;没有包子, 进入等待&quot;);            Thread.currentThread().suspend();        &#125;        System.out.println(&quot;买到包子&quot;);    &#125;);    thread.start();    // 3秒后通知消费者    Thread.sleep(3000L);    baozi = new Object();    thread.resume();    System.out.println(&quot;生产出包子,通知消费者&quot;);&#125;\n\nsuspend 和 resume 死锁示例\npublic static Object baozi = null;/** * suspend并不会像wait一样释放锁,很容易出现死锁代码 * 还是买包子, 但如果出现了锁竞争问题, 就会出现死锁 */public void suspendResumeDeadLockTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        if (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            synchronized (this) &#123;                Thread.currentThread().suspend();            &#125;        &#125;        System.out.println(&quot;买到包子&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒后生产包子&quot;);    synchronized (this) &#123;        thread.resume();    &#125;    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n(二) wait&#x2F;notify 机制\n这些方法只能由同一对象锁的持有者线程调用, 也就是写在同步块里面, 否则会抛出 IllegalMonitorStateException 异常\n\nwait 方法导致当前线程等待, 加入该对象的等待集合中, 并且放弃当前持有的对象锁\n\nnotify&#x2F;notifyAll 方法唤醒一个或者所有正在等待这个对象锁的线程\npublic static Object baozi = null;/** * 正常的wait/notify * 还是买包子,可以有锁竞争,因为wait会释放锁 */public void waitNotifyTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        synchronized (this) &#123;            while (baozi == null) &#123;                try &#123;                    System.out.println(&quot;没有包子,进入等待&quot;);                    this.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    synchronized (this) &#123;        this.notify();        System.out.println(&quot;有包子了,通知消费者&quot;);    &#125;&#125;\n\n注意: 虽然会 wait 自动解锁, 但是对顺序有要求, 如果在 notify 被调用之后才开始wait方法的调用, 线程会永远处于 WAITING 状态\npublic static Object baozi = null;/** * wait/notify会释放锁, 但是如果出现先notify(通知)后wait(等待) * 这是线程就会一直等待, 也可以看作是另一种形式的死锁 */public void waitNotifyWaitForeverTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            try &#123;                Thread.sleep(5000L);                synchronized (this) &#123;                    System.out.println(&quot;没有包子,进入等待&quot;);                    this.wait();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒后,生产包子&quot;);    synchronized (this) &#123;        this.notify();        System.out.println(&quot;有包子了,通知消费者&quot;);    &#125;&#125;\n\n(三) park&#x2F;unpark 机制\n线程调用 park 则等待许可(permit), unpark 方法为指定线程提供”许可(permit)”\n\n不要求 park 和 unpark 方法的调用顺序\n\n多次调用 unpark 之后, 再调用 park , 线程会直接运行\n\n但不会叠加, 也就是说, 连续多次调用 park 方法, 第一次会拿到”许可”直接运行, 后续调用会进入等待状态\n/** * 正常的park/unPark */public void parkUnparkTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            LockSupport.park();        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    System.out.println(&quot;休眠3秒后生产包子&quot;);    baozi = new Object();    LockSupport.unpark(thread);    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n注意: 同步代码容易写出死锁代码\n/** * park/unpark虽然没有顺序要求, 但是如果不会释放锁 * 如果出现锁竞争问题,还是要考虑死锁的问题 */public void parkUnparkDeadLockTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            synchronized (this) &#123;                LockSupport.park();            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒,生产包子&quot;);    synchronized (this) &#123;        LockSupport.unpark(thread);    &#125;    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n五 : 伪唤醒\n警告: 之前代码中用 if 语句来判断是否进入等待状态, 这是错误的 !\n\n官方建议应该在循环中检查等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒, 如果不在循环中检查等待条件, 程序就会在没有满足条件的情况下退出\n\n伪唤醒是指线程并非因为 notify, notifyAll, unpark 等 api 调用而唤醒, 是更底层原因导致的\n//waitsynchronized (obj) &#123;    while (&lt;条件判断&gt;)        obj.wait();    ...//执行后续操作&#125;&#125;// parkwhile (&lt;条件判断&gt;)    LockSupport.park();\t...//执行后续操作\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"内存屏障和CPU缓存","url":"/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/","content":"\n多核心处理器的出现使得计算机性能得到了巨大的提升, 但同时会不会出现什么问题, 并且解决了吗 ?\n\n一 : CPU性能优化手段-缓存为了提高程序运行的性能, 现代 CPU 在很多方面对程序进行了优化; 例如 : CPU 高速缓存, 尽可能地避免处理器访问主内存的时间开销, 处理器大多会利用缓存(cache)以提高性能\nCPU &lt;===&gt; L1-L3缓存 &lt;===&gt;CPU &lt;===&gt; L1-L3缓存 &lt;===&gt; 缓存一致性协议 &lt;===&gt; 主内存CPU &lt;===&gt; L1-L3缓存 &lt;===&gt;\n\n(一) 多级缓存L1 Cache(一级缓存)是 CPU 第一层高速缓存, 分为数据缓存和指令缓存; 一般服务器 CPU 的 L1 缓存的容量通常在 32~4096KB\nL2 由于 L1 级高速缓存容量的限制, 为了再次提高CPU的运算速度, 在 CPU 外部放置一高速存储器, 即二级缓存\nL3 现在的都是内置的; 作用是: L3缓存的应用可以进一步降低内存延迟, 同时提升大数据量计算时处理器的性能; 具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度; 一般是多核共享一个 L3 缓存\n读取顺序 : CPU 在读取数据时, 现在 L1 中寻找, 再从 L2 寻找, 再从 L3 寻找, 然后是内存, 再后是外存储器\n(二) 缓存同步协议多 CPU 读取同样的数据进行缓存, 进行不同运算之后, 最终写入主内存以哪个 CPU 为准 ?\n在这种高速缓存写的场景下, 有一个缓存一致性协议(MESI 协议), 多数 CPU 厂商对它进行了实现; 它规定每条缓存有个状态位, 同时定义了下面四个状态 :\n\n修改态(Modified) : 此 cache 行已被修改过(脏行), 内容已不同于主内存, 为此 cache 专有\n专有态(Exclusive) : 此 cache 行内容同于主存, 但不出现于其他 cache 中\n共享态(Shared) : 此 cache 行内容同于主存, 但也出现于其他 cache 中\n无效态(Invalid) : 此 cache 行 内容无效(空行)\n\n多处理器时, 单个 CPU 对缓存中数据进行了改动, 需要通知给其他 CPU; 也就是意味着, CPU 处理要控制自己的读写操作, 还要监听其他 CPU 发出的通知, 从而保证最终一致\n二 : CPU性能优化手段-运行时指令重排指令重排的场景 : 当 CPU 写缓存时发现缓存区块正被其他 CPU 占用, 为了提高 CPU 处理性能, 可能将后面的读缓存命令优先执行\n \n并非随便重排, 需要遵守 as-if-serial 语义\nas-if-serial 语义的意思指: 不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变; 编译器, runtime 和处理器都必须遵守 as-if-serial 语义\n也就是说: 编译器和处理器不会对存在数据依赖关系的操作重排序\n三 : 两个问题CPU 高速缓存下有一个问题 :\n\n缓存中的数据与主内存的数据并不是实时同步的, 各 CPU (或 CPU 核心) 间缓存的数据也不是实时同步;\n在同一个时间点, 各 CPU 所看到同一内存地址的数据的值可能时不一致的\n\nCPU 执行指令重排序优化下有一个问题 :\n\n虽然遵守了 as-if-serial 语义, 但仅在单 CPU 自己执行的情况下能保证结果正确;\n多核多线程中, 指令逻辑无法分辨因果关联, 可能出现乱序执行, 导致程序运行结果错误\n\n四 : 内存屏障处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题 : \n\n写内存屏障(Store Memory Barrier): 在指令后插入 Store Barrier, 能让写入缓存中的最新数据更新写入主内存, 让其他线程可见; 强制写入主内存, 这种显示调用, CPU 就不会因为性能考虑而去对指令重排\n读内存屏障(Load Memory Barrier): 在指令前插入 Load Barrier, 可以让高速缓存中的数据失效, 强制重新从主内存加载数据; 强制读取主内存内容, 让 CPU 缓存与主内存保持一致, 避免了缓存导致的一致性问题\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程终止","url":"/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/","content":"\n如果需要终止正在运行的线程, 我们希望数据可以保持准确性\n\n一 : stop(不建议)\nstop : 中止线程, 并且清除监控器锁的信息, 但是可能导致线程安全问题, JDK 不建议用\n\ndestroy : JDK 未实现该方法\n\n代码演示\npublic class Demo &#123;    public static void main(String[] args) throws InterruptedException &#123;        StopThread thread = new StopThread();        thread.start();        // 休眠1秒，确保i变量自增成功        Thread.sleep(1000);        // 暂停线程        thread.stop(); // 错误的终止        while (thread.isAlive()) &#123;            // 确保线程已经终止        &#125;         // 输出结果        thread.print();    &#125;&#125;class StopThread extends Thread &#123;    private int i = 0, j = 0;    @Override    public void run() &#123;        synchronized (this) &#123;            // 增加同步锁，确保线程安全            ++i;            try &#123;                // 休眠10秒,模拟耗时操作                Thread.sleep(10000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            ++j;        &#125;    &#125;    /**     * 打印i和j     */    public void print() &#123;        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);    &#125;&#125;\n\n二 : interrupt(推荐)\n如果目标线程在调用 Object class 的 wait(), wait(long) 或 wait(long, int) 方法, join(), join(long, int) 或者 sleep(long, int) 方法时被阻塞, 那么 interrupt 会生效, 该线程的中断状态将被清除, 抛出 InterruptedException 异常\n\n如果目标线程是被 I&#x2F;O 或者 NIO 中的 Channel 所阻塞, 同样, I&#x2F;O 操作会被中断或者返回特殊异常值; 达到终止线程的目的\n\n如果以上条件都不满足, 则会设置此线程的终端状态\n\n代码示例, 修改之前的代码 : \n// thread.stop(); // 错误的终止thread.interrupt(); // 正确终止\n\n将 stop 改成 interrupt 后, 最终输出为 i=1 j=1, 数据一致\n\n\n三 : 标志位(推荐)\n代码逻辑中, 增加一个判断, 用来控制线程执行的中止\n\n代码示例\n/** 通过状态位来判断 */public class Demo extends Thread &#123;        public volatile static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            try &#123;                while (flag) &#123; // 判断是否运行                    System.out.println(&quot;运行中&quot;);                    Thread.sleep(1000L);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 3秒之后，将状态标志改为False，代表不继续运行        Thread.sleep(3000L);        flag = false;        System.out.println(&quot;程序运行结束&quot;);    &#125;&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程状态","url":"/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","content":"\n线程的6种状态及状态切换\n\n一 : 状态定义定义位置 : java.lang.Thread.State\n线程状态 : 新建, 可运行, 阻塞, 等待, 超时等待, 终止\n\nNew : 尚未启动的线程的线程状态\nRunnable : 可运行线程的线程状态, 等待CPU调度\nBlocked : 线程阻塞, 等待监视器锁定的线程状态; 处于 synchronized 同步代码块或方法中被阻塞\nWaiting : 等待线程的线程状态; 不带超时的方式(Object.wait, Thread.join, LockSupport.park)\nTime Waiting : 具有指定等待时间的等待线程的线程状态; 带超时的方式(Thread.sleep, Object.wait, Thread.join, LockSupport.parkNanos, LockSupport.parkUntil)\nTerminated : 终止线程的线程状态; 线程正常完成执行或者出现异常\n\n二 : 线程状态切换这 6 种状态在一定条件下会发生转换\n \n\nNew 新线程通过调用 start 进入 Runnable 可运行状态\nRunnable 可运行状态在等待锁的时候会进入 Blocked 阻塞状态; 一旦拿到锁, 便会从 Blocked 阻塞状态进入 Runnable 可运行状态\nRunnable 可运行状态在等待其他线程的通知时会进入 Waiting 等待状态; 一旦收到通知,继续执行时, 便会从 Waiting 等待状态进入 Runnable 可运行状态\nRunnable 可运行状态在有超时时间的等待其他线程的通知时会进入 Time Waiting 定时等待状态; 一旦等待超时或者收到通知, 继续执行时则会进入 Runnable 状态\nRunnable 可运行状态在线程执行结束时会成为 Terminated 终止状态\n\n三 : 代码演示\nNew &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    // 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread1 = new Thread(() -&gt; &#123;        System.out.println(&quot;thread1当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread1 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法,thread1当前状态: &quot; + thread1.getState().toString());    thread1.start();    Thread.sleep(2000L); // 等待thread1执行结束，再看状态    System.out.println(&quot;等待两秒,再看thread1当前状态: &quot; + thread1.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Timed Waiting &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)    System.out.println(&quot;### 第二种: 新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式) ###&quot;);    Thread thread2 = new Thread(() -&gt; &#123;        try &#123;            // 进入超时等待, 时间1.5s            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;thread2当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread2 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    thread2.start();    System.out.println(&quot;调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(200L); // 等待200毫秒，再看状态    System.out.println(&quot;等待200毫秒，再看thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态    System.out.println(&quot;等待3秒，再看thread2当前状态: &quot; + thread2.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Blocked &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread3 = new Thread(()-&gt; &#123;        synchronized (Demo.class) &#123;            System.out.println(&quot;thread3当前状态: &quot; + Thread.currentThread().getState().toString());            System.out.println(&quot;thread3 执行了&quot;);        &#125;    &#125;);    synchronized (Demo.class) &#123;        System.out.println(&quot;没调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        thread3.start();        System.out.println(&quot;调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        Thread.sleep(200L); // 等待200毫秒，再看状态        System.out.println(&quot;等待200毫秒，再看thread3当前状态: &quot; + thread3.getState().toString());    &#125;    Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态    System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态: &quot; + thread3.getState().toString());&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"Java程序运行堆栈分析","url":"/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/","content":"\njava 代码写起来很简单, 但具体是怎么运行的呢?\n\n一 : 概述jvm 运行时数据区大致可以分为两部分 : 线程共享部分和线程独占部分\n\n\n线程共享 : 所有线程能访问这块内存数据, 随虚拟机或者 GC 而创建和销毁; 方法区和堆内存皆属此列\n线程独占 : 每个线程都会有它的独立的空间, 随线程生命周期而创建和销毁; 虚拟机栈, 本地方法栈和程序计数器属于线程独占\n二 : JVM运行时数据区(一) 方法区jvm 启动时创建, 用来存储加载类信息, 常量, 静态变量, 编译后的代码等数据; \n\n虚拟机规范中这是一个逻辑区划, 具体实现根据不同虚拟机来实现; 例如: \n\noracle 的 HotSpot 在 java7 中方法区放在永久代; \njava8 放在元数据空间 (metaspace), 并且通过 GC 机制对这个区域进行管理。\n\n(二) 堆内存jvm 启动时创建, 存放对象的实例; 垃圾回收器主要就是管理堆内存; \n\n如果满了, 就会出现 OutOfMemroyError; \n堆内存还可以细分为 : 新生代(Eden, From Survivor(s0) 和 To Survivor(s1))和老年代 (Old)\n(三) 虚拟机栈随线程的生命周期创建和销毁, 每个线程都在在这个空间有一个私有的空间, 这个空间称为线程栈; \n\n线程栈由多个栈帧 (Stack Frame) 组成; 栈帧内容包含 : 局部变量表, 操作数栈, 动态链接, 方法返回地址和附加信息等; \n一个线程会执行一个或多个方法, 一个方法对应一个栈帧; \n栈内存默认最大是 1M, 超出则抛出 StackOverflowError\n(四) 本地方法栈和虚拟机栈功能类似, 虚拟机栈是为虚拟机执行java方法而准备的, 本地方法栈是为虚拟机使用 Native 本地方法而准备的;\n\n虚拟机规范没有规定具体的实现, 由不同的虚拟机厂商去实现;\nHotSpot 虚拟机中虚拟机栈和本地方法栈的实现是一样的; 同样, 超出大小以后也会抛出 StackOverflowError\n(五) 程序计数器程序计数器 (Program Counter Register) 记录当前线程执行字节码的位置, 存储的是字节码指令地址, \n\n如果执行Native方法, 则计数器值为空;\n每个线程都在这个空间有一个私有的空间, 占用内存空间很少;\nCPU 同一时间, 只会执行一条线程中的指令; jvm 多线程会轮流切换并分配 CPU 执行时间; 线程切换后, 需要通过程序计数器, 来恢复正确的执行位置\n三 : class文件内容(一) 概述class 文件包含 java 程序执行的字节码; 数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符; 文件开头有一个ca fe ba be (16进制)特殊的一个标志; \n \n这个文件具有复杂且严格的格式, 专门给 jvm 读取其中的内容, 人类可以借助工具查看; 其中包含 : 版本信息, 访问标志, 常量池, 当前类, 超级类, 接口, 字段, 方法, 属性等信息\n(二) 内容分析\n示例代码\npublic class Demo &#123;    public static void main(String[] args) &#123;        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a + b);    &#125;&#125;\n\n反编译 class 文件并重定向到 txt\n# 编译命令$ javac Demo.java# 反编译将其写入txt文件$ javap -v Demo.class &gt; Demo.txt\n\n版本号&#x2F;访问控制, 版本号规则 : JDK5,6,7,8 分别对应 49,50,51,52\npublic class Demo  minor version: 0 //次版本号  major version: 52 //主版本号  flags: ACC_PUBLIC, ACC_SUPER //访问标志\n\n常量池\nConstant pool:   #1 = Methodref          #5.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V   #4 = Class              #19            // Demo1   #5 = Class              #20            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               main  #11 = Utf8               ([Ljava/lang/String;)V  #12 = Utf8               SourceFile  #13 = Utf8               Demo1.java  #14 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #15 = Class              #21            // java/lang/System  #16 = NameAndType        #22:#23        // out:Ljava/io/PrintStream;  #17 = Class              #24            // java/io/PrintStream  #18 = NameAndType        #25:#26        // println:(I)V  #19 = Utf8               Demo1  #20 = Utf8               java/lang/Object  #21 = Utf8               java/lang/System  #22 = Utf8               out  #23 = Utf8               Ljava/io/PrintStream;  #24 = Utf8               java/io/PrintStream  #25 = Utf8               println  #26 = Utf8               (I)V\n\n构造方法 : 示例中并没有写构造函数, 由此可见, 没有定义构造函数时, 会有隐式的无参构造函数\npublic Demo();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=1, locals=1, args_size=1      0: aload_0      1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      4: return    LineNumberTable:      line 1: 0\n\n程序入口 main 方法 : stack(操作数栈), locals(为本地变量表)\npublic static void main(java.lang.String[]);  descriptor: ([Ljava/lang/String;)V  flags: ACC_PUBLIC, ACC_STATIC\t//访问控制  Code:    stack=3, locals=5, args_size=1      /**       * jvm执行引擎去执行这些源码编译过后的指令码       * javap编译出来是操作符,class文件内存的是指令码       * 前面的数字,是偏移量(字节),jvm根据这个去区分不同的指令(查看jvm指令码表)       */       0: sipush        500       3: istore_1       4: bipush        100       6: istore_2       7: iload_1       8: iload_2       9: idiv      10: istore_3      11: bipush        50      13: istore        4      15: getstatic     #2        // Field java/lang/System.out:Ljava/io/PrintStream;      18: iload_3      19: iload         4      21: iadd      22: invokevirtual #3        // Method java/io/PrintStream.println:(I)V      25: return    LineNumberTable:      line 3: 0      line 4: 4      line 5: 7      line 6: 11      line 7: 15      line 8: 25\n\n四 : 程序完整运行分析(一) 加载信息到方法区此时属于线程共享部分的方法区会存在大量的类信息, 同时还存在运行时常量池字符串常量。\nHotSpot 虚拟机 : 1.7及之前称为永久代, 1.8开始称为元数据空间。\n(二) jvm 创建线程来执行代码在虚拟机栈, 程序计数器内存区域中创建线程独占的空间。\n虚拟机栈中存放Thread栈帧, 程序计数器中存放Thread执行位置(字节码指令地址)。\n(三) 方法区程序入口main 方法栈帧初始化 : 5个本地变量, 变量0是方法参数 args\n \n(四) 程序执行过程\n将500压入操作数栈\n\n\n弹出操作数栈栈顶500保存到本地变量表1\n\n\n将100压入操作数栈\n\n\n弹出操作数栈栈顶100保存到本地变量表2\n\n\n读取本地变量1压入操作数栈\n\n\n读取本地变量2压入操作数栈\n\n\n将栈顶两int类型数相除, 结果入栈 500&#x2F;100&#x3D;5\n\n\n将栈顶int类型值保存到局部变量3中\n\n\n将50压入操作数栈\n\n\n将栈顶int类型值保存到局部变量4中\n\n\n获取类或接口字段的值并将其压入操作数栈\n\n\n将本地变量3取出压入操作数栈\n\n\n将本地变量4取出压入操作数栈\n\n\n将栈顶两int类型数相加, 结果入栈\n\n\n调用静态方法; jvm会根据这个方法的描述,创建新栈帧, 方法的参数从操作数栈中弹出来,压入虚拟机栈, 然后虚拟机会开始执行虚拟机栈最上面的栈帧; 执行完毕后,再继续执行main方法对应的栈帧\n\n\nvoid函数返回, main方法执行结束\n\n\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"博客图床","url":"/2019/12/25/blog-images/","content":"\n要写博客, 免不了要图文结合, 图片怎么办 ?\n\n一 : typora\n下载地址 : https://download2.typoraio.cn/windows/typora-setup-x64.exe\n傻瓜式安装即可\n\n二 : github\n创建一个公开仓库 : blog_images\n在 settings &#x3D;&gt; Developer settings &#x3D;&gt; Personal access tokens 里生成一个 token\n\n三 : picgo\n文件 &#x3D;&gt; 偏好设置 &#x3D;&gt; 图像, 做如下修改\n\n\n点击下载或更新, 下载 PicGo-Core(command-line)\n\n下载完毕后, 点击打开配置文件, 或者手动打开 C:/Users/&#123;用户名&#125;/.picgo/config.json, 参考下面文件进行配置\n&#123;    &quot;picBed&quot;: &#123;\t\t&quot;current&quot;: &quot;github&quot;,        &quot;github&quot;: &#123;            &quot;repo&quot;: &quot;info4z/blog_images&quot;,            &quot;branch&quot;: &quot;main&quot;,            &quot;token&quot;:&quot;刚刚生成的 Personal access tokens&quot;,              &quot;path&quot;: &quot;images&quot;,            &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/info4z/blog_images@main&quot;        &#125;    &#125;,    &quot;picgoPlugins&quot;: &#123;&#125;&#125;\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客美化","url":"/2019/12/24/blog-theme/","content":"\nhexo 提供了博客的骨架, 通过 kaze 使其丰满起来吧\n\n一 : 主题\n博客搭建完毕后, 可以对其进行一定的美化, 可以使用 kaze 主题\n$ git clone git@github.com:theme-kaze/hexo-theme-kaze.git themes/kaze\n\n二 : 站点配置\n编辑博客根目录下的 _config.yml\n# Sitetitle: 冰清阁\t\t#标题subtitle: &#x27;&#x27;description: &#x27;差不多得了, 玩什么命呀...&#x27;\t#简介或者格言keywords:author: 清月明风\t\t#作者language: zh-CN\t\t#主题语言,查看themes\\next\\languages下面的具体名字timezone: Asia/Shanghai\t\t#中国的时区# URLurl: https://info4z.github.io# 代码高亮highlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: trueprismjs:  enable: false# Extensionstheme: kaze\n\n三 : 主题配置\n修改 kaze下的 _config.yml\n# Header configtitle: 冰清阁author: 清月明风logo_img: https://img.songhn.com/img/Y67gdd.pngauthor_img: https://img.songhn.com/img/Y67gdd.pngauthor_description: 差不多得了, 玩什么命呀...\n\n目录\n# Navbar configmenus:  home: /  tags: /tags  categories: /categories  archive: /archives  about: /about  friends: /friends\n\n当然了, 有些目录是不存在的, 需要手动创建\n$ hexo new page tags$ hexo new page categories$ hexo new page about$ hexo new page friends\n\n搜索\nsearch:  enable: true  path: search.json  field: posts  searchContent: true\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客搭建","url":"/2019/12/24/blog-hexo/","content":"\n基于 hexo 在 github 上搭建属于自己的博客\n\n一 : nodejs\n官网 : https://nodejs.org/zh-cn/\n\n下载地址 : https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi (长期维护版即可)\n\n安装完成后 : \n# 查看node版本$ node -v\n\n二 : npm\nnode.js 自带 npm\n# 查看npm版本$ npm -v\n\nnpm 有时候不是特别好用, 可以使用 cnpm\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n安装过程中可能会出现无法加载文件的问题, 解决方案如下\n# 以管理员身份运行powerShellPS D:\\Blog&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS D:\\fore\\jshERP-web&gt; get-ExecutionPolicyRemoteSigned\n\n查看版本信息\n$ cnpm -v\n\n三 : hexo\n使用 npm 安装 hexo\n# npm和cnpm哪个好使用哪个$ cnpm install -g hexo-cli\n\n初始化\n# init : Create a new Hexo folder$ hexo init\n\n生成工具栏\n$ hexo new page tags \t\t# 新增标签$ hexo new page categories\t# 新增分类\n\n新写文章\n# 这里$ hexo new &quot;文章题目&quot;\n\n本地启动\n$ hexo server$ hexo s\n\n生成静态文件\n$ hexo generate$ hexo g\n\n四 : github\n创建仓库, 这里只需要注意 repository name 的值为 :  用户名.github.io\n\n通过 Settings 查看 Pages\nYour site is live at https://info4z.github.io/\t\t# 这就是个人博客的地址\n\n编辑 _config.yml\ndeploy:  type: git  repository: git@github.com:info4z/info4z.github.io.git \t# 用ssh连接  branch: main\n\n安装 git 部署插件\n$ cnpm install hexo-deployer-git --save\n\n执行如下指令\n# 清除缓存文件db.json和已生成的静态文件public$ hexo clean   # 生成网站静态文件到默认设置的public文件夹(generate)$ hexo g# 自动生成网站静态文件,并部署到设定的仓库(deploy)$ hexo d\n\n","categories":["博客搭建"],"tags":[]},{"title":"Hello World","url":"/2019/12/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["博客搭建"],"tags":[]}]