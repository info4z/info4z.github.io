[{"title":"Arthas","url":"/2023/01/13/arthas/","content":"\njava 诊断工具, 用于生产环境调错\n\n一 : 概述(一) 概述Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。\n(二) 背景通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 IDE 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。\n开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。\n如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 JVM 重新启动，它可能无法复现，如上文所述。\nArthas 旨在解决这些问题。开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。\n(三) 用途Arthas 是 Alibaba 开源的 Java 诊断工具。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：\n\n这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？\n我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n是否有一个全局视角来查看系统的运行状况？\n有什么办法可以监控到 JVM 的实时运行状态？\n怎么快速定位应用的热点，生成火焰图？\n怎样直接从 JVM 内查找某个类的实例？\n\n二 : 快速入门(一) 下载启动\n下载 jar 包\n$ curl -O https://arthas.aliyun.com/arthas-boot.jar\n\n启动\n# 执行该程序的用户需要和目标进程具有相同的权限$ java -jar arthas-boot.jar# 可以执行如下命令来查看帮助$ java -jar arthas-boot.jar -h\n\n选择应用 : 数据对应程序的编号, 然后回车即可\n\n未进入指定程序退出 : ctrl + c\n\n进入指定程序后退出 : ctrl + d\n\n\n(二) 常用操作\ndashboard : 选择指定程序后, 输入 dashboard 后回车, 即可进入看板, 按 ctrl+c 可以中断执行\n$ dashboard\n\n\n主要涉及到当前执行的线程, 内存情况和运行环境\n\n\nthread : 查看当前线程, 命令 : thread ID\n$ thread 1 | grep &#x27;main(&#x27;    at demo.MathGame.main(MathGame.java:17)\n\njad : 反编译工具, 通过 jad 来反编译 Main Class\n$ jad demo.MathGame\n\nwatch : 查看具体函数的参数和返回值\n$ watch demo.MathGame primeFactors returnObj\n\n(三) 退出\n如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。\n如果想完全退出 arthas，可以执行stop命令。\n\n","categories":["服务器"],"tags":["监控","诊断"]},{"title":"mysql数据统计","url":"/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/","content":"\n统计数据占用磁盘空间的大小\n\n一 : 库表结构\nMySQL 的 information_schema 数据库, 保存着数据库的容量和使用信息, 可查询数据库中每个表占用的空间, 表记录的行数\n\nTABLES 表结构\nCREATE TEMPORARY TABLE `TABLES` (  `TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_NAME` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_TYPE` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `ENGINE` varchar(64) DEFAULT NULL,  `VERSION` bigint(21) unsigned DEFAULT NULL,  `ROW_FORMAT` varchar(10) DEFAULT NULL,  `TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,  `AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_FREE` bigint(21) unsigned DEFAULT NULL,  `AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,  `CREATE_TIME` datetime DEFAULT NULL,  `UPDATE_TIME` datetime DEFAULT NULL,  `CHECK_TIME` datetime DEFAULT NULL,  `TABLE_COLLATION` varchar(32) DEFAULT NULL,  `CHECKSUM` bigint(21) unsigned DEFAULT NULL,  `CREATE_OPTIONS` varchar(255) DEFAULT NULL,  `TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &#x27;&#x27;) ENGINE=MEMORY DEFAULT CHARSET=utf8\n\n重点字段说明\n\n\n\n字段\n解释\n\n\n\nTABLE_SCHEMA\n数据库名\n\n\nTABLE_NAME\n表名\n\n\nENGINE\n存储引擎\n\n\nTABLE_ROWS\n记录数\n\n\nDATA_LENGTH\n数据大小(单位B)\n\n\nINDEX_LENGTH\n索引大小\n\n\n\n\n二 : 查询示例(一) 数据总占用量\n求和 &#x3D;&gt; 单位转换 &#x3D;&gt; 加单位\nselect \tconcat(round(sum(DATA_LENGTH/1024/1024/1024),2),&#x27;GB&#x27;) as data from information_schema.TABLES\n\n(二) 每个表占用量\ntable_name, table_rows, data_length\nselect \ttable_name, \tconcat(round(sum(data_length/1024/1024/1024),2),&#x27;G&#x27;) as data from information_schema.tables where table_schema=&#x27;dbname&#x27; group by table_name order by data desc;\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"内存占用过高","url":"/2020/03/06/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/","content":"\n服务器内存占用过高, 缓存不释放导致死机,  重启后持续几天再次占满\n\n一 : 故障现象\n服务器内存占用过高, 导致死机\n服务器硬重启 3-5 天再次占满\n\n二 : 问题排查\ncpu 使用率 : top\n定时任务 crontab -l\n文件的读取和写入 : ftp, log\n\n三 : 解决方案(一) 手动清理\n可手动清理页文件缓存\necho 1 &gt; /proc/sys/vm/drop_caches\n\n(二) 设置最低剩余内存\n修改 sysctl.conf 配置文件\nvim /etc/sysctl.conf# 最后加入一行vm.min_free_kbytes = 2097152\n\n使配置文件生效\n$ sudo sysctl -p\n\n第一种方法直接清空缓存, 可能会造成数据丢失, 我们选用第二种\n\n\n","categories":["服务器"],"tags":["内存"]},{"title":"线程池应用及实现原理剖析","url":"/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/","content":"\n多线程会提高处理速度不假, 但如果使用不合理, 也会造成资源浪费\n\n一 : 为什么要用线程池线程是不是越多越好?\n\n线程在 java 中是一个对象, 更是操作系统的资源, 线程创建和销毁需要时间; 如果创建时间 + 销毁时间 &gt; 执行任务时间就很不合算\njava 对象占用堆内存, 操作系统线程占用系统内存, 根据 jvm 规范, 一个线程默认最大栈大小 1M , 这个栈空间是需要从系统内存中分配的; 线程过多, 会消耗很多的内存\n操作系统需要频繁切换线程上下文, 影响性能\n\n线程池的推出, 就是为了方便的控制线程数量\n二 : 线程池 API三个接口两个实现类\n\n\n\n类型\n名称\n描述\n\n\n\n接口\nExecutor\n最上层的接口, 定义了执行任务的方法 execute\n\n\n接口\nExecutorService\n继承了 Executor 接口, 拓展了 Callable, Future, 关闭方法\n\n\n接口\nScheduledExecutorService\n继承了 ExecutorService, 增加了定时任务相关的方法\n\n\n实现类\nThreadPoolExecutor\n基础, 标准的线程池实现\n\n\n实现类\nScheduledThreadPoolExecutor\n继承了 ThreadPoolExecutor, 实现了 ScheduledExecutorService 中相关定时任务的方法, 可以认为时最丰富的实现类\n\n\n(一) ExecutorService\n方法定义和解释\n// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。awaitTermination(long timeout, TimeUnit unit);// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务，当所有任务完成或超时期满时(无论哪个首先发生)，返回保持任务状态和结果的 Future 列表。invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 执行给定的任务，如果某个任务已成功完成(也就是未抛出异常)，则返回其结果。invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成(也就是未抛出异常)，则返回其结果。invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 如果此执行程序已关闭，则返回 true。isShutdown();// 如果关闭后所有任务都已完成，则返回 true。isTerminated();// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。shutdown();// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。shutdownNow();// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。submit(Callable&lt;T&gt; task);// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。submit(Runnable task);// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。submit(Runnable task, T result)\n\n(二) ScheduledExecutorService\n方法定义和解释\n// 创建并执行在给定延迟后启用的 ScheduledFuture。schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);// 创建并执行在给定延迟后启用的一次性操作。schedule(Runnable command, long delay, TimeUnit unit);// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);\n\nschedule 方法\n\n创建并执行一个一次性任务; \n过了延迟时间就会被执行\n\n\nscheduleAtFixedRate 方法\n\n创建并执行一个周期任务; \n过了给定的初始延迟时间, 会第一次被执行; \n执行过程中发生了异常, 那么任务就停止; \n一次任务执行时长超过了周期时间, 下一次任务会等到该次任务执行结束后, 立刻执行, 这也是它和 scheduleWithFixedDelay 的重要区别\n\n\nscheduleWithFixedDelay 方法\n\n创建并执行一个周期性任务; \n过了初始延迟时间, 第一次被执行, 后续以给定的周期时间执行; \n执行过程中发生了异常, 那么任务就停止; \n一次任务执行时长超过了周期时间, 下一次任务会在该次任务执行结束的时间基础上, 计算执行延时;\n对于超过周期的长时间处理任务的不同处理方式, 这是它和scheduledFixedRate的重要区别\n\n\n\n(三) Executors 工具类你可以自己实例化线程池, 也可以用 Executors 创建线程池的工厂类, 常用方法如下: \n\nnewFixedThreadPool(int nThreads): 创建一个固定大小, 任务队列容量无界的线程池; 推荐: 核心线程数 &#x3D; 最大线程数\nnewCachedThreadPool(): 创建的是一个大小无界的缓冲线程池; 它的任务队列是一个同步队列; 任务加入到池中, 如果池中有空闲线程, 则用空闲线程执行, 如无则创建新线程执行; 池中的线程空闲超过60秒, 将被销毁释放; 线程数随任务的多少变化, 适用于执行耗时较小的异步任务; 池的核心线程数为0, 最大线程数&#x3D;Integer.MAX_VALUE\nnewSingleThreadExecutor(): 只有一个线程来执行无界任务队列的单一线程池; 该线程池确保任务被加入的顺序一个一个一次执行; 当唯一的线程因任务异常中止时, 将创建一个新的线程来继续执行后续的任务; 与 newFixedThreadPool(1)的区别在于, 单一线程池的池大小在 newSingleThreadExecutor() 中硬编码, 不能在改变的\nnewScheduledThreadPool(int corePoolSize): 能定时执行任务的线程池; 该池的核心线程数由参数指定, 最大线程数 &#x3D; Integer.MAX_VALUE\n\n三 : 线程池原理(一) 概念线程池管理器 : 用于创建并管理线程池; 包括创建线程池, 销毁线程池, 添加新任务\n工作线程 : 线程池中线程, 在没有任务时处于等待状态, 可以循环的执行任务\n任务接口 : 每个任务必须实现的接口, 以供工作线程调度任务的执行, 它主要规定了任务的入口, 任务执行完后的收尾工作, 任务的执行状态等\n任务队列 : 用于存放没有处理的任务; 提供一种缓冲机制\n(二) 执行过程首先, 是否达到核心线程数量? \n\n没达到, 创建一个工作线程来执行任务\n达到了, 进入工作队列\n\n其次, 工作队列是否已满? \n\n没满, 则将新提交的任务存储在工作队列里\n满了, 创建新的线程\n\n最后, 是否达到线程池最大数量? \n\n没达到, 则创建一个新的工作线程来执行任务\n达到了, 执行拒绝策略来处理这个任务\n\n过程梳理如图所示\n\n四 : 线程数量如何确定合适数量的线程? 要根据自己任务的类型进行判定\n\n计算型任务 : cpu 数量的1~2倍数\nIO型任务 : 相对比计算型任务, 需要多一些线程, 要根据具体的 IO 阻塞时长进行考量决定; 如 tomcat 中默认的最大线程数为: 200\n\n也可考虑根据需要在一个最小数量和最大数量间自动增减线程数\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程封闭之ThreadLocal和栈封闭","url":"/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/","content":"\n并不是所有多线程都会用到共享数据, 如果数据都是独享的, 就可以使用线程封闭技术\n\n一 : 线程封闭概念多线程访问共享可变数据时, 涉及到线程间数据同步的问题, 并不是所有时候, 都要用到共享数据, 所以线程封闭概念就提出来了\n数据都被封闭在各自的线程之中, 就不需要同步, 这种通过将数据封闭在线程中而避免使用同步的技术称为线程封闭\n线程封闭的具体实现有: ThreadLocal, 局部变量\n二 : ThreadLocalThreadLocal 是 java 里一种特殊的变量, 它是一个线程级别变量, 每个线程都有一个 ThreadLocal, 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了, 在并发模式下是绝对安全的变量\n用法: ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;(); 会自动在每一个线程上创建一个 T 的副本, 副本之间彼此独立, 互不影响; 可以用 ThreadLocal 存储一些参数, 以便在线程中多个方法中使用, 用来代替方法传参的做法; \n\n代码示例\npublic static ThreadLocal&lt;String&gt; value = new ThreadLocal&lt;&gt;();public void threadLocalTest() throws InterruptedException &#123;    value.set(&quot;123&quot;);    String v = value.get();    System.out.println(&quot;线程1执行之前,主线程取到的值: &quot; + v);    new Thread(()-&gt;&#123;        String s = value.get();        System.out.println(&quot;线程1取到的值: &quot; + s);        value.set(&quot;456&quot;);        s = value.get();        System.out.println(&quot;重新设置后,线程1取到的值: &quot; + s);    &#125;).start();    Thread.sleep(5000L);    v = value.get();    System.out.println(&quot;线程1执行之后,主线程取到的值: &quot; + v);&#125;public static void main(String[] args) throws InterruptedException &#123;    new ThreadLocalDemo().threadLocalTest();&#125;\n\n实在难以理解的, 可以理解为, jvm 维护了一个 Map&lt;Thread, T&gt;, 每个线程要用这个 T 的时候, 用当前的线程去 Map 里面取, 仅作为一个概念理解\n三 : 栈封闭局部变量的固有属性之一就是封闭在线程中\n它们位于执行线程的栈中, 其他线程无法访问这个栈\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程通信","url":"/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","content":"\n使用多线程技术往往会涉及到线程间的协同工作, 我们称为线程通信\n\n一 : 通信的方式要想实现多个线程之间的协同, 如: 线程执行先后顺序, 获取某个线程执行的结果等等\n涉及到线程之间相互通信, 分为四类:\n\n文件共享\n网络共享\n共享变量\nJDK 提供的线程协调 API (suspend&#x2F;resume, wait&#x2F;notify, park&#x2F;unpark)\n\n二 : 文件共享\n线程1在文件中写入数据, 线程2从文件中读取数据\n\n代码演示\npublic class Demo &#123;    public static void main(String[] args) &#123;        // 线程1 写入数据        new Thread(() -&gt; &#123;            try &#123;                Files.write(Paths.get(&quot;a.txt&quot;), (&quot;当前时间: &quot; + System.currentTimeMillis()).getBytes());                Thread.sleep(1000L);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 线程2 读数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    Thread.sleep(1000L);                    byte[] bytes = Files.readAllBytes(Paths.get(&quot;a.txt&quot;));                    System.out.println(new String(bytes));                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n\n三 : 变量共享\n线程-1在内存中写入数据, 线程-2从内存中读取数据\n\n代码演示\npublic class Demo &#123;    public static String content = &quot;&quot;;    public static void main(String[] args) &#123;        // 线程1 写入数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    content = &quot;当前时间: &quot; + System.currentTimeMillis();                    Thread.sleep(1000L);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 线程2 读取数据        new Thread(() -&gt; &#123;            try &#123;                while (true) &#123;                    Thread.sleep(1000L);                    System.out.println(content);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n\n四 : 线程协作-JDK APIJDK 中对于需要多线程协作完成某一任务的场景, 提供了对应API支持\n多线程协作的典型场景是 : 生产者 - 消费者模型(线程阻塞, 线程唤醒); \n\n(一) suspend&#x2F;resume 机制(弃用)\n作用: 调用 suspend 挂起目标线程, 通过 resume 可以恢复线程执行; 被弃用的主要原因是, 容易写出死锁的代码, 所以用 wait&#x2F;notify 和 park&#x2F;unpark 机制对它进行替代\npublic static Object baozi = null;/** * 买包子 =&gt; 如果没有包子 =&gt; 则进入等待 =&gt; 当生产出包子后通知消费者 */public void suspendResumeTest() throws Exception &#123;    Thread thread = new Thread(() -&gt; &#123;        if (baozi == null) &#123;            System.out.println(&quot;没有包子, 进入等待&quot;);            Thread.currentThread().suspend();        &#125;        System.out.println(&quot;买到包子&quot;);    &#125;);    thread.start();    // 3秒后通知消费者    Thread.sleep(3000L);    baozi = new Object();    thread.resume();    System.out.println(&quot;生产出包子,通知消费者&quot;);&#125;\n\nsuspend 和 resume 死锁示例\npublic static Object baozi = null;/** * suspend并不会像wait一样释放锁,很容易出现死锁代码 * 还是买包子, 但如果出现了锁竞争问题, 就会出现死锁 */public void suspendResumeDeadLockTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        if (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            synchronized (this) &#123;                Thread.currentThread().suspend();            &#125;        &#125;        System.out.println(&quot;买到包子&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒后生产包子&quot;);    synchronized (this) &#123;        thread.resume();    &#125;    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n(二) wait&#x2F;notify 机制\n这些方法只能由同一对象锁的持有者线程调用, 也就是写在同步块里面, 否则会抛出 IllegalMonitorStateException 异常\n\nwait 方法导致当前线程等待, 加入该对象的等待集合中, 并且放弃当前持有的对象锁\n\nnotify&#x2F;notifyAll 方法唤醒一个或者所有正在等待这个对象锁的线程\npublic static Object baozi = null;/** * 正常的wait/notify * 还是买包子,可以有锁竞争,因为wait会释放锁 */public void waitNotifyTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        synchronized (this) &#123;            while (baozi == null) &#123;                try &#123;                    System.out.println(&quot;没有包子,进入等待&quot;);                    this.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    synchronized (this) &#123;        this.notify();        System.out.println(&quot;有包子了,通知消费者&quot;);    &#125;&#125;\n\n注意: 虽然会 wait 自动解锁, 但是对顺序有要求, 如果在 notify 被调用之后才开始wait方法的调用, 线程会永远处于 WAITING 状态\npublic static Object baozi = null;/** * wait/notify会释放锁, 但是如果出现先notify(通知)后wait(等待) * 这是线程就会一直等待, 也可以看作是另一种形式的死锁 */public void waitNotifyWaitForeverTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            try &#123;                Thread.sleep(5000L);                synchronized (this) &#123;                    System.out.println(&quot;没有包子,进入等待&quot;);                    this.wait();                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒后,生产包子&quot;);    synchronized (this) &#123;        this.notify();        System.out.println(&quot;有包子了,通知消费者&quot;);    &#125;&#125;\n\n(三) park&#x2F;unpark 机制\n线程调用 park 则等待许可(permit), unpark 方法为指定线程提供”许可(permit)”\n\n不要求 park 和 unpark 方法的调用顺序\n\n多次调用 unpark 之后, 再调用 park , 线程会直接运行\n\n但不会叠加, 也就是说, 连续多次调用 park 方法, 第一次会拿到”许可”直接运行, 后续调用会进入等待状态\n/** * 正常的park/unPark */public void parkUnparkTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            LockSupport.park();        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    System.out.println(&quot;休眠3秒后生产包子&quot;);    baozi = new Object();    LockSupport.unpark(thread);    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n注意: 同步代码容易写出死锁代码\n/** * park/unpark虽然没有顺序要求, 但是如果不会释放锁 * 如果出现锁竞争问题,还是要考虑死锁的问题 */public void parkUnparkDeadLockTest() throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        while (baozi == null) &#123;            System.out.println(&quot;没有包子,进入等待&quot;);            synchronized (this) &#123;                LockSupport.park();            &#125;        &#125;        System.out.println(&quot;买到包子了&quot;);    &#125;);    thread.start();    Thread.sleep(3000L);    baozi = new Object();    System.out.println(&quot;休眠3秒,生产包子&quot;);    synchronized (this) &#123;        LockSupport.unpark(thread);    &#125;    System.out.println(&quot;有包子了,通知消费者&quot;);&#125;\n\n五 : 伪唤醒\n警告: 之前代码中用 if 语句来判断是否进入等待状态, 这是错误的 !\n\n官方建议应该在循环中检查等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒, 如果不在循环中检查等待条件, 程序就会在没有满足条件的情况下退出\n\n伪唤醒是指线程并非因为 notify, notifyAll, unpark 等 api 调用而唤醒, 是更底层原因导致的\n//waitsynchronized (obj) &#123;    while (&lt;条件判断&gt;)        obj.wait();    ...//执行后续操作&#125;&#125;// parkwhile (&lt;条件判断&gt;)    LockSupport.park();\t...//执行后续操作\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"内存屏障和CPU缓存","url":"/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/","content":"一 : CPU性能优化手段-缓存为了提高程序运行的性能, 现代 CPU 在很多方面对程序进行了优化; 例如 : CPU 高速缓存, 尽可能地避免处理器访问主内存的时间开销, 处理器大多会利用缓存(cache)以提高性能\nCPU &lt;===&gt; L1-L3缓存 &lt;===&gt;CPU &lt;===&gt; L1-L3缓存 &lt;===&gt; 缓存一致性协议 &lt;===&gt; 主内存CPU &lt;===&gt; L1-L3缓存 &lt;===&gt;\n\n(一) 多级缓存L1 Cache(一级缓存)是 CPU 第一层高速缓存, 分为数据缓存和指令缓存; 一般服务器 CPU 的 L1 缓存的容量通常在 32~4096KB\nL2 由于 L1 级高速缓存容量的限制, 为了再次提高CPU的运算速度, 在 CPU 外部放置一高速存储器, 即二级缓存\nL3 现在的都是内置的; 作用是: L3缓存的应用可以进一步降低内存延迟, 同时提升大数据量计算时处理器的性能; 具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度; 一般是多核共享一个 L3 缓存\n读取顺序 : CPU 在读取数据时, 现在 L1 中寻找, 再从 L2 寻找, 再从 L3 寻找, 然后是内存, 再后是外存储器\n(二) 缓存同步协议多 CPU 读取同样的数据进行缓存, 进行不同运算之后, 最终写入主内存以哪个 CPU 为准 ?\n在这种高速缓存写的场景下, 有一个缓存一致性协议(MESI 协议), 多数 CPU 厂商对它进行了实现; 它规定每条缓存有个状态位, 同时定义了下面四个状态 :\n\n修改态(Modified) : 此 cache 行已被修改过(脏行), 内容已不同于主内存, 为此 cache 专有\n专有态(Exclusive) : 此 cache 行内容同于主存, 但不出现于其他 cache 中\n共享态(Shared) : 此 cache 行内容同于主存, 但也出现于其他 cache 中\n无效态(Invalid) : 此 cache 行 内容无效(空行)\n\n多处理器时, 单个 CPU 对缓存中数据进行了改动, 需要通知给其他 CPU; 也就是意味着, CPU 处理要控制自己的读写操作, 还要监听其他 CPU 发出的通知, 从而保证最终一致\n二 : CPU性能优化手段-运行时指令重排指令重排的场景 : 当 CPU 写缓存时发现缓存区块正被其他 CPU 占用, 为了提高 CPU 处理性能, 可能将后面的读缓存命令优先执行\n\n并非随便重排, 需要遵守 as-if-serial 语义\nas-if-serial 语义的意思指: 不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变; 编译器, runtime 和处理器都必须遵守 as-if-serial 语义\n也就是说: 编译器和处理器不会对存在数据依赖关系的操作重排序\n三 : 两个问题CPU 高速缓存下有一个问题 :\n\n缓存中的数据与主内存的数据并不是实时同步的, 各 CPU (或 CPU 核心) 间缓存的数据也不是实时同步;\n在同一个时间点, 各 CPU 所看到同一内存地址的数据的值可能时不一致的\n\nCPU 执行指令重排序优化下有一个问题 :\n\n虽然遵守了 as-if-serial 语义, 但仅在单 CPU 自己执行的情况下能保证结果正确;\n多核多线程中, 指令逻辑无法分辨因果关联, 可能出现乱序执行, 导致程序运行结果错误\n\n四 : 内存屏障处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题 : \n\n写内存屏障(Store Memory Barrier): 在指令后插入 Store Barrier, 能让写入缓存中的最新数据更新写入主内存, 让其他线程可见; 强制写入主内存, 这种显示调用, CPU 就不会因为性能考虑而去对指令重排\n读内存屏障(Load Memory Barrier): 在指令前插入 Load Barrier, 可以让高速缓存中的数据失效, 强制重新从主内存加载数据; 强制读取主内存内容, 让 CPU 缓存与主内存保持一致, 避免了缓存导致的一致性问题\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程终止","url":"/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/","content":"\n如果需要终止正在运行的线程, 我们希望数据可以保持准确性\n\n一 : stop(不建议)\nstop : 中止线程, 并且清除监控器锁的信息, 但是可能导致线程安全问题, JDK 不建议用\n\ndestroy : JDK 未实现该方法\n\n代码演示\npublic class Demo &#123;    public static void main(String[] args) throws InterruptedException &#123;        StopThread thread = new StopThread();        thread.start();        // 休眠1秒，确保i变量自增成功        Thread.sleep(1000);        // 暂停线程        thread.stop(); // 错误的终止        while (thread.isAlive()) &#123;            // 确保线程已经终止        &#125;         // 输出结果        thread.print();    &#125;&#125;class StopThread extends Thread &#123;    private int i = 0, j = 0;    @Override    public void run() &#123;        synchronized (this) &#123;            // 增加同步锁，确保线程安全            ++i;            try &#123;                // 休眠10秒,模拟耗时操作                Thread.sleep(10000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            ++j;        &#125;    &#125;    /**     * 打印i和j     */    public void print() &#123;        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);    &#125;&#125;\n\n二 : interrupt(推荐)\n如果目标线程在调用 Object class 的 wait(), wait(long) 或 wait(long, int) 方法, join(), join(long, int) 或者 sleep(long, int) 方法时被阻塞, 那么 interrupt 会生效, 该线程的中断状态将被清除, 抛出 InterruptedException 异常\n\n如果目标线程是被 I&#x2F;O 或者 NIO 中的 Channel 所阻塞, 同样, I&#x2F;O 操作会被中断或者返回特殊异常值; 达到终止线程的目的\n\n如果以上条件都不满足, 则会设置此线程的终端状态\n\n代码示例, 修改之前的代码 : \n// thread.stop(); // 错误的终止thread.interrupt(); // 正确终止\n\n将 stop 改成 interrupt 后, 最终输出为 i=1 j=1, 数据一致\n\n\n三 : 标志位(推荐)\n代码逻辑中, 增加一个判断, 用来控制线程执行的中止\n\n代码示例\n/** 通过状态位来判断 */public class Demo extends Thread &#123;        public volatile static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            try &#123;                while (flag) &#123; // 判断是否运行                    System.out.println(&quot;运行中&quot;);                    Thread.sleep(1000L);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 3秒之后，将状态标志改为False，代表不继续运行        Thread.sleep(3000L);        flag = false;        System.out.println(&quot;程序运行结束&quot;);    &#125;&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程状态","url":"/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","content":"\n线程的6种状态及状态切换\n\n一 : 状态定义定义位置 : java.lang.Thread.State\n线程状态 : 新建, 可运行, 阻塞, 等待, 超时等待, 终止\n\nNew : 尚未启动的线程的线程状态\nRunnable : 可运行线程的线程状态, 等待CPU调度\nBlocked : 线程阻塞, 等待监视器锁定的线程状态; 处于 synchronized 同步代码块或方法中被阻塞\nWaiting : 等待线程的线程状态; 不带超时的方式(Object.wait, Thread.join, LockSupport.park)\nTime Waiting : 具有指定等待时间的等待线程的线程状态; 带超时的方式(Thread.sleep, Object.wait, Thread.join, LockSupport.parkNanos, LockSupport.parkUntil)\nTerminated : 终止线程的线程状态; 线程正常完成执行或者出现异常\n\n二 : 线程状态切换\n这 6 种状态在一定条件下会发生转换\n\n\nNew 新线程通过调用 start 进入 Runnable 可运行状态\nRunnable 可运行状态在等待锁的时候会进入 Blocked 阻塞状态; 一旦拿到锁, 便会从 Blocked 阻塞状态进入 Runnable 可运行状态\nRunnable 可运行状态在等待其他线程的通知时会进入 Waiting 等待状态; 一旦收到通知,继续执行时, 便会从 Waiting 等待状态进入 Runnable 可运行状态\nRunnable 可运行状态在有超时时间的等待其他线程的通知时会进入 Time Waiting 定时等待状态; 一旦等待超时或者收到通知, 继续执行时则会进入 Runnable 状态\nRunnable 可运行状态在线程执行结束时会成为 Terminated 终止状态\n\n\n\n三 : 代码演示\nNew &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    // 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread1 = new Thread(() -&gt; &#123;        System.out.println(&quot;thread1当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread1 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法,thread1当前状态: &quot; + thread1.getState().toString());    thread1.start();    Thread.sleep(2000L); // 等待thread1执行结束，再看状态    System.out.println(&quot;等待两秒,再看thread1当前状态: &quot; + thread1.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Timed Waiting &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)    System.out.println(&quot;### 第二种: 新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式) ###&quot;);    Thread thread2 = new Thread(() -&gt; &#123;        try &#123;            // 进入超时等待, 时间1.5s            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;thread2当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread2 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    thread2.start();    System.out.println(&quot;调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(200L); // 等待200毫秒，再看状态    System.out.println(&quot;等待200毫秒，再看thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态    System.out.println(&quot;等待3秒，再看thread2当前状态: &quot; + thread2.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Blocked &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread3 = new Thread(()-&gt; &#123;        synchronized (Demo.class) &#123;            System.out.println(&quot;thread3当前状态: &quot; + Thread.currentThread().getState().toString());            System.out.println(&quot;thread3 执行了&quot;);        &#125;    &#125;);    synchronized (Demo.class) &#123;        System.out.println(&quot;没调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        thread3.start();        System.out.println(&quot;调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        Thread.sleep(200L); // 等待200毫秒，再看状态        System.out.println(&quot;等待200毫秒，再看thread3当前状态: &quot; + thread3.getState().toString());    &#125;    Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态    System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态: &quot; + thread3.getState().toString());&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"Java程序运行堆栈分析","url":"/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/","content":"\njava 代码写起来很简单, 但具体是怎么运行的呢?\n\n一 : 概述jvm 运行时数据区大致可以分为两部分 : 线程共享部分和线程独占部分\n\n\n线程共享 : 所有线程能访问这块内存数据, 随虚拟机或者 GC 而创建和销毁; 方法区和堆内存皆属此列\n线程独占 : 每个线程都会有它的独立的空间, 随线程生命周期而创建和销毁; 虚拟机栈, 本地方法栈和程序计数器属于线程独占\n二 : JVM运行时数据区(一) 方法区jvm 启动时创建, 用来存储加载类信息, 常量, 静态变量, 编译后的代码等数据; \n\n虚拟机规范中这是一个逻辑区划, 具体实现根据不同虚拟机来实现; 例如: \n\noracle 的 HotSpot 在 java7 中方法区放在永久代; \njava8 放在元数据空间 (metaspace), 并且通过 GC 机制对这个区域进行管理。\n\n(二) 堆内存jvm 启动时创建, 存放对象的实例; 垃圾回收器主要就是管理堆内存; \n\n如果满了, 就会出现 OutOfMemroyError; \n堆内存还可以细分为 : 新生代(Eden, From Survivor(s0) 和 To Survivor(s1))和老年代 (Old)\n(三) 虚拟机栈随线程的生命周期创建和销毁, 每个线程都在在这个空间有一个私有的空间, 这个空间称为线程栈; \n\n线程栈由多个栈帧 (Stack Frame) 组成; 栈帧内容包含 : 局部变量表, 操作数栈, 动态链接, 方法返回地址和附加信息等; \n一个线程会执行一个或多个方法, 一个方法对应一个栈帧; \n栈内存默认最大是 1M, 超出则抛出 StackOverflowError\n(四) 本地方法栈和虚拟机栈功能类似, 虚拟机栈是为虚拟机执行java方法而准备的, 本地方法栈是为虚拟机使用 Native 本地方法而准备的;\n\n虚拟机规范没有规定具体的实现, 由不同的虚拟机厂商去实现;\nHotSpot 虚拟机中虚拟机栈和本地方法栈的实现是一样的; 同样, 超出大小以后也会抛出 StackOverflowError\n(五) 程序计数器程序计数器 (Program Counter Register) 记录当前线程执行字节码的位置, 存储的是字节码指令地址, \n\n如果执行Native方法, 则计数器值为空;\n每个线程都在这个空间有一个私有的空间, 占用内存空间很少;\nCPU 同一时间, 只会执行一条线程中的指令; jvm 多线程会轮流切换并分配 CPU 执行时间; 线程切换后, 需要通过程序计数器, 来恢复正确的执行位置\n三 : class文件内容(一) 概述class 文件包含 java 程序执行的字节码; 数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符; 文件开头有一个ca fe ba be (16进制)特殊的一个标志; \n\n这个文件具有复杂且严格的格式, 专门给 jvm 读取其中的内容, 人类可以借助工具查看; 其中包含 : 版本信息, 访问标志, 常量池, 当前类, 超级类, 接口, 字段, 方法, 属性等信息\n(二) 内容分析\n示例代码\npublic class Demo &#123;    public static void main(String[] args) &#123;        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a + b);    &#125;&#125;\n\n反编译 class 文件并重定向到 txt\n# 编译命令$ javac Demo.java# 反编译将其写入txt文件$ javap -v Demo.class &gt; Demo.txt\n\n版本号&#x2F;访问控制, 版本号规则 : JDK5,6,7,8 分别对应 49,50,51,52\npublic class Demo  minor version: 0 //次版本号  major version: 52 //主版本号  flags: ACC_PUBLIC, ACC_SUPER //访问标志\n\n常量池\nConstant pool:   #1 = Methodref          #5.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V   #4 = Class              #19            // Demo1   #5 = Class              #20            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               main  #11 = Utf8               ([Ljava/lang/String;)V  #12 = Utf8               SourceFile  #13 = Utf8               Demo1.java  #14 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #15 = Class              #21            // java/lang/System  #16 = NameAndType        #22:#23        // out:Ljava/io/PrintStream;  #17 = Class              #24            // java/io/PrintStream  #18 = NameAndType        #25:#26        // println:(I)V  #19 = Utf8               Demo1  #20 = Utf8               java/lang/Object  #21 = Utf8               java/lang/System  #22 = Utf8               out  #23 = Utf8               Ljava/io/PrintStream;  #24 = Utf8               java/io/PrintStream  #25 = Utf8               println  #26 = Utf8               (I)V\n\n构造方法 : 示例中并没有写构造函数, 由此可见, 没有定义构造函数时, 会有隐式的无参构造函数\npublic Demo();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=1, locals=1, args_size=1      0: aload_0      1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      4: return    LineNumberTable:      line 1: 0\n\n程序入口 main 方法 : stack(操作数栈), locals(为本地变量表)\npublic static void main(java.lang.String[]);  descriptor: ([Ljava/lang/String;)V  flags: ACC_PUBLIC, ACC_STATIC\t//访问控制  Code:    stack=3, locals=5, args_size=1      /**       * jvm执行引擎去执行这些源码编译过后的指令码       * javap编译出来是操作符,class文件内存的是指令码       * 前面的数字,是偏移量(字节),jvm根据这个去区分不同的指令(查看jvm指令码表)       */       0: sipush        500       3: istore_1       4: bipush        100       6: istore_2       7: iload_1       8: iload_2       9: idiv      10: istore_3      11: bipush        50      13: istore        4      15: getstatic     #2        // Field java/lang/System.out:Ljava/io/PrintStream;      18: iload_3      19: iload         4      21: iadd      22: invokevirtual #3        // Method java/io/PrintStream.println:(I)V      25: return    LineNumberTable:      line 3: 0      line 4: 4      line 5: 7      line 6: 11      line 7: 15      line 8: 25\n\n四 : 程序完整运行分析(一) 加载信息到方法区此时属于线程共享部分的方法区会存在大量的类信息, 同时还存在运行时常量池字符串常量。\nHotSpot 虚拟机 : 1.7及之前称为永久代, 1.8开始称为元数据空间。\n(二) jvm 创建线程来执行代码在虚拟机栈, 程序计数器内存区域中创建线程独占的空间。\n虚拟机栈中存放Thread栈帧, 程序计数器中存放Thread执行位置(字节码指令地址)。\n(三) 方法区程序入口\nmain 方法栈帧初始化 : 5个本地变量, 变量0是方法参数 args\n\n\n\n(四) 程序执行过程\n将500压入操作数栈\n\n\n弹出操作数栈栈顶500保存到本地变量表1\n\n\n将100压入操作数栈\n\n\n弹出操作数栈栈顶100保存到本地变量表2\n\n\n读取本地变量1压入操作数栈\n\n\n读取本地变量2压入操作数栈\n\n\n将栈顶两int类型数相除, 结果入栈 500&#x2F;100&#x3D;5\n\n\n将栈顶int类型值保存到局部变量3中\n\n\n将50压入操作数栈\n\n\n将栈顶int类型值保存到局部变量4中\n\n\n获取类或接口字段的值并将其压入操作数栈\n\n\n将本地变量3取出压入操作数栈\n\n\n将本地变量4取出压入操作数栈\n\n\n将栈顶两int类型数相加, 结果入栈\n\n\n调用静态方法; jvm会根据这个方法的描述,创建新栈帧, 方法的参数从操作数栈中弹出来,压入虚拟机栈, 然后虚拟机会开始执行虚拟机栈最上面的栈帧; 执行完毕后,再继续执行main方法对应的栈帧\n\n\nvoid函数返回, main方法执行结束\n\n\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"博客图床","url":"/2019/12/25/blog-images/","content":"\n要写博客, 免不了要图文结合, 图片怎么办 ?\n\n一 : typora\n下载地址 : https://download2.typoraio.cn/windows/typora-setup-x64.exe\n傻瓜式安装即可\n\n二 : github\n创建一个公开仓库 : blog_images\n在 settings &#x3D;&gt; Developer settings &#x3D;&gt; Personal access tokens 里生成一个 token\n\n三 : picgo\n文件 &#x3D;&gt; 偏好设置 &#x3D;&gt; 图像, 做如下修改\n\n\n点击下载或更新, 下载 PicGo-Core(command-line)\n\n下载完毕后, 点击打开配置文件, 或者手动打开 C:/Users/&#123;用户名&#125;/.picgo/config.json, 参考下面文件进行配置\n&#123;    &quot;picBed&quot;: &#123;\t\t&quot;current&quot;: &quot;github&quot;,        &quot;github&quot;: &#123;            &quot;repo&quot;: &quot;info4z/blog_images&quot;,            &quot;branch&quot;: &quot;main&quot;,            &quot;token&quot;:&quot;刚刚生成的 Personal access tokens&quot;,              &quot;path&quot;: &quot;images&quot;,            &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/info4z/blog_images@main&quot;        &#125;    &#125;,    &quot;picgoPlugins&quot;: &#123;&#125;&#125;\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客美化","url":"/2019/12/24/blog-theme/","content":"\nhexo 提供了博客的骨架, 通过 kaze 使其丰满起来吧\n\n一 : 主题\n博客搭建完毕后, 可以对其进行一定的美化, 可以使用 kaze 主题\n$ git clone git@github.com:theme-kaze/hexo-theme-kaze.git themes/kaze\n\n二 : 站点配置\n编辑博客根目录下的 _config.yml\n# Sitetitle: 冰清阁\t\t#标题subtitle: &#x27;&#x27;description: &#x27;差不多得了, 玩什么命呀...&#x27;\t#简介或者格言keywords:author: 清月明风\t\t#作者language: zh-CN\t\t#主题语言,查看themes\\next\\languages下面的具体名字timezone: Asia/Shanghai\t\t#中国的时区# URLurl: https://info4z.github.io# 代码高亮highlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: trueprismjs:  enable: false# Extensionstheme: kaze\n\n三 : 主题配置\n修改 kaze下的 _config.yml\n# Header configtitle: 冰清阁author: 清月明风logo_img: https://img.songhn.com/img/Y67gdd.pngauthor_img: https://img.songhn.com/img/Y67gdd.pngauthor_description: 差不多得了, 玩什么命呀...\n\n目录\n# Navbar configmenus:  home: /  tags: /tags  categories: /categories  archive: /archives  about: /about  friends: /friends\n\n当然了, 有些目录是不存在的, 需要手动创建\n$ hexo new page tags$ hexo new page categories$ hexo new page about$ hexo new page friends\n\n搜索\nsearch:  enable: true  path: search.json  field: posts  searchContent: true\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客搭建","url":"/2019/12/24/blog-hexo/","content":"\n基于 hexo 在 github 上搭建属于自己的博客\n\n一 : nodejs\n官网 : https://nodejs.org/zh-cn/\n\n下载地址 : https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi (长期维护版即可)\n\n安装完成后 : \n# 查看node版本$ node -v\n\n二 : npm\nnode.js 自带 npm\n# 查看npm版本$ npm -v\n\nnpm 有时候不是特别好用, 可以使用 cnpm\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n安装过程中可能会出现无法加载文件的问题, 解决方案如下\n# 以管理员身份运行powerShellPS D:\\Blog&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS D:\\fore\\jshERP-web&gt; get-ExecutionPolicyRemoteSigned\n\n查看版本信息\n$ cnpm -v\n\n三 : hexo\n使用 npm 安装 hexo\n# npm和cnpm哪个好使用哪个$ cnpm install -g hexo-cli\n\n初始化\n# init : Create a new Hexo folder$ hexo init\n\n生成工具栏\n$ hexo new page tags \t\t# 新增标签$ hexo new page categories\t# 新增分类\n\n新写文章\n# 这里$ hexo new &quot;文章题目&quot;\n\n本地启动\n$ hexo server$ hexo s\n\n生成静态文件\n$ hexo generate$ hexo g\n\n四 : github\n创建仓库, 这里只需要注意 repository name 的值为 :  用户名.github.io\n\n通过 Settings 查看 Pages\nYour site is live at https://info4z.github.io/\t\t# 这就是个人博客的地址\n\n编辑 _config.yml\ndeploy:  type: git  repository: git@github.com:info4z/info4z.github.io.git \t# 用ssh连接  branch: main\n\n安装 git 部署插件\n$ cnpm install hexo-deployer-git --save\n\n执行如下指令\n# 清除缓存文件db.json和已生成的静态文件public$ hexo clean   # 生成网站静态文件到默认设置的public文件夹(generate)$ hexo g# 自动生成网站静态文件,并部署到设定的仓库(deploy)$ hexo d\n\n","categories":["博客搭建"],"tags":[]},{"title":"Hello World","url":"/2019/12/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["博客搭建"],"tags":[]}]