[{"title":"Arthas","url":"/2023/01/13/arthas/","content":"\njava 诊断工具, 用于生产环境调错\n\n一 : 概述(一) 概述Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。\n(二) 背景通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 IDE 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。\n开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。\n如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 JVM 重新启动，它可能无法复现，如上文所述。\nArthas 旨在解决这些问题。开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。\n(三) 用途Arthas 是 Alibaba 开源的 Java 诊断工具。当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：\n\n这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？\n我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n是否有一个全局视角来查看系统的运行状况？\n有什么办法可以监控到 JVM 的实时运行状态？\n怎么快速定位应用的热点，生成火焰图？\n怎样直接从 JVM 内查找某个类的实例？\n\n二 : 快速入门(一) 下载启动\n下载 jar 包\n$ curl -O https://arthas.aliyun.com/arthas-boot.jar\n\n启动\n# 执行该程序的用户需要和目标进程具有相同的权限$ java -jar arthas-boot.jar# 可以执行如下命令来查看帮助$ java -jar arthas-boot.jar -h\n\n选择应用 : 数据对应程序的编号, 然后回车即可\n\n未进入指定程序退出 : ctrl + c\n\n进入指定程序后退出 : ctrl + d\n\n\n(二) 常用操作\ndashboard : 选择指定程序后, 输入 dashboard 后回车, 即可进入看板, 按 ctrl+c 可以中断执行\n$ dashboard\n\n\n主要涉及到当前执行的线程, 内存情况和运行环境\n\n\nthread : 查看当前线程, 命令 : thread ID\n$ thread 1 | grep &#x27;main(&#x27;    at demo.MathGame.main(MathGame.java:17)\n\njad : 反编译工具, 通过 jad 来反编译 Main Class\n$ jad demo.MathGame\n\nwatch : 查看具体函数的参数和返回值\n$ watch demo.MathGame primeFactors returnObj\n\n(三) 退出\n如果只是退出当前的连接，可以用quit或者exit命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。\n如果想完全退出 arthas，可以执行stop命令。\n\n","categories":["服务器"],"tags":["监控","诊断"]},{"title":"mysql数据统计","url":"/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/","content":"\n统计数据占用磁盘空间的大小\n\n一 : 库表结构\nMySQL 的 information_schema 数据库, 保存着数据库的容量和使用信息, 可查询数据库中每个表占用的空间, 表记录的行数\n\nTABLES 表结构\nCREATE TEMPORARY TABLE `TABLES` (  `TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_NAME` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `TABLE_TYPE` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,  `ENGINE` varchar(64) DEFAULT NULL,  `VERSION` bigint(21) unsigned DEFAULT NULL,  `ROW_FORMAT` varchar(10) DEFAULT NULL,  `TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,  `AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,  `INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,  `DATA_FREE` bigint(21) unsigned DEFAULT NULL,  `AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,  `CREATE_TIME` datetime DEFAULT NULL,  `UPDATE_TIME` datetime DEFAULT NULL,  `CHECK_TIME` datetime DEFAULT NULL,  `TABLE_COLLATION` varchar(32) DEFAULT NULL,  `CHECKSUM` bigint(21) unsigned DEFAULT NULL,  `CREATE_OPTIONS` varchar(255) DEFAULT NULL,  `TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &#x27;&#x27;) ENGINE=MEMORY DEFAULT CHARSET=utf8\n\n重点字段说明\n\n\n\n字段\n解释\n\n\n\nTABLE_SCHEMA\n数据库名\n\n\nTABLE_NAME\n表名\n\n\nENGINE\n存储引擎\n\n\nTABLE_ROWS\n记录数\n\n\nDATA_LENGTH\n数据大小(单位B)\n\n\nINDEX_LENGTH\n索引大小\n\n\n\n\n二 : 查询示例(一) 数据总占用量\n求和 &#x3D;&gt; 单位转换 &#x3D;&gt; 加单位\nselect \tconcat(round(sum(DATA_LENGTH/1024/1024/1024),2),&#x27;GB&#x27;) as data from information_schema.TABLES\n\n(二) 每个表占用量\ntable_name, table_rows, data_length\nselect \ttable_name, \tconcat(round(sum(data_length/1024/1024/1024),2),&#x27;G&#x27;) as data from information_schema.tables where table_schema=&#x27;dbname&#x27; group by table_name order by data desc;\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"内存占用过高","url":"/2020/03/06/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/","content":"\n服务器内存占用过高, 缓存不释放导致死机,  重启后持续几天再次占满\n\n一 : 故障现象\n服务器内存占用过高, 导致死机\n服务器硬重启 3-5 天再次占满\n\n二 : 问题排查\ncpu 使用率 : top\n定时任务 crontab -l\n文件的读取和写入 : ftp, log\n\n三 : 解决方案(一) 手动清理\n可手动清理页文件缓存\necho 1 &gt; /proc/sys/vm/drop_caches\n\n(二) 设置最低剩余内存\n修改 sysctl.conf 配置文件\nvim /etc/sysctl.conf# 最后加入一行vm.min_free_kbytes = 2097152\n\n使配置文件生效\n$ sudo sysctl -p\n\n第一种方法直接清空缓存, 可能会造成数据丢失, 我们选用第二种\n\n\n","categories":["服务器"],"tags":["内存"]},{"title":"线程池应用及实现原理剖析","url":"/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90(7)/","content":"一 : 为什么要用线程池二 : 线程池原理三 : 线程数量","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程封闭之ThreadLocal和栈封闭","url":"/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD(6)/","content":"一 : 线程封闭概念二 : ThreadLocal三 : 栈封闭","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程通信","url":"/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1(5)/","content":"一 : 通信的方式二 : 文件共享三 : 变量共享四 : 线程协作-JDK API五 : 伪唤醒","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"内存屏障和CPU缓存","url":"/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/","content":"一 : CPU性能优化手段-缓存为了提高程序运行的性能, 现代 CPU 在很多方面对程序进行了优化; 例如 : CPU 高速缓存, 尽可能地避免处理器访问主内存的时间开销, 处理器大多会利用缓存(cache)以提高性能\nCPU &lt;===&gt; L1-L3缓存 &lt;===&gt;CPU &lt;===&gt; L1-L3缓存 &lt;===&gt; 缓存一致性协议 &lt;===&gt; 主内存CPU &lt;===&gt; L1-L3缓存 &lt;===&gt;\n\n(一) 多级缓存L1 Cache(一级缓存)是 CPU 第一层高速缓存, 分为数据缓存和指令缓存; 一般服务器 CPU 的 L1 缓存的容量通常在 32~4096KB\nL2 由于 L1 级高速缓存容量的限制, 为了再次提高CPU的运算速度, 在 CPU 外部放置一高速存储器, 即二级缓存\nL3 现在的都是内置的; 作用是: L3缓存的应用可以进一步降低内存延迟, 同时提升大数据量计算时处理器的性能; 具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度; 一般是多核共享一个 L3 缓存\n读取顺序 : CPU 在读取数据时, 现在 L1 中寻找, 再从 L2 寻找, 再从 L3 寻找, 然后是内存, 再后是外存储器\n(二) 缓存同步协议多 CPU 读取同样的数据进行缓存, 进行不同运算之后, 最终写入主内存以哪个 CPU 为准 ?\n在这种高速缓存写的场景下, 有一个缓存一致性协议(MESI 协议), 多数 CPU 厂商对它进行了实现; 它规定每条缓存有个状态位, 同时定义了下面四个状态 :\n\n修改态(Modified) : 此 cache 行已被修改过(脏行), 内容已不同于主内存, 为此 cache 专有\n专有态(Exclusive) : 此 cache 行内容同于主存, 但不出现于其他 cache 中\n共享态(Shared) : 此 cache 行内容同于主存, 但也出现于其他 cache 中\n无效态(Invalid) : 此 cache 行 内容无效(空行)\n\n多处理器时, 单个 CPU 对缓存中数据进行了改动, 需要通知给其他 CPU; 也就是意味着, CPU 处理要控制自己的读写操作, 还要监听其他 CPU 发出的通知, 从而保证最终一致\n二 : CPU性能优化手段-运行时指令重排指令重排的场景 : 当 CPU 写缓存时发现缓存区块正被其他 CPU 占用, 为了提高 CPU 处理性能, 可能将后面的读缓存命令优先执行\n\n并非随便重排, 需要遵守 as-if-serial 语义\nas-if-serial 语义的意思指: 不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变; 编译器, runtime 和处理器都必须遵守 as-if-serial 语义\n也就是说: 编译器和处理器不会对存在数据依赖关系的操作重排序\n三 : 两个问题CPU 高速缓存下有一个问题 :\n\n缓存中的数据与主内存的数据并不是实时同步的, 各 CPU (或 CPU 核心) 间缓存的数据也不是实时同步;\n在同一个时间点, 各 CPU 所看到同一内存地址的数据的值可能时不一致的\n\nCPU 执行指令重排序优化下有一个问题 :\n\n虽然遵守了 as-if-serial 语义, 但仅在单 CPU 自己执行的情况下能保证结果正确;\n多核多线程中, 指令逻辑无法分辨因果关联, 可能出现乱序执行, 导致程序运行结果错误\n\n四 : 内存屏障处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题 : \n\n写内存屏障(Store Memory Barrier): 在指令后插入 Store Barrier, 能让写入缓存中的最新数据更新写入主内存, 让其他线程可见; 强制写入主内存, 这种显示调用, CPU 就不会因为性能考虑而去对指令重排\n读内存屏障(Load Memory Barrier): 在指令前插入 Load Barrier, 可以让高速缓存中的数据失效, 强制重新从主内存加载数据; 强制读取主内存内容, 让 CPU 缓存与主内存保持一致, 避免了缓存导致的一致性问题\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程终止","url":"/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/","content":"\n如果需要终止正在运行的线程, 我们希望数据可以保持准确性\n\n一 : stop(不建议)\nstop : 中止线程, 并且清除监控器锁的信息, 但是可能导致线程安全问题, JDK 不建议用\n\ndestroy : JDK 未实现该方法\n\n代码演示\npublic class Demo &#123;    public static void main(String[] args) throws InterruptedException &#123;        StopThread thread = new StopThread();        thread.start();        // 休眠1秒，确保i变量自增成功        Thread.sleep(1000);        // 暂停线程        thread.stop(); // 错误的终止        while (thread.isAlive()) &#123;            // 确保线程已经终止        &#125;         // 输出结果        thread.print();    &#125;&#125;class StopThread extends Thread &#123;    private int i = 0, j = 0;    @Override    public void run() &#123;        synchronized (this) &#123;            // 增加同步锁，确保线程安全            ++i;            try &#123;                // 休眠10秒,模拟耗时操作                Thread.sleep(10000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            ++j;        &#125;    &#125;    /**     * 打印i和j     */    public void print() &#123;        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);    &#125;&#125;\n\n二 : interrupt(推荐)\n如果目标线程在调用 Object class 的 wait(), wait(long) 或 wait(long, int) 方法, join(), join(long, int) 或者 sleep(long, int) 方法时被阻塞, 那么 interrupt 会生效, 该线程的中断状态将被清除, 抛出 InterruptedException 异常\n\n如果目标线程是被 I&#x2F;O 或者 NIO 中的 Channel 所阻塞, 同样, I&#x2F;O 操作会被中断或者返回特殊异常值; 达到终止线程的目的\n\n如果以上条件都不满足, 则会设置此线程的终端状态\n\n代码示例, 修改之前的代码 : \n// thread.stop(); // 错误的终止thread.interrupt(); // 正确终止\n\n将 stop 改成 interrupt 后, 最终输出为 i=1 j=1, 数据一致\n\n\n三 : 标志位(推荐)\n代码逻辑中, 增加一个判断, 用来控制线程执行的中止\n\n代码示例\n/** 通过状态位来判断 */public class Demo extends Thread &#123;        public volatile static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            try &#123;                while (flag) &#123; // 判断是否运行                    System.out.println(&quot;运行中&quot;);                    Thread.sleep(1000L);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        // 3秒之后，将状态标志改为False，代表不继续运行        Thread.sleep(3000L);        flag = false;        System.out.println(&quot;程序运行结束&quot;);    &#125;&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"线程状态","url":"/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","content":"\n线程的6种状态及状态切换\n\n一 : 状态定义定义位置 : java.lang.Thread.State\n线程状态 : 新建, 可运行, 阻塞, 等待, 超时等待, 终止\n\nNew : 尚未启动的线程的线程状态\nRunnable : 可运行线程的线程状态, 等待CPU调度\nBlocked : 线程阻塞, 等待监视器锁定的线程状态; 处于 synchronized 同步代码块或方法中被阻塞\nWaiting : 等待线程的线程状态; 不带超时的方式(Object.wait, Thread.join, LockSupport.park)\nTime Waiting : 具有指定等待时间的等待线程的线程状态; 带超时的方式(Thread.sleep, Object.wait, Thread.join, LockSupport.parkNanos, LockSupport.parkUntil)\nTerminated : 终止线程的线程状态; 线程正常完成执行或者出现异常\n\n二 : 线程状态切换\n这 6 种状态在一定条件下会发生转换\n\n\nNew 新线程通过调用 start 进入 Runnable 可运行状态\nRunnable 可运行状态在等待锁的时候会进入 Blocked 阻塞状态; 一旦拿到锁, 便会从 Blocked 阻塞状态进入 Runnable 可运行状态\nRunnable 可运行状态在等待其他线程的通知时会进入 Waiting 等待状态; 一旦收到通知,继续执行时, 便会从 Waiting 等待状态进入 Runnable 可运行状态\nRunnable 可运行状态在有超时时间的等待其他线程的通知时会进入 Time Waiting 定时等待状态; 一旦等待超时或者收到通知, 继续执行时则会进入 Runnable 状态\nRunnable 可运行状态在线程执行结束时会成为 Terminated 终止状态\n\n\n\n三 : 代码演示\nNew &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    // 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread1 = new Thread(() -&gt; &#123;        System.out.println(&quot;thread1当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread1 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法,thread1当前状态: &quot; + thread1.getState().toString());    thread1.start();    Thread.sleep(2000L); // 等待thread1执行结束，再看状态    System.out.println(&quot;等待两秒,再看thread1当前状态: &quot; + thread1.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Timed Waiting &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)    System.out.println(&quot;### 第二种: 新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式) ###&quot;);    Thread thread2 = new Thread(() -&gt; &#123;        try &#123;            // 进入超时等待, 时间1.5s            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;thread2当前状态: &quot; + Thread.currentThread().getState().toString());        System.out.println(&quot;thread2 执行了&quot;);    &#125;);    System.out.println(&quot;没调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    thread2.start();    System.out.println(&quot;调用start方法，thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(200L); // 等待200毫秒，再看状态    System.out.println(&quot;等待200毫秒，再看thread2当前状态: &quot; + thread2.getState().toString());    Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态    System.out.println(&quot;等待3秒，再看thread2当前状态: &quot; + thread2.getState().toString());&#125;\n\nnew &#x3D;&gt; Runnable &#x3D;&gt; Blocked &#x3D;&gt; Runnable &#x3D;&gt; Terminated\npublic static void main(String[] args) throws InterruptedException &#123;    //第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止    System.out.println(&quot;### 第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止 ###&quot;);    Thread thread3 = new Thread(()-&gt; &#123;        synchronized (Demo.class) &#123;            System.out.println(&quot;thread3当前状态: &quot; + Thread.currentThread().getState().toString());            System.out.println(&quot;thread3 执行了&quot;);        &#125;    &#125;);    synchronized (Demo.class) &#123;        System.out.println(&quot;没调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        thread3.start();        System.out.println(&quot;调用start方法，thread3当前状态: &quot; + thread3.getState().toString());        Thread.sleep(200L); // 等待200毫秒，再看状态        System.out.println(&quot;等待200毫秒，再看thread3当前状态: &quot; + thread3.getState().toString());    &#125;    Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态    System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态: &quot; + thread3.getState().toString());&#125;\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"Java程序运行堆栈分析","url":"/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/","content":"\njava 代码写起来很简单, 但具体是怎么运行的呢?\n\n一 : 概述jvm 运行时数据区大致可以分为两部分 : 线程共享部分和线程独占部分\n\n\n线程共享 : 所有线程能访问这块内存数据, 随虚拟机或者 GC 而创建和销毁; 方法区和堆内存皆属此列\n线程独占 : 每个线程都会有它的独立的空间, 随线程生命周期而创建和销毁; 虚拟机栈, 本地方法栈和程序计数器属于线程独占\n二 : JVM运行时数据区(一) 方法区jvm 启动时创建, 用来存储加载类信息, 常量, 静态变量, 编译后的代码等数据; \n\n虚拟机规范中这是一个逻辑区划, 具体实现根据不同虚拟机来实现; 例如: \n\noracle 的 HotSpot 在 java7 中方法区放在永久代; \njava8 放在元数据空间 (metaspace), 并且通过 GC 机制对这个区域进行管理。\n\n(二) 堆内存jvm 启动时创建, 存放对象的实例; 垃圾回收器主要就是管理堆内存; \n\n如果满了, 就会出现 OutOfMemroyError; \n堆内存还可以细分为 : 新生代(Eden, From Survivor(s0) 和 To Survivor(s1))和老年代 (Old)\n(三) 虚拟机栈随线程的生命周期创建和销毁, 每个线程都在在这个空间有一个私有的空间, 这个空间称为线程栈; \n\n线程栈由多个栈帧 (Stack Frame) 组成; 栈帧内容包含 : 局部变量表, 操作数栈, 动态链接, 方法返回地址和附加信息等; \n一个线程会执行一个或多个方法, 一个方法对应一个栈帧; \n栈内存默认最大是 1M, 超出则抛出 StackOverflowError\n(四) 本地方法栈和虚拟机栈功能类似, 虚拟机栈是为虚拟机执行java方法而准备的, 本地方法栈是为虚拟机使用 Native 本地方法而准备的;\n\n虚拟机规范没有规定具体的实现, 由不同的虚拟机厂商去实现;\nHotSpot 虚拟机中虚拟机栈和本地方法栈的实现是一样的; 同样, 超出大小以后也会抛出 StackOverflowError\n(五) 程序计数器程序计数器 (Program Counter Register) 记录当前线程执行字节码的位置, 存储的是字节码指令地址, \n\n如果执行Native方法, 则计数器值为空;\n每个线程都在这个空间有一个私有的空间, 占用内存空间很少;\nCPU 同一时间, 只会执行一条线程中的指令; jvm 多线程会轮流切换并分配 CPU 执行时间; 线程切换后, 需要通过程序计数器, 来恢复正确的执行位置\n三 : class文件内容(一) 概述class 文件包含 java 程序执行的字节码; 数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符; 文件开头有一个ca fe ba be (16进制)特殊的一个标志; \n\n这个文件具有复杂且严格的格式, 专门给 jvm 读取其中的内容, 人类可以借助工具查看; 其中包含 : 版本信息, 访问标志, 常量池, 当前类, 超级类, 接口, 字段, 方法, 属性等信息\n(二) 内容分析\n示例代码\npublic class Demo &#123;    public static void main(String[] args) &#123;        int x = 500;        int y = 100;        int a = x / y;        int b = 50;        System.out.println(a + b);    &#125;&#125;\n\n反编译 class 文件并重定向到 txt\n# 编译命令$ javac Demo.java# 反编译将其写入txt文件$ javap -v Demo.class &gt; Demo.txt\n\n版本号&#x2F;访问控制, 版本号规则 : JDK5,6,7,8 分别对应 49,50,51,52\npublic class Demo  minor version: 0 //次版本号  major version: 52 //主版本号  flags: ACC_PUBLIC, ACC_SUPER //访问标志\n\n常量池\nConstant pool:   #1 = Methodref          #5.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V   #4 = Class              #19            // Demo1   #5 = Class              #20            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               main  #11 = Utf8               ([Ljava/lang/String;)V  #12 = Utf8               SourceFile  #13 = Utf8               Demo1.java  #14 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #15 = Class              #21            // java/lang/System  #16 = NameAndType        #22:#23        // out:Ljava/io/PrintStream;  #17 = Class              #24            // java/io/PrintStream  #18 = NameAndType        #25:#26        // println:(I)V  #19 = Utf8               Demo1  #20 = Utf8               java/lang/Object  #21 = Utf8               java/lang/System  #22 = Utf8               out  #23 = Utf8               Ljava/io/PrintStream;  #24 = Utf8               java/io/PrintStream  #25 = Utf8               println  #26 = Utf8               (I)V\n\n构造方法 : 示例中并没有写构造函数, 由此可见, 没有定义构造函数时, 会有隐式的无参构造函数\npublic Demo();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=1, locals=1, args_size=1      0: aload_0      1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      4: return    LineNumberTable:      line 1: 0\n\n程序入口 main 方法 : stack(操作数栈), locals(为本地变量表)\npublic static void main(java.lang.String[]);  descriptor: ([Ljava/lang/String;)V  flags: ACC_PUBLIC, ACC_STATIC\t//访问控制  Code:    stack=3, locals=5, args_size=1      /**       * jvm执行引擎去执行这些源码编译过后的指令码       * javap编译出来是操作符,class文件内存的是指令码       * 前面的数字,是偏移量(字节),jvm根据这个去区分不同的指令(查看jvm指令码表)       */       0: sipush        500       3: istore_1       4: bipush        100       6: istore_2       7: iload_1       8: iload_2       9: idiv      10: istore_3      11: bipush        50      13: istore        4      15: getstatic     #2        // Field java/lang/System.out:Ljava/io/PrintStream;      18: iload_3      19: iload         4      21: iadd      22: invokevirtual #3        // Method java/io/PrintStream.println:(I)V      25: return    LineNumberTable:      line 3: 0      line 4: 4      line 5: 7      line 6: 11      line 7: 15      line 8: 25\n\n四 : 程序完整运行分析(一) 加载信息到方法区此时属于线程共享部分的方法区会存在大量的类信息, 同时还存在运行时常量池字符串常量。\nHotSpot 虚拟机 : 1.7及之前称为永久代, 1.8开始称为元数据空间。\n(二) jvm 创建线程来执行代码在虚拟机栈, 程序计数器内存区域中创建线程独占的空间。\n虚拟机栈中存放Thread栈帧, 程序计数器中存放Thread执行位置(字节码指令地址)。\n(三) 方法区程序入口\nmain 方法栈帧初始化 : 5个本地变量, 变量0是方法参数 args\n\n\n\n(四) 程序执行过程\n将500压入操作数栈\n\n\n弹出操作数栈栈顶500保存到本地变量表1\n\n\n将100压入操作数栈\n\n\n弹出操作数栈栈顶100保存到本地变量表2\n\n\n读取本地变量1压入操作数栈\n\n\n读取本地变量2压入操作数栈\n\n\n将栈顶两int类型数相除, 结果入栈 500&#x2F;100&#x3D;5\n\n\n将栈顶int类型值保存到局部变量3中\n\n\n将50压入操作数栈\n\n\n将栈顶int类型值保存到局部变量4中\n\n\n获取类或接口字段的值并将其压入操作数栈\n\n\n将本地变量3取出压入操作数栈\n\n\n将本地变量4取出压入操作数栈\n\n\n将栈顶两int类型数相加, 结果入栈\n\n\n调用静态方法; jvm会根据这个方法的描述,创建新栈帧, 方法的参数从操作数栈中弹出来,压入虚拟机栈, 然后虚拟机会开始执行虚拟机栈最上面的栈帧; 执行完毕后,再继续执行main方法对应的栈帧\n\n\nvoid函数返回, main方法执行结束\n\n\n\n","categories":["高性能编程"],"tags":["多线程并发编程","java基础"]},{"title":"博客图床","url":"/2019/12/25/blog-images/","content":"\n要写博客, 免不了要图文结合, 图片怎么办 ?\n\n一 : typora\n下载地址 : https://download2.typoraio.cn/windows/typora-setup-x64.exe\n傻瓜式安装即可\n\n二 : github\n创建一个公开仓库 : blog_images\n在 settings &#x3D;&gt; Developer settings &#x3D;&gt; Personal access tokens 里生成一个 token\n\n三 : picgo\n文件 &#x3D;&gt; 偏好设置 &#x3D;&gt; 图像, 做如下修改\n\n\n点击下载或更新, 下载 PicGo-Core(command-line)\n\n下载完毕后, 点击打开配置文件, 或者手动打开 C:/Users/&#123;用户名&#125;/.picgo/config.json, 参考下面文件进行配置\n&#123;    &quot;picBed&quot;: &#123;\t\t&quot;current&quot;: &quot;github&quot;,        &quot;github&quot;: &#123;            &quot;repo&quot;: &quot;info4z/blog_images&quot;,            &quot;branch&quot;: &quot;main&quot;,            &quot;token&quot;:&quot;刚刚生成的 Personal access tokens&quot;,              &quot;path&quot;: &quot;images&quot;,            &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/info4z/blog_images@main&quot;        &#125;    &#125;,    &quot;picgoPlugins&quot;: &#123;&#125;&#125;\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客美化","url":"/2019/12/24/blog-theme/","content":"\nhexo 提供了博客的骨架, 通过 kaze 使其丰满起来吧\n\n一 : 主题\n博客搭建完毕后, 可以对其进行一定的美化, 可以使用 kaze 主题\n$ git clone git@github.com:theme-kaze/hexo-theme-kaze.git themes/kaze\n\n二 : 站点配置\n编辑博客根目录下的 _config.yml\n# Sitetitle: 冰清阁\t\t#标题subtitle: &#x27;&#x27;description: &#x27;差不多得了, 玩什么命呀...&#x27;\t#简介或者格言keywords:author: 清月明风\t\t#作者language: zh-CN\t\t#主题语言,查看themes\\next\\languages下面的具体名字timezone: Asia/Shanghai\t\t#中国的时区# URLurl: https://info4z.github.io# 代码高亮highlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: trueprismjs:  enable: false# Extensionstheme: kaze\n\n三 : 主题配置\n修改 kaze下的 _config.yml\n# Header configtitle: 冰清阁author: 清月明风logo_img: https://img.songhn.com/img/Y67gdd.pngauthor_img: https://img.songhn.com/img/Y67gdd.pngauthor_description: 差不多得了, 玩什么命呀...\n\n目录\n# Navbar configmenus:  home: /  tags: /tags  categories: /categories  archive: /archives  about: /about  friends: /friends\n\n当然了, 有些目录是不存在的, 需要手动创建\n$ hexo new page tags$ hexo new page categories$ hexo new page about$ hexo new page friends\n\n搜索\nsearch:  enable: true  path: search.json  field: posts  searchContent: true\n\n","categories":["博客搭建"],"tags":[]},{"title":"博客搭建","url":"/2019/12/24/blog-hexo/","content":"\n基于 hexo 在 github 上搭建属于自己的博客\n\n一 : nodejs\n官网 : https://nodejs.org/zh-cn/\n\n下载地址 : https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi (长期维护版即可)\n\n安装完成后 : \n# 查看node版本$ node -v\n\n二 : npm\nnode.js 自带 npm\n# 查看npm版本$ npm -v\n\nnpm 有时候不是特别好用, 可以使用 cnpm\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n安装过程中可能会出现无法加载文件的问题, 解决方案如下\n# 以管理员身份运行powerShellPS D:\\Blog&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS D:\\fore\\jshERP-web&gt; get-ExecutionPolicyRemoteSigned\n\n查看版本信息\n$ cnpm -v\n\n三 : hexo\n使用 npm 安装 hexo\n# npm和cnpm哪个好使用哪个$ cnpm install -g hexo-cli\n\n初始化\n# init : Create a new Hexo folder$ hexo init\n\n生成工具栏\n$ hexo new page tags \t\t# 新增标签$ hexo new page categories\t# 新增分类\n\n新写文章\n# 这里$ hexo new &quot;文章题目&quot;\n\n本地启动\n$ hexo server$ hexo s\n\n生成静态文件\n$ hexo generate$ hexo g\n\n四 : github\n创建仓库, 这里只需要注意 repository name 的值为 :  用户名.github.io\n\n通过 Settings 查看 Pages\nYour site is live at https://info4z.github.io/\t\t# 这就是个人博客的地址\n\n编辑 _config.yml\ndeploy:  type: git  repository: git@github.com:info4z/info4z.github.io.git \t# 用ssh连接  branch: main\n\n安装 git 部署插件\n$ cnpm install hexo-deployer-git --save\n\n执行如下指令\n# 清除缓存文件db.json和已生成的静态文件public$ hexo clean   # 生成网站静态文件到默认设置的public文件夹(generate)$ hexo g# 自动生成网站静态文件,并部署到设定的仓库(deploy)$ hexo d\n\n","categories":["博客搭建"],"tags":[]},{"title":"Hello World","url":"/2019/12/24/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["博客搭建"],"tags":[]}]