<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shell编程</title>
    <link href="/2023/02/03/shell%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/03/shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-多命令执行符"><a href="#一-多命令执行符" class="headerlink" title="一 : 多命令执行符"></a>一 : 多命令执行符</h2><table><thead><tr><th>多命令执行符</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td><code>;</code></td><td>命令1<code>;</code>命令2</td><td>多个命令顺序执行, 命令之间没有任何逻辑联系</td></tr><tr><td><code>&amp;&amp;</code></td><td>命令1<code>&amp;&amp;</code>命令2</td><td>当命令1正确执行($?&#x3D;0), 则命令2才会执行; 当命令1执行不正确($? ≠ 0), 则命令2不会执行</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td></tr></tbody></table><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断命令是否正确执行</span><br>[root@localhost ~]# ls &amp;&amp; echo yes || echo no<br></code></pre></td></tr></table></figure><h2 id="二-数值运算的方法"><a href="#二-数值运算的方法" class="headerlink" title="二 : 数值运算的方法"></a>二 : 数值运算的方法</h2><p>在 linux 中, 所有变量的默认类型是字符串型, 如果我需要进行数值运算, 可以采用的方式有三种</p><p><strong>推荐使用 <code>$((运算式))</code> 的方式</strong></p><h3 id="一-运算式-或-运算式"><a href="#一-运算式-或-运算式" class="headerlink" title="(一) $((运算式))或$[运算式]"></a>(一) <code>$((运算式))</code>或<code>$[运算式]</code></h3><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">变量 ff 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br>[root@localhost ~]# ff=$(( $aa+$bb ))<br>[root@localhost ~]# echo $ff<br>33<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变量 gg 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# gg=$[ $aa+$bb ]<br>[root@localhost ~]# echo $gg<br>33<br></code></pre></td></tr></table></figure><h3 id="二-数值运算工具-expr-或-let"><a href="#二-数值运算工具-expr-或-let" class="headerlink" title="(二) 数值运算工具 expr 或 let"></a>(二) 数值运算工具 expr 或 let</h3><p><strong>expr</strong> 命令要求<strong>运算符左右两侧必须有空格</strong>, 否则运算不执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量aa和变量bb赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">dd</span>的值是aa和bb的和。注意<span class="hljs-string">&quot;+&quot;</span>号左右两侧必须有空格</span><br>[root@localhost ~]# dd=$(expr $aa + $bb)<br><br>[root@localhost ~]# echo $dd <br>33<br></code></pre></td></tr></table></figure><p><strong>let</strong> 命令对格式要求比较宽松, 所以<strong>推荐使用 let 命令进行数值运算</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">给变量 aa 和变量 bb 赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量 ee 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# let ee=$aa+$bb<br>[root@localhost ~]# echo $ee<br>33<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">定义变量 n</span><br>[root@localhost ~]# n=20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量 n 的值等于变量本身再加 1</span><br>[root@localhost ~]# let n+=1<br>[root@localhost ~]# echo $n<br>21<br></code></pre></td></tr></table></figure><h3 id="三-声明变量类型-declare"><a href="#三-声明变量类型-declare" class="headerlink" title="(三) 声明变量类型 declare"></a>(三) 声明变量类型 <code>declare</code></h3><p>既然所有变量的默认类型是字符串型, 那么只要把变量声明为整数型不就可以了吗? 使用 <code>declare</code> 命令就可以实现声明变量的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# declare [+/-][选项] 变量名<br>选项:<br>    -: 给变量设定类型属性<br>    +: 取消变量的类型属性<br>    <br>    -a: 将变量声明为数组型(array)<br>    -i: 将变量声明为整数型(integer) <br>    -r: 讲变量声明为只读变量(readonly)。<br>        注意, 一旦设置为只读变量, 既不能修改变量的值, 也不能删除变量, 甚至不能通过+r 取消只读属性<br>    -x: 将变量声明为环境变量<br>    -p: 显示指定变量的被声明的类型<br></code></pre></td></tr></table></figure><p>代码示例, 了解即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 aa 和 bb 赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"># </span><span class="language-bash">声明变量 cc 的类型是整数型, 它的值是 aa 和 bb 的和</span><br>[root@localhost ~]# declare -i cc=$aa+$bb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这下终于可以相加了</span><br>[root@localhost ~]# echo $cc<br>33<br></code></pre></td></tr></table></figure><h2 id="二-条件判断-test"><a href="#二-条件判断-test" class="headerlink" title="二 : 条件判断 test"></a>二 : 条件判断 test</h2><h3 id="一-文件类型"><a href="#一-文件类型" class="headerlink" title="(一) 文件类型"></a>(一) 文件类型</h3><p>相关参数 </p><table><thead><tr><th>选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td><code>-b</code> 文件</td><td>block</td><td>判断该文件是否存在, 并且是否为块设备文件(是块设备文件为真)</td></tr><tr><td><code>-c</code> 文件</td><td>character</td><td>判断该文件是否存在, 并且是否为字符设备文件(是字符设备文件为真)</td></tr><tr><td><strong><code>-d</code> 文件</strong></td><td>directory</td><td>判断该文件是否存在, 并且是否为目录文件(<strong>是目录为真</strong>)</td></tr><tr><td><strong><code>-e</code> 文件</strong></td><td>exists</td><td>判断该文件是否存在(<strong>存在为真</strong>)</td></tr><tr><td><strong><code>-f</code> 文件</strong></td><td>file</td><td>判断该文件是否存在, 并且是否为普通文件(<strong>是普通文件为真</strong>)</td></tr><tr><td><strong><code>-L</code> 文件</strong></td><td>link</td><td>判断该文件是否存在, 并且是否为符号链接文件(<strong>是符号链接文件为真</strong>)</td></tr><tr><td><code>-p</code> 文件</td><td>pipe</td><td>判断该文件是否存在, 并且是否为管道文件(是管道文件为真)</td></tr><tr><td><strong><code>-s</code> 文件</strong></td><td>size &gt; 0</td><td>判断该文件是否存在, 并且是否为非空(<strong>非空为真</strong>)</td></tr><tr><td><code>-S</code> 文件</td><td>socket</td><td>判断该文件是否存在, 并且是否为套接字文件(是套接字文件为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令格式</span><br>[root@localhost ~]# test -e /root/sh/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通常我们喜欢使用另一种格式,而且更通用,如下</span><br>[root@localhost ~]# [ -e /root/sh/ ]<br>[root@localhost ~]# echo $?<br>0 #判断结果为 0,/root/sh/目录是存在的<br><br>[root@localhost ~]# [ -e /root/test ]<br>[root@localhost ~]# echo $? <br>1 #在/root/下并没有test文件或目录,所以&quot;$?&quot;的返回值为非零<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用&amp;&amp;和||</span><br>[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><h3 id="二-文件权限"><a href="#二-文件权限" class="headerlink" title="(二) 文件权限"></a>(二) 文件权限</h3><p>相关参数 </p><table><thead><tr><th>选项</th><th>作 用</th></tr></thead><tbody><tr><td><strong><code>-r</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有读权限(有读权限为真)</td></tr><tr><td><strong><code>-w</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有写权限(有写权限为真)</td></tr><tr><td><strong><code>-x</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有执行权限(有执行权限为真)</td></tr><tr><td><code>-u</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SUID 权限(有 SUID 权限为真)</td></tr><tr><td><code>-g</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SGID 权限(有 SGID 权限为真)</td></tr><tr><td><code>-k</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SBit 权限(有 SBit 权限为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ll null.txt <br>-rw-r--r-- 1 root root 0 Nov 16 18:45 null.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断文件是拥有写权限的</span><br>[root@localhost ~]# [ -w null.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br></code></pre></td></tr></table></figure><h3 id="三-文件比较"><a href="#三-文件比较" class="headerlink" title="(三) 文件比较"></a>(三) 文件比较</h3><p>如何进行两个文件之间的比较</p><table><thead><tr><th>测试选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td>文件1 <code>-nt</code> 文件2</td><td>new</td><td>判断文件1的修改时间是否比文件2的新(如果新则为真)</td></tr><tr><td>文件1 <code>-ot</code> 文件2</td><td>old</td><td>判断文件1的修改时间是否比文件2的旧(如果旧则为真)</td></tr><tr><td><strong>文件1 <code>-ef</code> 文件2</strong></td><td>equal</td><td>判断文件1是否和文件2的Inode号一致,可以理解为两个文件是否为同一个文件(<strong>硬链接</strong>)</td></tr></tbody></table><p>代码示例 : 判断两个文件是否是硬链接呢</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建个硬链接吧</span><br>[root@localhost ~]# ln /root/student.txt /tmp/stu.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">用 <span class="hljs-built_in">test</span> 测试下,果然很有用</span><br>[root@localhost ~]# [ /root/student.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br></code></pre></td></tr></table></figure><h3 id="四-整数比较"><a href="#四-整数比较" class="headerlink" title="(四) 整数比较"></a>(四) 整数比较</h3><p>如何在两个整数之间进行比较</p><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 <code>-eq</code> 整数2</td><td>判断整数1是否和整数2相等(相等为真)</td></tr><tr><td>整数1 <code>-ne</code> 整数2</td><td>判断整数1是否和整数2不相等(不相等位置)</td></tr><tr><td>整数1 <code>-gt</code> 整数2</td><td>判断整数1是否大于整数2(大于为真)</td></tr><tr><td>整数1 <code>-lt</code> 整数2</td><td>判断整数1是否小于整数2(小于位置)</td></tr><tr><td>整数1 <code>-ge</code> 整数2</td><td>判断整数1是否大于等于整数2(大于等于为真)</td></tr><tr><td>整数1 <code>-le</code> 整数2</td><td>判断整数1是否小于等于整数2(小于等于为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 23 是否大于等于 22,当然是了</span><br>[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 23 是否小于等于 22,当然不是了</span><br>[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>no<br></code></pre></td></tr></table></figure><h3 id="五-字符串判断"><a href="#五-字符串判断" class="headerlink" title="(五) 字符串判断"></a>(五) 字符串判断</h3><p>字符串的判断</p><table><thead><tr><th>测试选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td><code>-z</code> 字符串</td><td>length zero</td><td>判断字符串是否为空(空为真)</td></tr><tr><td><code>-n</code> 字符串</td><td>nonzero</td><td>判断字符串是否为非空(非空为真)</td></tr><tr><td>字串1 <code>==</code> 字串2</td><td></td><td>判断字符串1是否和字符串2相等(相等为真)</td></tr><tr><td>字串1 <code>!=</code> 字串2</td><td></td><td>判断字符串1是否和字符串2不相等(不等为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断name变量是否为空</span><br>[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 aa 和变量 bb 赋值</span><br>[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><h3 id="六-多重条件判断"><a href="#六-多重条件判断" class="headerlink" title="(六) 多重条件判断"></a>(六) 多重条件判断</h3><p>多重条件判断是什么样子的</p><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 <code>-a</code> 判断2</td><td>逻辑与, 判断1和判断2都成立, 最终的结果才为真</td></tr><tr><td>判断1 <code>-o</code> 判断2</td><td>逻辑或, 判断1和判断2有一个成立, 最终的结果就为真</td></tr><tr><td><code>!</code> 判断</td><td>逻辑非, 使原始的判断式取反</td></tr></tbody></table><p>代码示例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断变量aa是否为空且是否大于 23</span><br>[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本来<span class="hljs-string">&quot;-n&quot;</span>选项是变量aa不为空,加<span class="hljs-string">&quot;!&quot;</span>后相当于<span class="hljs-string">&quot;-z&quot;</span></span><br>[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><ul><li><strong>注意 : <code>!</code> 和 <code>-n</code> 之间必须加入空格,否则会报错的。</strong></li></ul><h2 id="三-条件判断"><a href="#三-条件判断" class="headerlink" title="三 : 条件判断"></a>三 : 条件判断</h2><h3 id="一-单分支-if"><a href="#一-单分支-if" class="headerlink" title="(一) 单分支 if"></a>(一) 单分支 if</h3><p>单分支条件语句最为简单, 就是只有一个判断条件, 如果符合条件则执行某个程序, 否则什么事情都不做; 语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ];then<br>程序<br>fi<br></code></pre></td></tr></table></figure><p>需要注意几个点 : </p><ul><li><p><strong><code>if</code> 语句使用 <code>fi</code> 结尾</strong>, 和一般语言使用大括号结尾不同</p></li><li><p><code>[ 条件判断式 ]</code> 就是使用 <code>test</code> 命令判断,所以<strong>中括号和条件判断式之间必须有空格</strong></p></li><li><p><code>then</code> 后面跟符合条件之后执行的程序, 可以放在 <code>[]</code> 之后用 <code>;</code> 分割。<strong>也可以换行写入, 就不需要 <code>;</code> 了</strong>, 比如单分支 if 语句还可以这样写 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>    then<br>  程序<br>fi<br></code></pre></td></tr></table></figure></li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/if1.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">统计根分区使用率</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">把根分区使用率作为变量值赋予变量 rate</span><br>rate=$(df -h | grep &quot;/dev/vda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 rate 的值如果大于等于 80,则执行 <span class="hljs-keyword">then</span> 程序</span><br>if [ $rate -ge 80 ]<br>    then <br>    echo &quot;Warning! /dev/sda3 is full!!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="二-双分支-if-条件语句"><a href="#二-双分支-if-条件语句" class="headerlink" title="(二) 双分支 if 条件语句"></a>(二) 双分支 if 条件语句</h3><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>    then<br>    条件成立时,执行的程序<br>    else<br>    条件不成立时,执行的另一个程序<br>fi<br></code></pre></td></tr></table></figure><p>代码示例 : 我们写一个数据备份的例子, 来看看双分支 if 条件语句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">备份 mysql 数据库</span><br>[root@localhost ~]# vi sh/bakmysql.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份 mysql 数据库</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">同步系统时间</span><br>ntpdate asia.pool.ntp.org &amp;&gt;/dev/null<br><span class="hljs-meta prompt_">#</span><span class="language-bash">把当前系统时间按照<span class="hljs-string">&quot;年月日&quot;</span>格式赋予变量 <span class="hljs-built_in">date</span></span><br>date=$(date +%y%m%d)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">统计 mysql 数据库的大小,并把大小赋予 size 变量</span><br>size=$(du -sh /var/lib/mysql)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断备份目录是否存在,是否为目录</span><br>if [ -d /tmp/dbbak ]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果判断为真,执行以下脚本</span><br>    then<br>    #把当前日期写入临时文件<br>        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt<br>        #把数据库大小写入临时文件<br>        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt<br>        #进入备份目录<br>        cd /tmp/dbbak<br>        #打包压缩数据库与临时文件,把所有输出丢入垃圾箱(不想看到任何输出)<br>        tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null<br>        #删除临时文件<br>        rm -rf /tmp/dbbak/dbinfo.txt<br>    else<br>    #如果判断为假,则建立备份目录<br>        mkdir /tmp/dbbak<br>        #把日期和数据库大小保存如临时文件<br>        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt<br>        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt<br>        #压缩备份数据库与临时文件<br>        cd /tmp/dbbak<br>        tar -zcf mysql-lib-$date.tar.gz dbinfo.txt /var/lib/mysql &amp;&gt;/dev/null<br>        #删除临时文件<br>        rm -rf /tmp/dbbak/dbinfo.txt<br>fi<br></code></pre></td></tr></table></figure><ul><li><strong>注意 :</strong> 解释一下 <strong><code>&amp;&gt;/dev/null</code></strong> 这个命令, <code>&amp;&gt;</code> 输出, <code>/dev/null</code> 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 <code>&amp;&gt;/dev/null</code>, <strong>用于屏蔽命令的提示信息</strong></li></ul><p>实例 : 在工作当中,服务器上的服务经常会宕机。如果我们对服务器监控不好,就会造成服务器中服务宕机了,而管理员却不知道的情况, 这时我们可以写一个脚本来监听本机的服务,如果服务停止或宕机了,可以自动重启这些服务。我们拿 apache 服务来举例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断 apache 是否启动,如果没有启动则自动启动</span><br>[root@localhost ~]# vi sh/autostart.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 apache 是否启动,如果没有启动则自动启动</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Author: Bob (E-mail: Bob@163.com)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用nmap命令扫描服务器公网ip,并截取 apache 服务的状态,赋予变量 port</span><br>port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果变量 port 的值是<span class="hljs-string">&quot;open&quot;</span></span><br>if [ &quot;$port&quot; == &quot;open&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">则证明 apache 正常启动,在正常日志中写入一句话即可</span><br>echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log<br>else<br><span class="hljs-meta prompt_">#</span><span class="language-bash">否则证明 apache 没有启动,自动启动 apache</span><br>/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null<br><span class="hljs-meta prompt_">#</span><span class="language-bash">并在错误日志中记录自动启动 apche 的时间</span><br>echo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.log<br>fi<br></code></pre></td></tr></table></figure><ul><li><p>我们使用 <code>nmap</code> 端口扫描命令, 它的原理是给指定服务器所有的端口发送请求, 看它是否回复, <code>nmap</code> 命令格式如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# nmap -sT 域名或IP(一般用公网IP)<br>选项 : <br>    -s 扫描<br>    -T 扫描所有开启的 TCP 端口<br></code></pre></td></tr></table></figure></li><li><p>这条命令的执行结果如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到这台服务器开启了如下的服务</span><br>[root@localhost ~]# nmap -sT 192.168.4.210<br>Starting Nmap 5.51 ( http://nmap.org ) at 2018-11-25 15:11 CST<br>Nmap scan report for 192.168.4.210<br>Host is up (0.0010s latency).<br>Not shown: 994 closed ports<br>PORT STATE SERVICE<br>22/tcp open ssh<br>80/tcp open http #apache 的状态是 open<br>111/tcp open rpcbind<br>139/tcp open netbios-ssn<br>445/tcp open microsoft-ds<br>3306/tcp open mysql<br>Nmap done: 1 IP address (1 host up) scanned in 0.49 seconds<br></code></pre></td></tr></table></figure></li><li><p>知道了 <code>nmap</code> 命令的用法,我们在脚本中使用的命令就是为了截取 <code>http</code> 的状态,只要状态是 <code>open</code> 就证明 apache 启动正常,否则证明 apache 启动错误。来看看脚本中命令的结果 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描指定计算机,提取包含 tcp 的行,在提取包含 httpd 的行,截取第二列</span><br>[root@localhost ~]# nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;<br>open<br><span class="hljs-meta prompt_"># </span><span class="language-bash">把截取的值赋予变量 port</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="三-多分支-if-条件语句"><a href="#三-多分支-if-条件语句" class="headerlink" title="(三) 多分支 if 条件语句"></a>(三) 多分支 if 条件语句</h3><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 1 ]<br>    then<br>    当条件判断式 1 成立时,执行程序 1<br>elif [ 条件判断式 2 ]<br>    then<br>        当条件判断式 2 成立时,执行程序 2 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">…省略更多条件…</span><br>else<br>当所有条件都不成立时,最后执行此程序<br>fi<br></code></pre></td></tr></table></figure><p>代码示例 : 判断用户输入的是什么文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/if-elif.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断用户输入的是什么文件</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接收键盘的输入,并赋予变量 file</span><br>read -p &quot;Please input a filename: &quot; file<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 变量是否为空</span><br>if [ -z &quot;$file&quot; ]<br>then<br>        #如果为空,执行程序 1,也就是输出报错信息<br>        echo &quot;Error,please input a filename&quot;<br>        #退出程序,并返回值为 1(把返回值赋予变量$?)<br>exit 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否存在</span><br>elif [ ! -e &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果不存在,则执行程序 2</span><br>echo &quot;Your input is not a file!&quot;<br>        #退出程序,把并定义返回值为 2<br>        exit 2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否为普通文件</span><br>elif [ -f &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是普通文件,则执行程序 3</span><br>        echo &quot;$file is a regulare file!&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否为目录文件</span><br>elif [ -d &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是目录文件,则执行程序 4</span><br>echo &quot;$file is a directory!&quot;<br>else<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果以上判断都不是,则执行程序 5</span><br>echo &quot;$file is an other file!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="四-case-条件语句"><a href="#四-case-条件语句" class="headerlink" title="(四) case 条件语句"></a>(四) case 条件语句</h3><p><code>case</code> 语句和 <code>if…elif…else</code> 语句一样都是多分支条件语句, 不过和 <code>if</code> 多分支条件语句不同的是, <code>case</code> 语句只能判断一种条件关系, 而 <code>if</code> 语句可以判断多种条件关系。case 语句语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>    &quot;值1&quot;)<br>    如果变量的值等于值 1,则执行程序 1<br>    ;;<br>    &quot;值2&quot;)<br>    如果变量的值等于值 2,则执行程序 2<br>    ;;<br>    …省略其他分支…<br>     *)<br>    如果变量的值都不是以上的值,则执行此程序<br>    ;;<br>esac<br></code></pre></td></tr></table></figure><p><strong>注意</strong>以下内容 : </p><ul><li><code>case</code> 语句, 会取出变量中的值, 然后与语句体中的值逐一比较; 如果数值符合, 则执行对应的程序, 如果数值不符, 则依次比较下一个值。如果所有的值都不符合,则执行 <code>*)</code> 中的程序;  <code>*</code>  代表所有其他值</li><li><code>case</code> 语句以 <code>case</code> 开头, 以 <code>esac</code> 结尾; 每一个分支程序之后要通过 <code>;;</code> 双分号结尾, 代表该程序段结束(千万不要忘记)。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/case.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断用户输入</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在屏幕上输出<span class="hljs-string">&quot;请选择 yes/no&quot;</span>,然后把用户选择赋予变量 cho</span><br>read -p &quot;Please choose yes/no: &quot; -t 30 cho<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断变量 cho 的值</span><br>case $cho in<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是 <span class="hljs-built_in">yes</span></span><br>    &quot;yes&quot;)<br>    #执行程序 1<br>        echo &quot;Your choose is yes!&quot;<br>        ;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是 no</span><br>    &quot;no&quot;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行程序 2</span><br>        echo &quot;Your choose is no!&quot;<br>        ;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果既不是 <span class="hljs-built_in">yes</span>,也不是 no</span><br>    *)<br>    #则执行此程序<br>        echo &quot;Your choose is error!&quot;<br>        ;;<br>esac<br></code></pre></td></tr></table></figure><h2 id="四-循环"><a href="#四-循环" class="headerlink" title="四 : 循环"></a>四 : 循环</h2><h3 id="一-for-循环"><a href="#一-for-循环" class="headerlink" title="(一) for 循环"></a>(一) for 循环</h3><p><code>for</code> 循环是固定循环, 也就是在循环时已经知道需要进行几次的循环, 有时也把 <code>for</code> 循环称为<strong>计数循环</strong>。for 的语法有两种 : </p><p><strong>语法一</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3…<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><ul><li>这种语法中 for 循环的次数, 取决于 in 后面值的个数(空格分隔), 有几个值就循环几次, 并且每次循环都把值赋予变量。也就是说,假设 in 后面有三个值, 就会循环三次, 第一次循环会把值1赋予变量, 第二次循环会把值2赋予变量, 以此类推。</li></ul><p><strong>语法二</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始值;循环控制条件;变量变化 ))<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><p>语法二中<strong>需要注意</strong> : </p><ul><li>初始值 : 在循环开始时, 需要给某个变量赋予初始值, 如 i&#x3D;1;  </li><li>循环控制条件 : 用于指定变量循环的次数,如 i&lt;&#x3D;100, 则只要 i 的值小于等于 100, 循环就会继续; </li><li>变量变化 : 每次循环之后, 变量该如何变化,如 i&#x3D;i+1; 代表每次循环之后, 变量 i 的值都加 1。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/for.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印时间</span><br>for time in morning noon afternoon evening<br>do<br>echo &quot;This time is $time!&quot;<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/auto-tar.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量解压缩脚本</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入压缩包目录</span><br>cd /lamp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出.tar.gz的值,有多少个文件,就会循环多少次,每次循环把文件名赋予变量i</span><br>for i in $(ls *.tar.gz)<br>do<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压缩,并把所有输出都丢弃</span><br>tar -zxf $i &amp;&gt;/dev/null<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从1加到100</span><br><br>s=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义循环 100 次</span><br>for (( i=1;i&lt;=100;i=i+1 ))<br>    do<br>    # 每次循环给变量 s 赋值<br>        s=$(( $s+$i ))<br>    done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出1加到100的和</span><br>echo &quot;The sum of 1+2+...+100 is : $s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi useradd.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量添加指定数量的用户</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入用户名,把输入保存入变量 name</span><br>read -p &quot;Please input user name: &quot; -t 30 name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量,把输入保存入变量 num</span><br>read -p &quot;Please input the number of users: &quot; -t 30 num <br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入初始密码,把输入保存如变量 pass</span><br>read -p &quot;Please input the password of users: &quot; -t 30 pass<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span><br>if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot; ]<br>    then<br>    # 定义变量的值为后续命令的结果<br>    # 后续命令作用是,把变量num的值替换为空。如果能替换为空,证明 num 的值为数字<br>    # 如果不能替换为空,证明 num 的值为非数字。我们使用这种方法判断变量 num 的值为数字<br>    y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)<br>        # 如果变量 y 的值为空,证明 num 变量是数字<br>        if [ -z &quot;$y&quot; ]<br>            then<br>                # 循环 num 变量指定的次数<br>                for (( i=1;i&lt;=$num;i=i+1 ))<br>                    do <br>                        # 添加用户,用户名为变量 name 的值加变量 i 的数字<br>                        /usr/sbin/useradd $name$i &amp;&gt;/dev/null<br>                        # 给用户设定初始密码为变量 pass 的值<br>                        echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null<br>                    done<br>        fi <br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/userdel.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">批量删除用户</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">读取用户信息文件,提取可以登录用户,排除root用户,截取第一列就是用户名</span><br>user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; |cut -d &quot;:&quot; -f 1)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环,有多少个普通用户,循环多少次</span><br>for i in $user<br>    do <br>    #每次循环,删除指定普通用户<br>        userdel -r $i<br>    done<br></code></pre></td></tr></table></figure><h3 id="二-while-循环"><a href="#二-while-循环" class="headerlink" title="(二) while 循环"></a>(二) while 循环</h3><p>对 <code>while</code> 循环来讲, 只要条件判断式成立, 循环就会一直继续, 直到条件判断式不成立, 循环才会停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><p>代码示例 : 1 加到 100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从 1 加到 100</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 i 和变量 s 赋值</span><br>i=1<br>s=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果变量 i 的值小于等于 100,则执行循环</span><br>while [ $i -le 100 ]<br>    do<br>        s=$(( $s+$i ))<br>        i=$(( $i+1 ))<br>    done<br>echo &quot;The sum is: $s&quot; <br></code></pre></td></tr></table></figure><h3 id="三-until-循环"><a href="#三-until-循环" class="headerlink" title="(三) until 循环"></a>(三) until 循环</h3><p>和 <code>while</code> 循环相反, <code>until</code> 循环时<strong>只要条件判断式不成立则进行循环</strong>, 并执行循环程序; 一旦循环条件成立,则终止循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ 条件判断式 ]<br>    do<br>   程序<br>    done<br></code></pre></td></tr></table></figure><p>还是写从 1 加到 100 这个例子, 注意和 while 循环的区别 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 1 加到 100</span><br>[root@localhost ~]# vi sh/until.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从 1 加到 100</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给变量i和s赋值</span><br>i=1<br>s=0<br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环直到变量i的值大于100,就停止循环</span><br>until [ $i -gt 100 ]<br>    do<br>        s=$(( $s+$i ))<br>        i=$(( $i+1 ))<br>    done<br>echo &quot;The sum is: $s&quot;<br></code></pre></td></tr></table></figure><h2 id="五-退出"><a href="#五-退出" class="headerlink" title="五 : 退出"></a>五 : 退出</h2><h3 id="一-exit-语句"><a href="#一-exit-语句" class="headerlink" title="(一) exit 语句"></a>(一) exit 语句</h3><p>系统是有 <code>exit</code> 命令的,用于退出当前用户的登录状态。可是在 Shell 脚本中, <code>exit</code> 语句是用来退出当前脚本的。也就是说, 在 Shell 脚本中, 只要碰到了 <code>exit</code> 语句, 后续的程序就不再执行, 而直接退出脚本。</p><p>exit 的语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit [返回值]<br></code></pre></td></tr></table></figure><ul><li>如果 <code>exit</code> 命令之后定义了返回值, 那么这个脚本执行之后的返回值就是我们自己定义的返回值; 可以通过查询 <code>$?</code> 这个变量来查看返回值; 如果 exit 之后没有定义返回值, 脚本执行之后的返回值是执行 exit 语句之前, 最后执行的一条命令的返回值。</li></ul><p>代码示例 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/exit.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接收用户的输入,并把输入赋予num</span><br>read -p &quot;Please input a number: &quot; -t 30 num <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果变num的值是数字,则把num的值替换为空,否则不替换</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">把替换之后的值赋予变量 y</span><br>y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断变量 y 的值如果不为空,输出报错信息,退出脚本,退出返回值为 18</span><br>[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果没有退出脚本,则打印变量 num 中的数字</span><br>echo &quot;The number is: $num&quot;<br></code></pre></td></tr></table></figure><ul><li><strong>注意 : 这里的字符串变量要用 <code>&quot;&quot;</code> 引一下</strong></li></ul><h3 id="二-break-语句"><a href="#二-break-语句" class="headerlink" title="(二) break 语句"></a>(二) break 语句</h3><p>再来看看特殊流程控制语句 <code>break</code> 的作用, 当程序执行到 <code>break</code> 语句时, <strong>会结束整个当前循环</strong>; 而 <code>continue</code> 语句也是结束循环的语句, 不过 <code>continue</code> 语句单次当前循环, 而下次循环会继续。</p><p>代码示例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/break.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">演示 <span class="hljs-built_in">break</span> 跳出循环</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环十次</span><br>for (( i=1;i&lt;=10;i=i+1 ))<br>    do <br>    #如果变量 i 的值等于 4<br>        if [ &quot;$i&quot; -eq 4 ]<br>            then<br>            #退出整个循环<br>                break<br>        fi <br>        echo $i<br>        #输出变量 i 的值<br>    done<br></code></pre></td></tr></table></figure><p>测试结果 : 输出1,2,3后停止脚本</p><h3 id="三-continue-语句"><a href="#三-continue-语句" class="headerlink" title="(三) continue 语句"></a>(三) continue 语句</h3><p>再来看看 continue 语句, continue 也是结束流程控制的语句; 如果在循环中, <code>continue</code> 语句只会<strong>结束单次当前循环</strong></p><p>还是用刚刚的脚本,不过退出语句换成 <code>continue</code> 语句,看看会发生什么情况 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/continue.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">演示 <span class="hljs-built_in">continue</span> 语句</span><br><br>for (( i=1;i&lt;=10;i=i+1 ))<br>    do <br>        if [ &quot;$i&quot; -eq 4 ] <br>            then<br>            #退出语句换成 continue<br>                continue<br>        fi <br>        echo $i<br>    done<br></code></pre></td></tr></table></figure><p>测试结果 : 只有4不会被输出</p><h2 id="六-函数"><a href="#六-函数" class="headerlink" title="六 : 函数"></a>六 : 函数</h2><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function 函数名 () &#123;<br>程序<br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]<span class="hljs-comment"># vi sh/function.sh</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#接收用户输入的数字,然后从1加到这个数字</span><br><br><span class="hljs-comment">#定义函数 sum</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">sum</span></span> () &#123;<br>    s=0 <br>    <span class="hljs-comment">#循环直到i大于$1为止。$1是函数sum的第一个参数</span><br>    <span class="hljs-comment">#在函数中也可以使用位置参数变量,不过这里的$1指的是函数的第一个参数</span><br>    <span class="hljs-keyword">for</span> (( i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-variable">$1</span>;i=i+<span class="hljs-number">1</span> ))<br>        <span class="hljs-keyword">do</span> <br>        s=$(( <span class="hljs-variable">$i</span>+<span class="hljs-variable">$s</span> ))<br>        <span class="hljs-keyword">done</span><br><span class="hljs-comment">#输出1加到$1 的和</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The sum of 1+2+3...+<span class="hljs-variable">$1</span> is : <span class="hljs-variable">$s</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment">#接收用户输入的数字,并把值赋予变量num</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please input a number: &quot;</span> -t 30 num <br><span class="hljs-comment">#把变量num的值替换为空,并赋予变量y</span><br>y=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$num</span> | sed <span class="hljs-string">&#x27;s/[0-9]//g&#x27;</span>)<br><span class="hljs-comment">#判断变量y是否为空,以确定变量 num 中是否为数字</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$y</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">#调用sum函数,并把变量num的值作为第一个参数传递给 sum 函数</span><br>        <span class="hljs-built_in">sum</span> <span class="hljs-variable">$num</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">#如果变量 num 的值不是数字,则输出报错信息</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error!! Please input a number!&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="七-接收键盘输入"><a href="#七-接收键盘输入" class="headerlink" title="七 : 接收键盘输入"></a>七 : 接收键盘输入</h2><p>用来从标准输入读取单行数据; 这个命令可以用来读取键盘输入, 当使用重定向的时候, 可以读取文件中的一行数据; 命令格式 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# read [选项] [变量名]<br>选项:<br>    -p &quot;message&quot;: 在等待 read 输入时, 输出提示信息(message)<br>    -t second: read 命令会一直等待用户输入, 使用此选项可以指定等待时间(秒数)<br>    -n number: read 命令只接受指定的字符数(number), 就会执行<br>    -s : 隐藏输入的数据, 适用于机密信息的输入<br>变量名:<br>    变量名可以自定义, 如果不指定变量名, 会把输入保存入默认变量 REPLY<br>    如果只提供了一个变量名, 则整个输入行赋予该变量<br>    如果提供了一个以上的变量名, 则输入行分为若干字, 一个接一个地赋予各个变量, 而命令行上的最后一个变量取得剩余的所有字<br></code></pre></td></tr></table></figure><p>还是写个例子来解释下 <code>read</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost sh]# vi read.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Author: Bob (E-mail: Bob@163.com)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请输入姓名&quot;</span>并等待 30 秒, 把用户的输入保存入变量 name 中</span><br>read -t 30 -p &quot;Please input your name: &quot; name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">看看变量<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span>中是否保存了你的输入</span><br>echo &quot;Name is $name&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请输入年龄&quot;</span>并等待30秒, 把用户的输入保存入变量age中</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">年龄是隐私, 所以我们用<span class="hljs-string">&quot;-s&quot;</span>选项隐藏输入</span><br>read -s -t 30 -p &quot;Please enter your age: &quot; age<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调整输出格式,如果不输出换行,一会儿的年龄输出不会换行</span><br>echo -e &quot;\n&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请选择性别&quot;</span>并等待 30 秒, 把用户的输入保存入变量 gender</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-string">&quot;-n 1&quot;</span>选项只接收一个输入字符就会执行(都不用输入回车)</span><br>echo &quot;Age is $age&quot;<br>read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender<br><br>echo -e &quot;\n&quot;<br>echo &quot;Sex is $gender&quot;<br></code></pre></td></tr></table></figure><h2 id="八-输入输出重定向"><a href="#八-输入输出重定向" class="headerlink" title="八 : 输入输出重定向"></a>八 : 输入输出重定向</h2><h3 id="一-Bash-的标准输入输出"><a href="#一-Bash-的标准输入输出" class="headerlink" title="(一) Bash 的标准输入输出"></a>(一) Bash 的标准输入输出</h3><table><thead><tr><th>设备</th><th>设备文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>&#x2F;dev&#x2F;stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>&#x2F;dev&#x2F;stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>&#x2F;dev&#x2F;stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table><h3 id="二-输出重定向"><a href="#二-输出重定向" class="headerlink" title="(二) 输出重定向"></a>(二) 输出重定向</h3><p>标准输出重定向</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>以覆盖的方式, 把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>以追加的方式, 把命令的正确输出输出到指定的文件或设备当中</td></tr></tbody></table><p>标准错误输出重定向</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>错误命令 2&gt;文件</td><td>以覆盖的方式, 把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td>错误命令 2&gt;&gt;文件</td><td>以追加的方式, 把命令的错误输出输出到指定的文件或设备当中</td></tr></tbody></table><p>正确输出和错误输出同时保存</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件 2&gt;&amp;1</td><td>以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &gt;&gt; 文件 2&gt;&amp;1</strong></td><td>以追加的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td>命令 &amp;&gt;文件</td><td>以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &amp;&gt;&gt;文件</strong></td><td>以追加的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &gt;&gt;文件1  2&gt;&gt;文件2</strong></td><td>把正确的输出追加到文件 1 中, 把错误的输出追加到文件 2 中</td></tr></tbody></table><ul><li><strong>注意: 错误输出<code>2</code>和<code>&gt;</code>之间不能有空格, 至于<code>&gt;</code>之后有没有空格无所谓, 为了方便记忆, 错误输出前后都不要加空格了</strong></li></ul><h3 id="三-输入重定向"><a href="#三-输入重定向" class="headerlink" title="(三) 输入重定向"></a>(三) 输入重定向</h3><p>同时也支持输入重定向</p><p>代码示例 : 在文件 var.ini 中统一定义变量, 通过脚本读出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=1<br>b=2<br>c=3<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中心思想就是把a=1,b=2,c=3引入进来声明,这里用到<span class="hljs-built_in">read</span>命令做重定向,可以一次读取一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">eval</span>命令用于重新运算求出参数的内容,还可读取一连串的参数，然后再依参数本身的特性来执行</span><br>while read line;do<br>eval $line<br>done &lt; var.ini<br>echo $a<br>echo $b<br>echo $c<br></code></pre></td></tr></table></figure><p>代码示例 : 统计 err.log 的行数,单词数和字节数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# wc &lt; err.log<br></code></pre></td></tr></table></figure><h3 id="四-垃圾桶"><a href="#四-垃圾桶" class="headerlink" title="(四) 垃圾桶"></a>(四) 垃圾桶</h3><p>解释一下比较常用的 <strong><code>&amp;&gt;/dev/null</code></strong> 这个命令  </p><p><code>&amp;&gt;</code> 输出, <code>/dev/null</code> 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 <code>&amp;&gt;/dev/null</code>, <strong>用于屏蔽命令的提示信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> java -jar xxx.jar &amp;&gt;/dev/null &amp;</span><br></code></pre></td></tr></table></figure><p>注意 : <code>&amp;</code> 放在启动参数后面表示设置此进程为后台进程，也即非阻塞性运行，如果不加&amp;，则会执行完该命令后才能执行后面的命令。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell入门</title>
    <link href="/2023/01/27/shell%E5%85%A5%E9%97%A8/"/>
    <url>/2023/01/27/shell%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Shell-概述"><a href="#一-Shell-概述" class="headerlink" title="一 : Shell 概述"></a>一 : Shell 概述</h2><h3 id="一-什么是-Shell"><a href="#一-什么是-Shell" class="headerlink" title="(一) 什么是 Shell"></a>(一) 什么是 Shell</h3><p>Shell 是一个用 C 语言编写的程序, 它是用户使用 Linux 的桥梁。Shell 既是一种命令语言, 又是一种程序设计语言。</p><p>Shell 是指一种应用程序, 这个应用程序提供了一个界面, 用户通过这个界面访问操作系统内核的服务。</p><p>硬件 &#x3D;&gt; 内核 &#x3D;&gt; shell命令解释器 &#x3D;&gt; 外层应用程序</p><p>Ken Thompson 的 sh 是第一种 Unix Shell, Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="二-Shell-脚本"><a href="#二-Shell-脚本" class="headerlink" title="(二) Shell 脚本"></a>(二) Shell 脚本</h3><p>Shell 脚本(shell script), 是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本, 但读者朋友要知道, shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因, 简洁起见, 本文出现的 “shell编程” 都是指 shell 脚本编程, 不是指开发 shell 自身。</p><p>shell命令解释器 : 把命令翻译成机器语言, 再把结果翻译成命令</p><h3 id="三-shell-的分类"><a href="#三-shell-的分类" class="headerlink" title="(三) shell 的分类"></a>(三) shell 的分类</h3><table><thead><tr><th>Shell 类别</th><th>易学性</th><th>可移植性</th><th>编辑性</th><th>快捷性</th></tr></thead><tbody><tr><td>Bourne Shell (sh)</td><td>容易</td><td>好</td><td>较差</td><td>较差</td></tr><tr><td>Korn Shell (ksh)</td><td>较难</td><td>较好</td><td>好</td><td>较好</td></tr><tr><td><strong>Bourne Again (Bash)</strong></td><td><strong>难</strong></td><td><strong>较好</strong></td><td><strong>好</strong></td><td><strong>好</strong></td></tr><tr><td>POSIX Shell (psh)</td><td>较难</td><td>好</td><td>好</td><td>较好</td></tr><tr><td>C Shell (csh)</td><td>较难</td><td>差</td><td>较好</td><td>较好</td></tr><tr><td>TC Shell (tcsh)</td><td>难</td><td>差</td><td>好</td><td>好</td></tr></tbody></table><p>Shell 的两种主要语法类型有 Bourne 和 C, 这两种语法彼此不兼容。</p><ul><li>Bourne 家族主要包括 sh、ksh、Bash、psh、zsh；</li><li>C 家族主要包括:csh、tcsh (Bash 和 zsh 在不同程度上支持 csh 的语法)。</li></ul><p>我们可以通过 <code>/etc/shells</code> 文件来查询 Linux 支持的 Shell。命令如下 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi /etc/shells<br><br>/bin/sh<br>/bin/Bash<br>/sbin/nologin<br>/bin/tcsh<br>/bin/csh<br></code></pre></td></tr></table></figure><h2 id="二-特殊符号"><a href="#二-特殊符号" class="headerlink" title="二 : 特殊符号"></a>二 : 特殊符号</h2><table><thead><tr><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>‘’</td><td>单引号。在单引号中所有的特殊符号, 如”$”和”&#96;”(反引号)都没有特殊含义。</td></tr><tr><td>“”</td><td>双引号。在双引号中特殊符号都没有特殊含义, 但是”$”、”&#96;”和”\“是例外, 拥有”调用变量的值”、”引用命令”和”转义符”的特殊含义。</td></tr><tr><td>&#96;&#96;</td><td>反引号。反引号括起来的内容是系统命令, 在 Bash 中会先执行它。和$()作用一样, <strong>不过推荐使用$()</strong>, 因为反引号非常容易看错。</td></tr><tr><td>$</td><td>用于调用变量的值, 如需要调用变量 name 的值时, 需要用 <code>$name</code> 的方式得到变量的值。</td></tr><tr><td>${}</td><td>括号里面写变量, 相当于 <code>$name</code></td></tr><tr><td>$()</td><td>和反引号作用一样, 用来引用系统命令。例如: <code>$(df -h)</code></td></tr><tr><td>$[]</td><td>括号里面运算式, 也可以用 <code>$((...))</code>, 例如: <code>$[1+2]</code></td></tr><tr><td>$(())</td><td>括号里面写运算式, 和 <code>$[]</code> 作用一样, 例如: <code>$((1+2))</code></td></tr><tr><td>()</td><td>用于一串命令执行时, ()中的命令会在子 Shell 中运行</td></tr><tr><td>{}</td><td>用于一串命令执行时, {}中的命令会在当前 Shell 中执行。也可以用于变量变形与替换。</td></tr><tr><td>[]</td><td>用于变量的测试。</td></tr><tr><td>#</td><td>在 Shell 脚本中, #开头的行代表注释。</td></tr><tr><td>\</td><td>转义符, 跟在 \ 之后的特殊符号将失去特殊含义, 变为普通字符。如 <code>\$</code> 将输出”$”符号, 而不当做是变量引用。</td></tr></tbody></table><h2 id="三-变量"><a href="#三-变量" class="headerlink" title="三 : 变量"></a>三 : 变量</h2><h3 id="一-用户自定义变量"><a href="#一-用户自定义变量" class="headerlink" title="(一) 用户自定义变量"></a>(一) 用户自定义变量</h3><p>这种变量是最常见的变量, 由用户自由定义变量名和变量的值。</p><p>注意变量定义的时候 : 变量名不能以数字开头, <code>=</code>两边不要写空格, 变量值必须是连续的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">变量名不能用数字开头</span><br>[root@localhost ~]# 2name=&quot;Bob Han&quot;<br>-bash: 2name=Bob: command not found<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">等号左右两侧不能有空格</span><br>[root@localhost ~]# name = &quot;Bob Han&quot;<br>-bash: name: command not found<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量的值如果有空格, 必须用引号包含</span><br>[root@localhost ~]# name=Bob Han<br>-bash: Han: command not found<br></code></pre></td></tr></table></figure><p>变量调用就直接使用 <code>$变量名</code> 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">输出变量 name 的值</span><br>[root@localhost ~]# echo $name<br>Bob<br></code></pre></td></tr></table></figure><p>变量查看 : 直接使用 <code>set</code> 命令, 会查询系统中所有的变量, 包含用户自定义变量和环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# set [选项]<br>选项:<br>-u: 如果设定此选项, 调用未声明变量时会报错(默认无任何提示)<br>-x: 如果设定此选项, 在命令执行之前, 会把命令先输出一次<br></code></pre></td></tr></table></figure><p>删除变量 : <code>unset</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意: 直接写变量名,不加$符号</span><br>[root@localhost ~]# unset name<br></code></pre></td></tr></table></figure><h3 id="二-环境变量"><a href="#二-环境变量" class="headerlink" title="(二) 环境变量"></a>(二) 环境变量</h3><p>这种变量中主要保存的是和系统操作环境相关的数据, 比如当前登录用户, 用户的家目录, 命令的提示符等</p><ul><li>环境变量的变量名可以自由定义, 但是一般对系统起作用的环境变量的变量名是系统预先设定好的</li><li>系统自带的环境变量 : <strong>命令是确定的, 作用是确定的, 但内容可以自定义</strong></li><li>用户自定义的环境变量 : <strong>命令, 作用和内容都可以自定义</strong></li><li><strong>环境变量名建议大写, 便于区分</strong></li></ul><p>环境变量设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">export</span> 声明的变量即是环境变量</span><br>[root@localhost ~]# export age=&quot;18&quot;<br></code></pre></td></tr></table></figure><p>环境变量查询和删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查询环境变量gender,<span class="hljs-built_in">env</span> 命令只能查看环境变量,而<span class="hljs-built_in">set</span>命令可以查看所有变量</span><br>[root@localhost ~]# env | grep gender<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除环境变量gender</span><br>[root@localhost ~]# unset gender<br></code></pre></td></tr></table></figure><p>系统默认环境变量 <code>PATH</code> : 系统查找命令的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">PATH变量的值是用<span class="hljs-string">&quot;:&quot;</span>分割的路径,这些路径就是系统查找命令的路径</span><br>[root@localhost ~]# echo $PATH<br>/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br></code></pre></td></tr></table></figure><ul><li>也就是说, 如果将test.sh放到 <code>/root/bin</code> (其中一个目录)下, 程序也可以直接执行; 或者定义 <code>PATH=$PATH:/root/sh</code> 将脚本所在目录追加进去</li></ul><p>系统默认环境变量 <code>PS1</code> : 命令提示符设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认的提示符是显示<span class="hljs-string">&quot;[用户名@简写主机名 最后所在目录]提示符&quot;</span></span><br>[root@localhost ~]# echo $PS1<br>[\u@\h \W]\$<br></code></pre></td></tr></table></figure><ul><li>如果需要永久修改, 可以写入配置文件 <code>/etc/bashrc</code></li></ul><p>系统默认环境变量 <code>LANG</code> : 语系变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost src]# echo $LANG<br>zh_CN.UTF-8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询支持的语系</span><br>[root@localhost src]# locale -a | more<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询当前系统的语系(当前系统使用的语系)</span><br>[root@localhost src]# locale<br>LANG=zh_CN.UTF-8<br>LC_CTYPE=&quot;zh_CN.UTF-8&quot;<br>LC_NUMERIC=&quot;zh_CN.UTF-8&quot;<br>LC_TIME=&quot;zh_CN.UTF-8&quot;<br>LC_COLLATE=&quot;zh_CN.UTF-8&quot;<br>LC_MONETARY=&quot;zh_CN.UTF-8&quot;<br>LC_MESSAGES=&quot;zh_CN.UTF-8&quot;<br>LC_PAPER=&quot;zh_CN.UTF-8&quot;<br>LC_NAME=&quot;zh_CN.UTF-8&quot;<br>LC_ADDRESS=&quot;zh_CN.UTF-8&quot;<br>LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;<br>LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;<br>LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;<br>LC_ALL=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询系统的默认语系(下次重启之后系统所使用的语系)</span><br>[root@localhost src]# cat /etc/sysconfig/i18n <br>LANG=&quot;zh_CN.UTF-8&quot;<br></code></pre></td></tr></table></figure><h3 id="三-位置参数变量"><a href="#三-位置参数变量" class="headerlink" title="(三) 位置参数变量"></a>(三) 位置参数变量</h3><p>这种变量主要是用来向脚本当中传递参数或数据的, 变量名不能自定义, 变量作用是固定的; <strong>只有内容可以自定义</strong></p><table><thead><tr><th>位置参数变量</th><th>作用</th></tr></thead><tbody><tr><td><code>$n</code></td><td>n 为数字, $0 代表命令本身, $1-$9 代表第一到第九个参数, <strong>十以上的参数需要用大括号包含, 如${10}</strong></td></tr><tr><td><code>$*</code></td><td>这个变量代表命令行中所有的参数, <strong><code>$*</code>把所有的参数看成一个整体</strong></td></tr><tr><td><code>$@</code></td><td>这个变量也代表命令行中所有的参数, 不过**<code>$@</code>把每个参数区分对待**</td></tr><tr><td><code>$#</code></td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table><h3 id="四-预定义变量"><a href="#四-预定义变量" class="headerlink" title="(四) 预定义变量"></a>(四) 预定义变量</h3><p>是 Bash 中已经定义好的变量, 变量名不能自定义, 变量作用也是固定的; <strong>只有内容可以自定义</strong></p><table><thead><tr><th>预定义变量</th><th>作 用</th></tr></thead><tbody><tr><td>$?</td><td>最后一次执行的命令的返回状态。<br />如果这个变量的值为 0, 证明上一个命令正确执行；<br />如果这个变量的值为非 0(具体是哪个数, 由命令<br/>自己来决定), 则证明上一个命令执行不正确了</td></tr><tr><td>$$</td><td>当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号(PID)</td></tr></tbody></table><h2 id="四-通配符和正则表达式"><a href="#四-通配符和正则表达式" class="headerlink" title="四 : 通配符和正则表达式"></a>四 : 通配符和正则表达式</h2><h3 id="一-通配符"><a href="#一-通配符" class="headerlink" title="(一) 通配符"></a>(一) 通配符</h3><table><thead><tr><th>通配符</th><th>作 用</th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>匹配一个任意字符</td><td></td></tr><tr><td>*</td><td>匹配 0 个或任意多个任意字符, 也就是可以匹配任何内容</td><td></td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符</td><td><code>[abc]</code> 代表一定匹配一个字符, 或者是 a, 或者是 b, 或者是 c</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符, <code>-</code>代表一个范围</td><td><code>[a-z]</code>代表匹配一个小写字母。</td></tr><tr><td>[^]</td><td>逻辑非, 表示匹配不是中括号内的一个字符</td><td><code>[^0-9]</code>代表匹配一个不是数字的字符</td></tr></tbody></table><h3 id="二-正则表达式-regex"><a href="#二-正则表达式-regex" class="headerlink" title="(二) 正则表达式(regex)"></a>(二) 正则表达式(regex)</h3><table><thead><tr><th>元字符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>前一个字符匹配 <strong>0 次或任意多次</strong></td><td><code>aa*</code> 查询a出现1次及以上</td></tr><tr><td><code>.</code></td><td>匹配除了换行符外<strong>任意一个</strong>字符</td><td><code>s..d</code> 会匹配在s和d这两个字母之间一定有两个字符的单词</td></tr><tr><td><code>^</code></td><td>匹配<strong>行首</strong></td><td><code>^hello</code> 会匹配以 hello 开头的行</td></tr><tr><td>$</td><td>匹配<strong>行尾</strong></td><td><code>hello$</code> 会匹配以 hello 结尾的行</td></tr><tr><td><code>[]</code></td><td>匹配中括号中指定的<strong>任意一个</strong>字符, 只匹配一个字符</td><td><code>[aeiou]</code> 匹配任意一个元音字母, <code>[0-9]</code> 匹配任意一位数字, <code>[a-z][0-9]</code>匹配小写字和一位数字构成的两位字符</td></tr><tr><td><code>[^]</code></td><td>匹配除中括号的字符以外的任意一个字符。</td><td><code>[^0-9]</code> 匹配任意一位非数字字符, <code>[^a-z]</code>表示任意一位非小写字母</td></tr><tr><td><code>\</code></td><td>转义符。用于取消特殊符号的含义</td><td><code>\.$</code> 查找以字符 <code>.</code> 结尾的行</td></tr><tr><td><code>\&#123;n\&#125;</code></td><td>表示其前面的字符恰好出现 n 次</td><td><code>[0-9]\&#123;4\&#125;</code> 匹配 4 位数字, <code>[1][3-8][0-9]\&#123;9\&#125;</code> 匹配手机号码</td></tr><tr><td><code>\&#123;n,\&#125;</code></td><td>表示其前面的字符出现不小于 n 次</td><td><code>[0-9]\&#123;2,\&#125;</code> 表示两位及以上的数字</td></tr><tr><td><code>\&#123;n,m\&#125;</code></td><td>表示其前面的字符至少出现n次, 最多出现m次</td><td><code>[a-z]\&#123;6,8\&#125;</code> 匹配 6~8 位的小写字母</td></tr></tbody></table><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="(三) 总结"></a>(三) 总结</h3><p>通常 : 正则表达式和通配符使用的场景是不同的</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>正则表达式</td><td>用来在<strong>文件内容</strong>中匹配符合条件的字符串</td></tr><tr><td>通配符</td><td>用来匹配符合条件的<strong>文件名</strong></td></tr></tbody></table><p>其实这种区别只在 Shell 当中适用, 因为用来在文件当中搜索字符串的命令, 如 <code>grep</code>, <code>awk</code>, <code>sed</code> 等命令可以<strong>支持正则</strong>表达式; 而在系统当中搜索文件的命令, 如 <code>ls</code>, <code>find</code>, <code>cp</code> 这些命令<strong>不支持正则</strong>表达式, 所以只能使用 shell 自己的通配符来进行匹配了</p><h2 id="五-常用指令"><a href="#五-常用指令" class="headerlink" title="五 : 常用指令"></a>五 : 常用指令</h2><p><code>grep</code>, <code>awk</code>, <code>sed</code> 也被称为Linux三剑客, <strong>grep主打查找功能</strong>，<strong>sed主要是编辑</strong>，<strong>awk主要是分割处理</strong>; 基础中的基础, 重点中的重点</p><h3 id="一-行提取-grep"><a href="#一-行提取-grep" class="headerlink" title="(一) 行提取 grep"></a>(一) 行提取 grep</h3><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# grep [选项] &quot;搜索内容&quot; 文件名<br>选项:<br>    -A 数字: 列出符合条件的行,并列出后续的n行 <br>    -B 数字: 列出符合条件的行,并列出前面的n行 <br>    -c: 统计找到的符合条件的字符串的次数<br>    -i: 忽略大小写<br>    -n: 输出行号<br>    -v: 反向查找<br>    --color=auto 搜索出的关键字用颜色显示<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找用户信息文件/etc/passwd 中, 有多少可以登录的用户</span><br>[root@localhost ~]# grep &quot;/bin/bash&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找包含有<span class="hljs-string">&quot;root&quot;</span>的行, 并列出后续的3行</span><br>[root@localhost ~]# grep -A 3 &quot;root&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找可以登录的用户, 并显示行号</span><br>[root@localhost ~]# grep -n &quot;/bin/bash&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找不含有<span class="hljs-string">&quot;/bin/bash&quot;</span>的行, 其实就是列出所有的伪用户</span><br>[root@localhost ~]# grep -v &quot;/bin/bash&quot; /etc/passwd <br></code></pre></td></tr></table></figure><h3 id="二-文本截取-awk"><a href="#二-文本截取-awk" class="headerlink" title="(二) 文本截取 awk"></a>(二) 文本截取 awk</h3><p><code>awk</code> 是一个强大的文本分析工具, 相对于 <code>grep</code> 的查找, <code>sed</code> 的编辑, <code>awk</code> 在其<strong>对数据分析并生成报告</strong>时, 显得尤为强大。</p><p>简单来说<code>awk</code> 就是把文件<strong>逐行的读入</strong>, <strong>以空格</strong>为默认分隔符<strong>将每行切片</strong>, 切开的部分再进行各种分析处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;…&#x27; 文件名<br>条件(Pattern) : <br>    x &gt; 10 : 判断变量 x 是否大于 10<br>    x == y : 判断变量 x 是否等于变量 y<br>    A ~ B : 判断字符串 A 中是否包含能匹配 B 表达式的子字符串<br>    A !~ B : 判断字符串 A 中是否不包含能匹配 B 表达式的子字符串<br>动作(Action) : <br>    格式化输出<br>    流程控制语句<br></code></pre></td></tr></table></figure><p>awk 提供了一些内置变量</p><table><thead><tr><th>awk 内置变量</th><th>作用</th></tr></thead><tbody><tr><td><strong>$0</strong></td><td>代表目前 awk 所读入的整行数据。我们已知 awk 是一行一行读入数据的, $0 就代表当前读入行的整行数据</td></tr><tr><td><strong>$n</strong></td><td>代表目前读入行的第 n 个字段</td></tr><tr><td><strong>NF</strong></td><td>当前行拥有的字段(列)总数</td></tr><tr><td><strong>NR</strong></td><td>当前 awk 所处理的行, 是总数据的第几行</td></tr><tr><td><strong>FS</strong></td><td>用户定义分隔符。awk 的默认分隔符是任何空格, 如果想要使用其他分隔符(如” : “), 就需要 <code>FS</code> 变量定义</td></tr><tr><td>ARGC</td><td>命令行参数个数</td></tr><tr><td>ARGV</td><td>命令行参数数组</td></tr><tr><td>FNR</td><td>当前文件中的当前记录数(对输入文件起始为 1)</td></tr><tr><td>OFMT</td><td>数值的输出格式(默认为%.6g)</td></tr><tr><td>OFS</td><td>输出字段的分隔符(默认为空格)</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认为换行符)</td></tr><tr><td>RS</td><td>输入记录分隔符(默认为换行符)</td></tr></tbody></table><p>简单代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出第1列和第3列</span><br>[root@localhost ~]# df -h | awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询可以登录的用户的用户名和 UID</span><br>[root@localhost ~]# awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3 &#125;&#x27; /etc/passwd<br></code></pre></td></tr></table></figure><p>awk 还提供了保留字, 保留字可以看作是<u>条件的一种</u>, 必须大写</p><table><thead><tr><th>保留字</th><th>说明</th></tr></thead><tbody><tr><td><code>BEGIN</code></td><td>在 awk 程序一开始时,尚未读取任何数据之前执行; BEGIN 后的动作只在程序开始时执行一次</td></tr><tr><td><code>END</code></td><td>在 awk 程序处理完所有数据,即将结束时执行; END 后的动作只在程序结束时执行一次</td></tr></tbody></table><p>保留字代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">BEGIN和END都只会执行一次</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;开始&quot;&#125; &#123;print $1 &quot;:&quot; $3&#125; END&#123;print &quot;完毕&quot;&#125;&#x27; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行,所以这个命令的换行不用加入<span class="hljs-string">&quot;\&quot;,就是一行命令</span></span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;统计开始:&quot;&#125; <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">&#123;print &quot;</span>系统分区<span class="hljs-string">&quot; <span class="hljs-variable">$1</span> &quot;</span>已使用:<span class="hljs-string">&quot; <span class="hljs-variable">$3</span>&#125; END&#123;print &quot;</span>统计完毕<span class="hljs-string">&quot;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>awk 的条件 : 关系运算符</p><table><thead><tr><th>条件</th><th>说明</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于。用于判断两个值是否相等,如果是给变量赋值,请使用<code>=</code>号</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>A~B</td><td>判断字符串 A 中是否包含能匹配 B 表达式的子字符串, 比字符串要加 <code>//</code>, 例如 : <code>$2 ~ /shell/</code></td></tr><tr><td>A!~B</td><td>判断字符串 A 中是否不包含能匹配 B 表达式的子字符串</td></tr></tbody></table><p>条件示例代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出使用大于0的分区及使用情况</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;$3&gt;0&#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出vda的使用情况</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;$1 ~ /vda/ &#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果在//中可以写入字符,也可以支持正则表达式,查询包含有vda的行,并打印第一字段和第五字段</span><br>[root@localhost ~]# df -h | awk &#x27;/vda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125; &#x27;<br></code></pre></td></tr></table></figure><p>awk 流程控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">统计 PHP 成绩的总分</span> <br>[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; <br>NR==3&#123;php2=$3&#125; <br>NR==4&#123;php3=$3;totle=php1+php2+php3;print &quot;totle php is &quot; totle&#125;&#x27; awk_test.txt<br></code></pre></td></tr></table></figure><p><code>awk</code> 编程也允许在编程时使用函数(不常用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义函数<span class="hljs-built_in">test</span>,包含两个参数,函数体的内容是输出这两个参数的值</span><br>[root@localhost ~]# awk &#x27;function test(a,b) &#123; printf a &quot;\t&quot; b &quot;\n&quot; &#125; <br><span class="hljs-meta prompt_">#</span><span class="language-bash">调用函数 <span class="hljs-built_in">test</span>,并向两个参数传递值</span><br>&#123; test($2,$6) &#125; &#x27; student.txt<br></code></pre></td></tr></table></figure><p>awk 调用脚本<code>(-f)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编写脚本</span><br>[root@localhost ~]# vi pass.awk<br>BEGIN &#123;FS=&quot;:&quot;&#125;<br>&#123; print $1 &quot;\t&quot; $3&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用脚本 -f</span><br>[root@localhost ~]# awk -f pass.awk /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>在 <code>awk</code> 编程中,因为命令语句非常长, 在输入格式时需要注意以下内容 :</strong> </p><ul><li>多个 <code>条件&#123;动作&#125;</code> 可以用空格分割, 也可以用回车分割</li><li>在一个动作中, 如果需要执行多个命令, 需要用 <code>;</code> 分割, 或用回车分割</li><li>在 <code>awk</code> 中, 变量的赋值与调用都不需要加入 <code>$</code> 符</li><li>条件中判断两个值是否相同, 请使用<code>==</code>, 以便和变量赋值进行区分</li></ul><h3 id="三-文本操作-sed"><a href="#三-文本操作-sed" class="headerlink" title="(三) 文本操作 sed"></a>(三) 文本操作 sed</h3><p><code>sed</code> 主要是用来将数据进行<strong>选取</strong>, <strong>替换</strong>, <strong>删除</strong>, <strong>新增</strong>的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...<br>选项 : <br>    -n : 把经过sed处理的结果输出到屏幕(只查看sed命令操作的数据,如果不加则把所有数据都输出到屏幕)。<br>    -e : 允许对输入数据应用多条sed命令编辑,中间用&quot;;&quot;隔开。<br>    -r :  在 sed 中支持扩展正则表达式。<br>    -i :  用 sed 的修改结果直接修改读取数据的文件,而不是由屏幕输出<br>    -f 脚本文件名 : 从 sed 脚本中读入 sed 操作。和 awk 命令的 -f 非常类似。<br>动作 : <br>    a \ : 追加(append),在当前行后添加一行或多行; 添加多行时,除最后一行外,每行末尾需要用&quot;\&quot;代表数据未完结。<br>    c \ : 行替换(replace),用 c 后面的字符串替换原数据行; 替换多行时,除最后一行外,每行末尾需用&quot;\&quot;代表数据未完结<br>    i \ : 插入(insert),在当期行前插入一行或多行; 插入多行时,除最后一行外每行末尾需要用&quot;\&quot;代表数据未完结<br>    d :  删除(delete),删除指定的行<br>    p :  打印(print),输出指定的行<br>    s :  字串替换,用一个字符串替换另外一个字符串;格式为&quot;行范围s/旧字串/新字串/&quot;(和vim中的替换格式类似)<br></code></pre></td></tr></table></figure><ul><li><strong>注意 :</strong> <code>sed</code> 所做的修改并<strong>不会直接改变文件的内容</strong>(如果是用管道符接收的命令的输出,这种情况连文件都没有), 而是把修改结果只显示到屏幕上, <strong>除非使用 <code>-i</code> 选项才会直接修改文件</strong>。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印第二行</span><br>[root@localhost ~]# sed -n &#x27;2p&#x27; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除第二行到第四行的数据,但是文件本身并不会发生改变</span><br>[root@localhost ~]# sed &#x27;2,4d&#x27; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在第二行后加入hello</span><br>[root@localhost ~]# sed &#x27;2a hello&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果需要多插几行,则需要用\换行</span><br>[root@localhost ~]# sed &#x27;2a hello \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">world<span class="hljs-string">&#x27; /etc/passwd</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">在第二行前插入hello,如果需要插入多行也需要\</span></span><br><span class="hljs-string"><span class="language-bash">[root@localhost ~]# sed &#x27;</span>2i hello<span class="hljs-string">&#x27; /etc/passwd</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行数据替换掉</span></span><br>[root@localhost ~]# sed &#x27;2c hello world&#x27; /etc/passwd <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行的bin替换成hello</span></span><br>[root@localhost ~]# sed &#x27;2s/bin/hello/&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行注释掉</span></span><br>[root@localhost ~]# sed &#x27;2s/^/#/&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行和第四行注释掉,用;隔开</span></span><br>[root@localhost ~]# sed &#x27;2s/bin/hello/;3s/daemon/world/&#x27; /etc/passwd<br></code></pre></td></tr></table></figure><h3 id="四-列提取-cut"><a href="#四-列提取-cut" class="headerlink" title="(四) 列提取 cut"></a>(四) 列提取 cut</h3><p>cut 命令的默认分隔符是制表符, 也就是 <code>tab</code> 键, <strong>不支持空格</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cut OPTION... [FILE]...<br>选项 : <br>-f column_number : 提取第几列<br>-d separate : 按照指定分隔符分割列(默认分隔符是制表符)<br>-c number : 不依赖分隔符来区分列,而是通过字符范围(行首为0)来进行字段提取(了解)<br>&quot;n-&quot;表示从第n个字符到行尾; <br>&quot;n-m&quot;从第n个字符到第m个字符; <br>&quot;-m&quot;表示从第1个字符到第m个字符。<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">提取第二列内容</span><br>[root@localhost ~]# cut -f 2 test.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">那如果想要提取多列呢? 只要列号直接用<span class="hljs-string">&quot;,&quot;</span>分开</span><br>[root@localhost ~]# cut -f 2,3 cut_test.txt <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询普通用户的用户名和用户ID</span><br>[yuelu@localhost ~]$ grep &quot;/bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1,3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照字符进行提取,c表示character,后面跟表达式,8-代表的是提取所有行的第8个字符开始到行尾(10-20代表提取所有行的第10个字符到第20个字符,-8代表提取所有行从行首到第8个字符)</span> <br>[root@localhost ~]# cut -c 8- cut_test.txt <br></code></pre></td></tr></table></figure><h3 id="五-排序命令-sort"><a href="#五-排序命令-sort" class="headerlink" title="(五) 排序命令 sort"></a>(五) 排序命令 sort</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# sort [选项] 文件名<br>选项 : <br>-f :  忽略大小写<br>-b :  忽略每行前面的空白部分<br>-n :  以数值型进行排序,默认使用字符串型排序<br>-r :  反向排序<br>-u :  删除重复行。就是 uniq 命令<br>-t :  指定分隔符,默认是分隔符是制表符<br>-k n[,m] :  按照指定的字段范围排序。从第n字段开始,m字段结束(默认到行尾)<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序用户信息文件,默认是用每行开头第一个字符来进行排序</span><br>[root@localhost ~]# sort /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">反向排序-r</span><br>[root@localhost ~]# sort -r /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定分隔符是<span class="hljs-string">&quot;:&quot;</span>,排序范围是第三个(用第三字段开头,第三字段结尾排序)</span><br>[root@localhost ~]# sort -t &quot;:&quot; -k 3,3 /etc/passwd<br></code></pre></td></tr></table></figure><h3 id="六-去重命令-uniq"><a href="#六-去重命令-uniq" class="headerlink" title="(六) 去重命令 uniq"></a>(六) 去重命令 uniq</h3><p><code>uniq</code> 命令是用来取消重复行的命令, 其实和 <code>sort -u</code> 选项是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# uniq [选项] 文件名<br>选项 : <br>-i :  忽略大小写<br></code></pre></td></tr></table></figure><h3 id="七-统计命令-wc"><a href="#七-统计命令-wc" class="headerlink" title="(七) 统计命令 wc"></a>(七) 统计命令 wc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# wc [选项] 文件名<br>选项 : <br>    -l : 只统计行数(print the newline counts)<br>    -w : 只统计单词数(print the word counts)<br>    -m : 只统计字符数(print the character counts)<br>    -c : print the byte counts<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器内存占用过高</title>
    <link href="/2023/01/20/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"/>
    <url>/2023/01/20/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-故障现象"><a href="#一-故障现象" class="headerlink" title="一 : 故障现象"></a>一 : 故障现象</h2><ul><li>服务器内存占用过高, 导致死机</li><li>服务器硬重启 3-5 天再次占满</li></ul><h2 id="二-问题排查"><a href="#二-问题排查" class="headerlink" title="二 : 问题排查"></a>二 : 问题排查</h2><ol><li><code>cpu</code> 使用率 : <code>top</code></li><li>定时任务 <code>crontab -l</code></li><li>文件的读取和写入 : <code>ftp</code>, <code>log</code></li></ol><h2 id="三-解决方案"><a href="#三-解决方案" class="headerlink" title="三 : 解决方案"></a>三 : 解决方案</h2><h3 id="一-手动清理"><a href="#一-手动清理" class="headerlink" title="(一) 手动清理"></a>(一) 手动清理</h3><ul><li><p>可手动清理页文件缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free pagecache:</span><br>echo 1 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li><li><p>清理可回收 slab 对象(slab 分配算法采用 cache 存储内核对象, 当需要内核数据结构的对象时, 可以直接从cache 上直接获取, 并将对象初始化为使用) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free reclaimable slab objects (includes dentries and inodes):</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">reclaimable: 可回收</span><br>echo 2 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li><li><p>清理 slab 对象和 pagecache</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free slab objects and pagecache:</span><br>echo 3 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-设置最低剩余内存"><a href="#二-设置最低剩余内存" class="headerlink" title="(二) 设置最低剩余内存"></a>(二) 设置最低剩余内存</h3><ul><li><p>修改 sysctl.conf 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加入一行</span><br>vm.min_free_kbytes = 2097152<br></code></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -p</span><br></code></pre></td></tr></table></figure></li><li><p>第一种方法直接清空缓存, 可能会造成数据丢失, 我们选用第二种</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arthas</title>
    <link href="/2023/01/13/arthas/"/>
    <url>/2023/01/13/arthas/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><h3 id="一-概述-1"><a href="#一-概述-1" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p><code>Arthas</code> 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p><h3 id="二-背景"><a href="#二-背景" class="headerlink" title="(二) 背景"></a>(二) 背景</h3><p>通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 <code>IDE</code> 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。</p><p>开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。</p><p>如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 <code>JVM</code> 重新启动，它可能无法复现，如上文所述。</p><p><code>Arthas</code> 旨在解决这些问题。开发人员可以在线解决生产问题。无需 <code>JVM</code> 重启，无需代码更改。 <code>Arthas</code> 作为观察者永远不会暂停正在运行的线程。</p><h3 id="三-用途"><a href="#三-用途" class="headerlink" title="(三) 用途"></a>(三) 用途</h3><p><code>Arthas</code> 是 Alibaba 开源的 Java 诊断工具。当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li><li>怎样直接从 JVM 内查找某个类的实例？</li></ol><h2 id="二-快速入门"><a href="#二-快速入门" class="headerlink" title="二 : 快速入门"></a>二 : 快速入门</h2><h3 id="一-下载启动"><a href="#一-下载启动" class="headerlink" title="(一) 下载启动"></a>(一) 下载启动</h3><ul><li><p>下载 jar 包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl -O https://arthas.aliyun.com/arthas-boot.jar<br></code></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行该程序的用户需要和目标进程具有相同的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以执行如下命令来查看帮助</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar -h</span><br></code></pre></td></tr></table></figure></li><li><p>选择应用 : 数据对应程序的编号, 然后回车即可</p></li><li><p>未进入指定程序退出 : <code>ctrl + c</code></p></li><li><p>进入指定程序后退出 : <code>ctrl + d</code></p></li></ul><h3 id="二-常用操作"><a href="#二-常用操作" class="headerlink" title="(二) 常用操作"></a>(二) 常用操作</h3><ul><li><p>dashboard : 选择指定程序后, 输入 <code>dashboard</code> 后回车, 即可进入看板, 按 <code>ctrl+c </code>可以中断执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ dashboard<br></code></pre></td></tr></table></figure><ul><li>主要涉及到当前执行的线程, 内存情况和运行环境</li></ul></li><li><p>thread : 查看当前线程, 命令 : <code>thread ID</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ thread 1 | grep <span class="hljs-string">&#x27;main(&#x27;</span><br>    at demo.MathGame.main(MathGame.java:17)<br></code></pre></td></tr></table></figure></li><li><p>jad : 反编译工具, 通过 jad 来反编译 Main Class</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ jad demo.MathGame<br></code></pre></td></tr></table></figure></li><li><p>watch : 查看具体函数的参数和返回值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ watch demo.MathGame primeFactors returnObj<br></code></pre></td></tr></table></figure></li></ul><h3 id="三-退出"><a href="#三-退出" class="headerlink" title="(三) 退出"></a>(三) 退出</h3><ul><li>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</li><li>如果想完全退出 arthas，可以执行<code>stop</code>命令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诊断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql数据统计</title>
    <link href="/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-库表结构"><a href="#一-库表结构" class="headerlink" title="一 : 库表结构"></a>一 : 库表结构</h2><ul><li><p>MySQL 的 information_schema 数据库, 保存着数据库的容量和使用信息, 可查询数据库中每个表占用的空间, 表记录的行数</p></li><li><p>TABLES 表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> `TABLES` (<br>  `TABLE_CATALOG` <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_SCHEMA` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_NAME` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_TYPE` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `ENGINE` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `VERSION` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `ROW_FORMAT` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_ROWS` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `AVG_ROW_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `DATA_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `MAX_DATA_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `INDEX_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `DATA_FREE` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `AUTO_INCREMENT` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CREATE_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `UPDATE_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CHECK_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_COLLATION` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CHECKSUM` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CREATE_OPTIONS` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_COMMENT` <span class="hljs-type">varchar</span>(<span class="hljs-number">2048</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span><br>) ENGINE<span class="hljs-operator">=</span>MEMORY <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure></li><li><p>重点字段说明</p><table><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td>TABLE_SCHEMA</td><td>数据库名</td></tr><tr><td>TABLE_NAME</td><td>表名</td></tr><tr><td>ENGINE</td><td>存储引擎</td></tr><tr><td>TABLE_ROWS</td><td>记录数</td></tr><tr><td>DATA_LENGTH</td><td>数据大小(单位B)</td></tr><tr><td>INDEX_LENGTH</td><td>索引大小</td></tr></tbody></table></li></ul><h2 id="二-查询示例"><a href="#二-查询示例" class="headerlink" title="二 : 查询示例"></a>二 : 查询示例</h2><h3 id="一-数据总占用量"><a href="#一-数据总占用量" class="headerlink" title="(一) 数据总占用量"></a>(一) 数据总占用量</h3><ul><li><p>求和 &#x3D;&gt; 单位转换 &#x3D;&gt; 加单位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>concat(round(<span class="hljs-built_in">sum</span>(DATA_LENGTH<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>),<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;GB&#x27;</span>) <span class="hljs-keyword">as</span> data <br><span class="hljs-keyword">from</span> information_schema.TABLES<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-每个表占用量"><a href="#二-每个表占用量" class="headerlink" title="(二) 每个表占用量"></a>(二) 每个表占用量</h3><ul><li><p>table_name, table_rows, data_length</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>table_name, <br>concat(round(<span class="hljs-built_in">sum</span>(data_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>),<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;G&#x27;</span>) <span class="hljs-keyword">as</span> data <br><span class="hljs-keyword">from</span> information_schema.tables <br><span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbname&#x27;</span> <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> table_name <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> data <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式消息中间件设计</title>
    <link href="/2020/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-什么是分布式消息中间件"><a href="#一-什么是分布式消息中间件" class="headerlink" title="一 : 什么是分布式消息中间件"></a>一 : 什么是分布式消息中间件</h2><p>单体架构</p><pre><code class=" mermaid">flowchart LRsubgraph A[XX商城系统]商品会员订单登录注册...endA --&gt; B[(数据库)]</code></pre><p>分布式系统架构 : 一个请求后台多系统协同处理</p><pre><code class=" mermaid">flowchart LRA[前端系统] --&gt; B[订单系统]B &lt;-.相互调用.-&gt; CA --&gt; C[会员系统]B --&gt; D[(数据库)]C --&gt; E((缓存)) --&gt; D</code></pre><p>基于消息中间件的分布式系统架构</p><pre><code class=" mermaid">graph LRA[前端系统] --发送注册消息--&gt; B&#123;消息中间件&#125;A[前端系统] --创建订单消息--&gt; B&#123;消息中间件&#125;A[前端系统] --发送支付消息--&gt; B&#123;消息中间件&#125;B --接收注册消息--&gt; C[会员系统]B --接收订单消息--&gt; D[订单系统]B --接收支付消息--&gt; E[支付系统]</code></pre><h3 id="一-消息中间件概述"><a href="#一-消息中间件概述" class="headerlink" title="(一) 消息中间件概述"></a>(一) 消息中间件概述</h3><p>什么是消息中间件</p><ul><li>利用高效可靠的消息传递机制进行平台无关的数据交流;</li><li>并基于数据通信来进行分布式系统的集成;</li><li>通过提供消息传递和消息排队模型, 它可以在分布式环境下扩展进程间的通信;</li></ul><p>消息中间件的应用场景</p><ul><li>跨系统数据传递</li><li>高并发流量削峰</li><li>数据异步处理…等等</li></ul><p>常用的消息中间件</p><ul><li>ActiveMQ, RabbitMQ, kafka, RocketMQ</li></ul><h3 id="二-消息中间件核心设计"><a href="#二-消息中间件核心设计" class="headerlink" title="(二) 消息中间件核心设计"></a>(二) 消息中间件核心设计</h3><ul><li>本质<ul><li>一种具备接收请求, 保存数据, 发送数据等功能的网络应用</li><li>和一般网络应用程序的区别是它主要负责数据的接收和传递, 所以性能一般都高于普通程序</li></ul></li><li>5大核心组成<ul><li>协议</li><li>持久化机制</li><li>消息分发机制</li><li>高可用设计</li><li>高可靠设计</li></ul></li></ul><h2 id="二-协议"><a href="#二-协议" class="headerlink" title="二 : 协议"></a>二 : 协议</h2><h3 id="一-协议是什么"><a href="#一-协议是什么" class="headerlink" title="(一) 协议是什么"></a>(一) 协议是什么</h3><p>协议是计算机之间通信时共同遵从的一组约定, 都遵守相同的约定, 计算机之间才能相互交流; </p><p>是对数据格式和计算机之间交换数据时必须遵守的规则的正式描述</p><p><strong>协议三要素 :</strong> </p><ol><li>语法 : 即数据与控制信息的结构或格式</li><li>语义 : 即需要发出何种控制信息, 完成何种动作以及做出何种响应</li><li>时许(同步) : 即事件实现顺序的详细说明</li></ol><p><strong>举例 : Http 协议三要素</strong> </p><ol><li>语法 : http 规定了请求报文和响应报文的具体格式</li><li>语义 : 客户端主动发起的操作称为请求</li><li>时序 : 一个请求对应一个响应</li></ol><h3 id="二-消息中间件常见协议"><a href="#二-消息中间件常见协议" class="headerlink" title="(二) 消息中间件常见协议"></a>(二) 消息中间件常见协议</h3><p><strong>OpenWire :</strong> ActiveMQ专属</p><p><strong>AMQP :</strong> Advanced Message Queuing Protocol, 高级消息队列协议, 2004 年 JPMorgan Chase (摩根大通集团)联合其他公司共同设计</p><ul><li><strong>特性 :</strong> 事务支持, 持久化支持, 出生金融行业, 在可靠性消息处理上具备天然的优势</li><li>代表产品 : ActiveMQ, RabbitMQ</li></ul><p><strong>MQTT :</strong> Message Queuing Telemrtry Transport, 消息队列遥测传输, 是IBM开发的一个即时通讯协议, 物联网系统架构中的重要组成部分</p><ul><li><strong>特性 :</strong> 轻量, 结构简单, 传输快, 没有事务支持, 没有持久化相关设计</li><li><strong>应用场景 :</strong> 适用于计算能力有限, 低带宽, 网络不稳定的场景</li><li>代表产品 : ActiveMQ, RabbitMQ</li></ul><p><strong>Kafka :</strong> 基于 TCP 的二进制协议; 消息内部是通过长度来分割, 由一些基本数据类型组成</p><ul><li><strong>特性 :</strong> 结构简单, 解析快, 无事务设计, 有持久化设计</li></ul><p><strong>OpenMessae :</strong> 近一两年由阿里发起, 与雅虎, 滴滴出行, Streamlio 等公司共同参与创立的分布式消息中间件, 流处理领域的应用开发标准; 是<strong>国内首个</strong>在全球范围内发起的分布式消息领域国际标准</p><ul><li><strong>特性 :</strong> 结构简单, 解析快, 有事务设计, 有持久化设计</li><li>代表产品 : Apache RocketMQ</li></ul><p><strong>问题 : 为什么消息中间件不直接使用 Http 协议 ?</strong></p><ol><li>首先 http 的内容很多,请求报文和响应报文很复杂</li><li>http 大部分情况都是短连接, 不利于消息中间件的场景, 消息中间件要求客户端长期的获取信息或者是往消息中间件中发送数据</li></ol><h2 id="三-持久化"><a href="#三-持久化" class="headerlink" title="三 : 持久化"></a>三 : 持久化</h2><h3 id="一-持久化是什么"><a href="#一-持久化是什么" class="headerlink" title="(一) 持久化是什么"></a>(一) 持久化是什么</h3><p>简单来说就是数据存入磁盘, 而不是存在内存中随服务重启而消失, 使数据能够永久保存叫做持久化</p><pre><code class=" mermaid">graph LRA[前台系统] --&gt; B&#123;消息中间件&#125; --&gt; C[订单系统]B --- D((&quot;磁盘&lt;br&gt;(持久存储)&quot;))</code></pre><h3 id="二-常用持久化方式"><a href="#二-常用持久化方式" class="headerlink" title="(二) 常用持久化方式"></a>(二) 常用持久化方式</h3><ul><li><p>文件系统和数据库, 举例说明</p><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>文件系统</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>&#x2F;</td><td>&#x2F;</td><td>&#x2F;</td></tr></tbody></table></li></ul><h2 id="四-消息分发"><a href="#四-消息分发" class="headerlink" title="四 : 消息分发"></a>四 : 消息分发</h2><h3 id="一-为什么要有消息分发策略"><a href="#一-为什么要有消息分发策略" class="headerlink" title="(一) 为什么要有消息分发策略"></a>(一) 为什么要有消息分发策略</h3><p><strong>业务场景一 :</strong> 前台系统创建订单, 然后传递数据到消息中间件, 那这条消息要给后端的哪个系统呢? 因为一个消息中间件会有多个子系统进行连接, 这个时候就<strong>需要有消息分发策略, 根据什么策略将消息分发给一个正确的系统</strong>; 例如订单系统要接收订单消息, 而购物车系统和用户系统就不需要接收</p><pre><code class=" mermaid">graph LRA[前台系统] --创建订单--&gt; B&#123;消息中间件&#125; --订单消息--&gt; C[订单系统]B --订单消息--&gt; 购物车系统B --订单消息--&gt; 用户系统</code></pre><p><strong>业务场景二 :</strong> 下了订单要支付, 支付会有一个支付成功或者失败的消息, 支付失败之后, 可能由于支付系统处理发生失败, 这个时候需要有重试的机制, 我们要求<strong>不仅可以正确的分发, 还要求能够支持重发</strong></p><pre><code class=" mermaid">graph LRA[前台系统] --支付--&gt; B[消息中间件] B --支付消息--&gt; C[支付系统]C --失败--&gt; B</code></pre><h3 id="二-常用的消息中间件分发策略"><a href="#二-常用的消息中间件分发策略" class="headerlink" title="(二) 常用的消息中间件分发策略"></a>(二) 常用的消息中间件分发策略</h3><p>发布订阅, 轮询分发, 公平分发, 重发, 消息拉取</p><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>公平分发</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>&#x2F;</td><td>支持</td></tr><tr><td>消息拉取</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="五-高可用"><a href="#五-高可用" class="headerlink" title="五 : 高可用"></a>五 : 高可用</h2><h3 id="一-高可用机制"><a href="#一-高可用机制" class="headerlink" title="(一) 高可用机制"></a>(一) 高可用机制</h3><p><strong>高可用性</strong>是指产品在规定的条件和规定的时刻或时间区间内处于可执行规定功能状态的能力</p><p>当业务量大时, 一台消息中间件服务器可能无法满足需求, 所以需要消息中间件能够集群部署, 来达到高可用的目的</p><h3 id="二-实现方式"><a href="#二-实现方式" class="headerlink" title="(二) 实现方式"></a>(二) 实现方式</h3><p>Master-Slave 主从共享数据的部署方式</p><pre><code class=" mermaid">graph BTB1[Broker1 Master] --&gt; A[&quot;消息存储&lt;br&gt;(文件系统/数据库...)&quot;]B2[Broker2 Slave] --&gt; AB3[Broker3 Slave] --&gt; AC1[Client] --&gt; B1C2[Client] --&gt; B1</code></pre><p>Master-Slave 主从同步部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; C1subgraph C[ ]subgraph C1[broker1-master]C11[消息数据]endsubgraph C2[broker2-slave]C21[&quot;消息数据&lt;br&gt;(副本)&quot;]endsubgraph C3[broker3-slave]C31[&quot;消息数据&lt;br&gt;(副本)&quot;]endC1 -.-&gt; C2C1 -.-&gt; C3endC2 --&gt; D[消费者]C3 --&gt; E[消费者]</code></pre><p>Broker-Cluster 多主集群同步部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; C1subgraph C[ ]subgraph C1[broker1]C11[消息数据]endsubgraph C2[broker2]C21[&quot;消息数据&lt;br&gt;(副本)&quot;]endsubgraph C3[broker3]C31[&quot;消息数据&lt;br&gt;(副本)&quot;]endC1 -.-&gt; C2C1 -.-&gt; C3endC2 --&gt; D[消费者]C3 --&gt; E[消费者]</code></pre><p>Broker-Cluster 多主集群转发部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; Csubgraph C[broker1]C1[&quot;元数据&lt;br&gt;(队列内容)&quot;]endsubgraph D[broker2]D1[&quot;元数据&lt;br&gt;(队列内容)&quot;]endC &lt;-.转发数据&lt;br&gt;转发请求.-&gt; DD --&gt; E[消费者]</code></pre><p>Master-Slave 与 Broker-Cluster 结合</p><pre><code class=" mermaid">flowchart LRA1[Master1] --- B1[Slave1] --- C1[Slave1]  --- A1A2[Master2] --- B2[Slave2] --- C2[Slave2]  --- A2A3[Master3] --- B3[Slave3] --- C3[Slave3]  --- A3D[Load Balance] --&gt; A1D --&gt; A2D --&gt; A3E[Client] --&gt; D</code></pre><h2 id="六-高可靠"><a href="#六-高可靠" class="headerlink" title="六 : 高可靠"></a>六 : 高可靠</h2><p><strong>高可靠性</strong>是指系统可以无故障持续运行; 比如一个系统从来不崩溃, 报错, 或者崩溃, 报错的几率极低, 那就是高可靠</p><p>在高并发业务场景下, 如果不能保证系统的高可靠, 那造成的损失将会非常严重</p><p>保证消息中间件的高可靠性, 可以从以下几方面考虑 : </p><ul><li><strong>消息传输可靠 :</strong> 通过协议来保证系统间数据解析的正确性</li><li><strong>消息存储可靠 :</strong> 通过持久化来保证消息的存储可靠性</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>设计原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat参数调优</title>
    <link href="/2020/09/11/Tomcat%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/"/>
    <url>/2020/09/11/Tomcat%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一-参数调优"><a href="#一-参数调优" class="headerlink" title="一 : 参数调优"></a>一 : 参数调优</h2><table><thead><tr><th>配置项</th><th>解释</th><th>默认</th><th>建议</th><th>注意</th></tr></thead><tbody><tr><td>ConnectionTimeout</td><td>连接超时时间</td><td>20s</td><td>减少</td><td></td></tr><tr><td>maxThreads</td><td>处理连接的最大线程数</td><td>200</td><td>增加</td><td>不是越大越好</td></tr><tr><td>acceptCount(backlog)</td><td>等待接受accept的请求数量限制</td><td>100</td><td>增加</td><td>socket参数, min(accept, &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn)</td></tr><tr><td>maxConnections</td><td>最大连接处理数</td><td>nio:1w&#x2F;apr:8192</td><td>不变</td><td></td></tr></tbody></table><p>maxConnections : tomcat能够处理的最大连接数</p><p>acceptCount(backlog) : 当请求数超过 <code>maxConnections</code> 将会进入操作系统的等待区域 <code>acceptCount</code>, 这个值会取 <code>accept</code> 和 <code>/proc/sys/net/core/somaxconn</code> 中的最小值</p><pre><code class=" mermaid">graph LRRequest --&gt; AcceptCount --&gt; maxConnections --&gt; maxThreadssubgraph 总可受理连接数AcceptCountmaxConnectionsend</code></pre><h3 id="一-连接数调整"><a href="#一-连接数调整" class="headerlink" title="(一) 连接数调整"></a>(一) 连接数调整</h3><p>总共连接数 &#x3D; acceptCount+ connections</p><p>connections： Tomcat能接收的请求限制；</p><p>acceptCount： 超过Tomcat能接收的请求数以后，堆积在操作系统的数量(windows 和 linux 略有不同);</p><pre><code class=" mermaid">flowchart LRA[用户请求] --linux--&gt; B[Linux 操作系统&lt;/br&gt;TCP握手过程&lt;/br&gt;SYN queue]B -.-&gt; C[OS 操作系统&lt;br/&gt;TCP 完毕&lt;br/&gt;accept queue&lt;br/&gt;&lt;b&gt;acceptCount=1&lt;/b&gt;]A --windows--&gt; CC --&gt; D[selector收到socket事件通知&lt;br/&gt;连接处理计数&lt;br/&gt;默认限制1W&lt;br/&gt;&lt;b&gt;maxConnections=1&lt;/b&gt;] D --&gt; E((请求堆积)) E --&gt; Fsubgraph F[线程数量:MaxThreads]线程-1线程-2线程-nendsubgraph 操作系统BCendsubgraph TomcatDEFend</code></pre><p><strong>什么时候需要调整connections？如何调整？</strong></p><ul><li>connections小于maxThread的时候；需要调大；最好是比预期的最高并发数要大20%；例如 MaxThreads &#x3D; 5000, 则 MaxConnections &#x3D; 6000</li><li>反正是堆积到tomcat的work处理线程池中(堆积占内存)；</li></ul><p><strong>什么时候需要调整acceptCount？</strong></p><ul><li><p>想受理更多用户请求，却又不想堆积在tomcat中，利用操作系统来高效的堆积，可以调整为最高并发数 ­ connections；</p></li><li><p>实际上不需要调整，tomcat默认100，linux默认128；最好是把连接控制交给应用程序，这样方便管理。</p></li></ul><p>启动方式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar xxx.jar --server.tomcat.max-connections=1 --server.tomcat.max-thread=1 --server.tomcat.acceptCount=1<br></code></pre></td></tr></table></figure><h3 id="二-并发处理线程数调整"><a href="#二-并发处理线程数调整" class="headerlink" title="(二) 并发处理线程数调整"></a>(二) 并发处理线程数调整</h3><p>线程太少，CPU利用率过低，程序的吞吐量变小，资源浪费，容易堆积。</p><p>线程太多，上下文频繁切换，性能反而变低。</p><p>场景代入：服务器配置2核，不考虑内存问题。收到请求，java代码执行耗时50ms，等待数据返回50ms</p><p>那么, <strong>线程数调为多少合适？</strong></p><ul><li><p><strong>理想</strong>的线程数量&#x3D; (1 + 代码阻塞时间&#x2F;代码执行时间) * cpu数量</p></li><li><p><strong>实际情况</strong>是跑起代码，压测环境进行调试。不断调整线程数，将CPU打到80~90%的利用率。</p></li></ul><p>启动方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar web-demo-1.1.0.jar --server.tomcat.max-threads=500<br></code></pre></td></tr></table></figure><h2 id="二-整体架构"><a href="#二-整体架构" class="headerlink" title="二 : 整体架构"></a>二 : 整体架构</h2><pre><code class=" mermaid">graph LRA1[PC] --HTTPS--&gt; B2A2[Mobile] --HTTPS--&gt; B2subgraph B[Connection &amp; Load Balance]B1[Nginx]B2[Nginx]B3[Nginx]endsubgraph C[ ]    subgraph D[API GATEWAY]        D1[Nginx]        D2[Tomcat]    end    subgraph E1[WEB APP]        E11[Nginx]        E12[Tomcat]        E11 --&gt; E12    end    subgraph E2[WEB APP]        E21[Nginx]        E22[Tomcat]        E21 --&gt; E22    end    B2 --HTTP--&gt; D1    D1 --&gt; D2    D2 --HTTP--&gt; E11    D2 --RPC--&gt; E21endsubgraph F[Database]F1[Database]F2[Database]F3[Database]endE12 --&gt; F1</code></pre><p>如有需要 : 每台机器可以是nginx+tomcat，Nginx负责限流+日志记录</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat网络处理线程模型</title>
    <link href="/2020/09/04/Tomcat%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/09/04/Tomcat%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-BIO-同步-Servlet"><a href="#一-BIO-同步-Servlet" class="headerlink" title="一 : BIO + 同步 Servlet"></a>一 : BIO + 同步 Servlet</h2><p>一个请求，一个工作线程，CPU利用率低。</p><p>新版本中不再使用</p><pre><code class=" mermaid">graph LRA[User Request] --&gt; B[Nginx] --&gt; C[BIO Connector] --&gt; D[Servlet]D[Servlet] --&gt; E1[Remote Service]D[Servlet] --RPC--&gt; E2[Remote Service]D[Servlet] --HTTP--&gt; E3[Remote Service]subgraph NginxB[Nginx]endsubgraph TomcatC[BIO Connector]D[Servlet]endsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="二-APR-异步-Servlet"><a href="#二-APR-异步-Servlet" class="headerlink" title="二 : APR + 异步 Servlet"></a>二 : APR + 异步 Servlet</h2><p>APR(Apache Portable Runtime&#x2F;Apache可移植运行库)，是Apache HTTP服务器的支持库</p><p>JNI(Java Native Interface)的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作</p><p>Tomcat默认监听指定路径，如果有APR安装，则自动启用</p><pre><code class=" mermaid">graph LRA[User Request] --HTTP/1.1--&gt; B[Nginx] --&gt; C[APR Connector] --&gt; D[Async Servlet]D[Async Servlet] --&gt; E1[Remote Service]D[Async Servlet] --Async RPC--&gt; E2[Remote Service]D[Async Servlet] --Async HTTP--&gt; E3[Remote Service]subgraph NginxBendsubgraph TomcatCDendsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="三-NIO-异步-Servlet"><a href="#三-NIO-异步-Servlet" class="headerlink" title="三 : NIO + 异步 Servlet"></a>三 : NIO + 异步 Servlet</h2><p>Tomcat8开始，默认NIO方式</p><p>非阻塞读取请求信息，非阻塞处理下一个请求，完全异步</p><pre><code class=" mermaid">graph LRA[User Request] --HTTP/1.1--&gt; B[Nginx] --&gt; C[NIO Connector] --&gt; D[Async Servlet]D[Async Servlet] --Async RPC--&gt; E1[Remote Service]D[Async Servlet] --Async HTTP--&gt; E2[Remote Service]D[Async Servlet] --&gt; E3[Remote Service]subgraph NginxBendsubgraph TomcatCDendsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="四-NIO-处理流程"><a href="#四-NIO-处理流程" class="headerlink" title="四 : NIO 处理流程"></a>四 : NIO 处理流程</h2><pre><code class=" mermaid">graph TDA[User Request] --1--&gt; B[Acceptor]B --3--&gt; C1[PollerEvent]B --3--&gt; C2[PollerEvent]C1 --4--&gt; D1[Poller1 selector1]C2 --4--&gt; D2[Poller2 selector2]D1 --5--&gt; E1D2 --5--&gt; E1E1 --&gt; F1[nioChannel1]subgraph C[PollerEvent]C1[PollerEvent]C2[PollerEvent]endsubgraph D[Poller selector]D1[Poller1 selector1]D2[Poller2 selector2]endsubgraph E[SocketProcessor]E1[SocketProcessor1]E2[SocketProcessor2]E3[SocketProcessor3]endsubgraph F[nioChannel]F1F2[nioChannel2]F3[nioChannel3]endF1 --2--&gt; B</code></pre><ol><li>接受器接受套接字</li><li>接受器从缓存中检索niochannel对象</li><li>Pollerthread将nioChannel注册到它的选择器I0事件</li><li>轮询器将nioChannel分配给一个work线程来处理请求</li><li>SocketProcessor完成对请求的处理和返回</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/2020/08/28/JVM%E8%B0%83%E4%BC%98/"/>
    <url>/2020/08/28/JVM%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-调优基本概念"><a href="#一-调优基本概念" class="headerlink" title="一 : 调优基本概念"></a>一 : 调优基本概念</h2><p>在调整性能时, JVM有三个组件 :</p><ol><li>堆大小调整</li><li>垃圾收集器调整</li><li>JIT编译器</li></ol><p>通常, 在调优 Java 应用程序时, 重点是以下两个主要目标之一 :</p><ul><li><strong>响应性 :</strong> 应用程序或系统对请求的数据进行响应的速度, 对于专注于响应性的应用程序, 长的暂停时间是不可接受的, 重点是在短时间内做出回应</li><li><strong>吞吐量 :</strong> 侧重于在特定时间段内最大化应用程序的工作量, 对于专注于吞吐量的应用程序, 高暂停时间是可接受的。由于高吞吐量应用程序在较长时间内专注于基准测试, 因此不需要考虑快速响应时间</li></ul><p><strong>系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化。</strong></p><p><strong>JDK版本不断更新, JVM参数和具体说明, 建议需要时参考oracle官网的手册。</strong></p><p>官方调优指南 : <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></p><h2 id="二-常用-JVM-参数"><a href="#二-常用-JVM-参数" class="headerlink" title="二 : 常用 JVM 参数"></a>二 : 常用 JVM 参数</h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:+AlwaysPreTouch</td><td>jvm启动时分配内存, 非使用时再分配</td></tr><tr><td>-XX: ErrorFile &#x3D; filename</td><td>崩溃日志</td></tr><tr><td>-XX:+TraceClassLoading</td><td>跟踪类加载信息</td></tr><tr><td>-XX:+PrintClassHistogram</td><td>按下Ctrl+Break后, 打印类的信息</td></tr><tr><td>-Xmx -Xms</td><td>最大堆和最小堆</td></tr><tr><td>-xx:permSize、-xx:metaspaceSize</td><td>永久代&#x2F;元数据空间</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>OOM时导出堆到文件</td></tr><tr><td>-XX:+HeapDumpPath</td><td>OOM时堆导出的路径</td></tr><tr><td>-XX:OnOutOfMemoryError</td><td>在OOM时, 执行一个脚本</td></tr><tr><td>iava -XX:+PrintFlagsFinal -version</td><td>打印所有的-XX参数和默认值</td></tr></tbody></table><h2 id="三-GC-调优思路"><a href="#三-GC-调优思路" class="headerlink" title="三 : GC 调优思路"></a>三 : GC 调优思路</h2><table><thead><tr><th>步骤</th><th>目标</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>分析场景</td><td>启动速度慢; 偶尔出现响应慢于平均水平或者出现卡顿</td></tr><tr><td>2</td><td>确定目标</td><td>内存占用、低延时、吞吐量</td></tr><tr><td>3</td><td>收集日志</td><td>通过参数配置收集GC日志;通过JDK工具查看GC状态</td></tr><tr><td>4</td><td>分析日志</td><td>使用工具辅助分析日志, 查看GC次数, GC时间</td></tr><tr><td>5</td><td>调整参数</td><td>切换垃圾收集器或者调整垃圾收集器参数</td></tr></tbody></table><h2 id="四-通用-GC-参数"><a href="#四-通用-GC-参数" class="headerlink" title="四 : 通用 GC 参数"></a>四 : 通用 GC 参数</h2><p>GC线程数量</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:ParallelGCThreads</td><td>并行GC线程数量</td></tr><tr><td>-XX:ConcGCThreads</td><td>并发GC线程数量</td></tr></tbody></table><p>GC时间 : 意义不大, JVM只能尽量满足</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:MaxGCPauseMillis</td><td>最大停顿时间, 单位毫秒; GC尽力保证回收时间不超过设定值</td></tr><tr><td>-XX:GCTimeRatio</td><td>0-100的取值范围; 垃圾收集时间占总时间的比; 默认99, 即最大允许1%时间做GC</td></tr></tbody></table><p>内存占比 : 用默认值就好</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:SurvivorRatio</td><td>新生代Eden和Survivor大小的比例; 默认8, 表示2个Survivor:Eden&#x3D;2:8, 即1个Survivor占新生代的1&#x2F;10</td></tr><tr><td>-XX:NewRatio</td><td>新生代和老年代的比例; 默认4, 表示新生代:老年代&#x3D;1:4, 即年轻代占堆的1&#x2F;5</td></tr></tbody></table><p>GC信息</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-verbose:gc、-XX:+printGC</td><td>打印GC的简要信息</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC详细信息, <strong>jdk9已经舍弃</strong></td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>打印CG发生的时间戳, <strong>jdk9已经舍弃</strong></td></tr><tr><td><strong>-Xloggc:log&#x2F;gc.log</strong></td><td>指定Gc日志的位置, 以文件输出</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>每次一次GC后, 都打印堆信息</td></tr></tbody></table><h2 id="五-垃圾收集器-Parallel-参数"><a href="#五-垃圾收集器-Parallel-参数" class="headerlink" title="五 : 垃圾收集器 Parallel 参数"></a>五 : 垃圾收集器 Parallel 参数</h2><p>Parallel 是 JDK1.8 的默认收集器, 适用于<strong>吞吐量优先</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>新生代使用并行回收收集器</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>老年代使用并行回收收集器</td></tr><tr><td><strong>-XX:ParallelGCThreads</strong></td><td>设置用于垃圾回收的线程数</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>打开自适应GC策略,<strong>默认开启</strong></td></tr></tbody></table><h2 id="六-垃圾收集器-CMS-参数调优"><a href="#六-垃圾收集器-CMS-参数调优" class="headerlink" title="六 : 垃圾收集器 CMS 参数调优"></a>六 : 垃圾收集器 CMS 参数调优</h2><p><strong>响应时间优先;</strong> ParallelGC 无法满足应用程序延迟要求时再考虑使用 CMS 垃圾收集器; 新版建议用 G1 垃圾收集器</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>新生代使用并行收集器;老年代使用CMS+串行收集器</td></tr><tr><td>-XX:+UseParNewGC</td><td>在新生代使用并行收集器;CMS下默认开启</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction</td><td>设置触发GC的阈值,默认68%;如果内存预留空间不够,就会引起concurrentmode failure</td></tr><tr><td>-XX:+ UseCMSCompactAtFullCollection</td><td>Full GC后,进行一次整理,整理过程是独占的,会引起停顿时间变长</td></tr><tr><td>-XX:+CMSFullGCsBeforeCompaction</td><td>设置进行几次Full GC后,进行一次碎片整理</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td>允许对类元数据进行回收</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>表示只在到达阀值的时候,才进行CMS回收</td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>使用增量模式,比较适合单 CPU,<strong>不再维护</strong></td></tr></tbody></table><h2 id="七-垃圾收集器-G1-参数调优"><a href="#七-垃圾收集器-G1-参数调优" class="headerlink" title="七 : 垃圾收集器 G1 参数调优"></a>七 : 垃圾收集器 G1 参数调优</h2><p><strong>兼顾吞吐量和响应时间;</strong> 超过50%的Java堆被实时数据占用; 建议大堆(大小约为6GB更大)</p><p>GC延迟要求有限的应用(稳定且可预测的暂停时间低于0.5秒)。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:G1HeapRegionSize&#x3D;&lt;N,例如 16&gt;M</td><td>设置region大小,默认heap&#x2F;2000</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent</td><td>老年代依靠Mixed GC, 触发闻值</td></tr><tr><td>-XX:G1OldCSetRegionThresholdPercent</td><td>定多被包含在一次Mixed GC中的region比例</td></tr><tr><td>-XX:+ClassUnloadingWithConcurrentMark</td><td>G1增加并默认开启,在并发标记阶段结束后,JVM即进行类型卸载</td></tr><tr><td>-XX:GINewSizePercent</td><td>新生代的最小比例</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代的最大比例</td></tr><tr><td>-XX:G1MixedGCCountTarget</td><td>Mixed GC 数量控制</td></tr></tbody></table><h2 id="八-运行时-JIT-编译器优化参数"><a href="#八-运行时-JIT-编译器优化参数" class="headerlink" title="八 : 运行时 JIT 编译器优化参数"></a>八 : 运行时 JIT 编译器优化参数</h2><p>JIT编译指的是字节码编译为本地代码(汇编)执行, 只有热点代码才会编译为本地代码。</p><p>解释器执行节约内存, 反之可以使用编译执行来提升效率</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+AggressiveOpts</td><td>允许ivm使用积极的性能优化功能</td></tr><tr><td>-XX:-TieredCompilation</td><td>分层编译idk8默认开启, idk7默认关闭client</td></tr><tr><td>-Xmaxjitcodesize、-XX:ReservedCodeCacheSize</td><td>指定JIT编译代码的最大代码高速缓存最大值</td></tr><tr><td>-Xmixed</td><td>除了热方法之外, 解释器执行所有字节码, 热方法被编译为本机代码</td></tr><tr><td>-XX:lnitialCodeCacheSize</td><td>初始化编译后的汇编指令, 缓存区大小, 字节</td></tr><tr><td>-XX:+PrintCompilation</td><td>打开编译日志istat -compiler pid</td></tr><tr><td>-XX:CICompilerCount</td><td>JIT编译所使用的线程数量</td></tr><tr><td>-XX:+DoEscapeAnalysis</td><td>逃逸分析, 默认打开。对代码的深度优化</td></tr><tr><td>-XX:-Inline</td><td>方法内联, 默认打开。</td></tr></tbody></table><p><strong>很少需要对较新版本的JVM进行JIT调优</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="/2020/08/21/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/08/21/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="一-javap-反编译"><a href="#一-javap-反编译" class="headerlink" title="一 : javap(反编译)"></a>一 : javap(反编译)</h2><p>java 反编译工具, 主要用于根据 java 字节码文件汇编为 java 源代码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# javap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出附加信息到文件</span><br>[root@localhost ~]# javap -v HelloWorld.class &gt; HelloWorld.txt<br></code></pre></td></tr></table></figure><blockquote><p>官方文档 : <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/">https://docs.oracle.com/javase/8/docs/technotes/tools/</a></p></blockquote><h2 id="二-jps-进程状态"><a href="#二-jps-进程状态" class="headerlink" title="二 : jps(进程状态)"></a>二 : jps(进程状态)</h2><p>jps : java virtual machine process status tool, 显示当前所有 java 进程 pid 的命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行的java进程</span><br>[root@localhost ~]# jps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jps -help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前运行的java进程及jar包</span><br>[root@localhost ~]# jps -l<br></code></pre></td></tr></table></figure><h2 id="三-jstat-统计"><a href="#三-jstat-统计" class="headerlink" title="三 : jstat(统计)"></a>三 : jstat(统计)</h2><p>jstat : Monitors Java Virtual Machine (JVM) statistics, 监视 java 虚拟机 (JVM) <strong>统计信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jstat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数</span><br>[root@localhost ~]# jstat -options<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看gc信息</span><br>[root@localhost ~]# jstat -gc 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">每10行输出一次表头,每秒更新一次</span><br>[root@localhost ~]# jstat -gc -h10 34977 1000<br></code></pre></td></tr></table></figure><h2 id="四-jcmd-命令"><a href="#四-jcmd-命令" class="headerlink" title="四 : jcmd(命令)"></a>四 : jcmd(命令)</h2><p>jcmd : Sends diagnostic command requests to a running Java Virtual Machine (JVM), 发送<strong>诊断指令</strong>请求到运行的 JVM </p><p>可以替代 jps 工具查看本地的 jvm 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">当前运行的java进程及jar包</span><br>[root@localhost ~]# jcmd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jcmd -h<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出具体指令</span><br>[root@localhost ~]# jcmd 34977 help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看堆内存信息</span><br>[root@localhost ~]# jcmd 34977 GC.heap_info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看gc</span><br>[root@localhost ~]# jcmd 34977 VM.flags<br></code></pre></td></tr></table></figure><h2 id="五-jinfo-配置信息"><a href="#五-jinfo-配置信息" class="headerlink" title="五 : jinfo(配置信息)"></a>五 : jinfo(配置信息)</h2><p>jinfo : Generates configuration information, 生成<strong>配置信息</strong></p><p>可以查看运行中 jvm 的全部参数, 还可以设置部分参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jinfo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定进程的参数</span><br>[root@localhost ~]# jinfo 34977<br></code></pre></td></tr></table></figure><h2 id="六-jmap-映射信息"><a href="#六-jmap-映射信息" class="headerlink" title="六 : jmap(映射信息)"></a>六 : jmap(映射信息)</h2><p>Prints shared object memory maps or heap memory details for a process, core file, or remote debug server</p><p>打印出 java 进程内存中 Object 的情况; 或者将 VM 中的堆, 以二级制输出成文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jmap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看堆内存</span><br>[root@localhost ~]# jmap -heap 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">内存快照: 以文件形式保存下来</span><br>[root@localhost ~]# jmap -dump:live,format=b,file=heap.bin 34977<br></code></pre></td></tr></table></figure><h2 id="七-jhat-堆内存"><a href="#七-jhat-堆内存" class="headerlink" title="七 : jhat(堆内存)"></a>七 : jhat(堆内存)</h2><p>jhat(java head analyse tool) : Analyzes the Java heap, 分析 java 堆的命令, 可以将堆中的对象以 html 的形式显示出来, 支持对象查询语言 OQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jhat -help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载内存快照,以9001提供web服务</span><br>[root@localhost ~]# jhat -port 9001 heap.bin<br></code></pre></td></tr></table></figure><p>这里需要注意的有 : </p><ul><li>Show all members of the rootset</li><li>Show heap histogram</li><li>Execute Object Query Language (OQL) query</li></ul><h2 id="八-jstack-栈内存"><a href="#八-jstack-栈内存" class="headerlink" title="八 : jstack(栈内存)"></a>八 : jstack(栈内存)</h2><p><strong>堆栈跟踪工具</strong>; jstack 用于打印出给定的 java 进程 ID 或 core file 或远程调试服务的 java 堆栈信息, 如果是在 64 位机器上, 需要指定选项 “-J-d64”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助命令</span><br>[root@localhost ~]# jstack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定进程的栈,-F为强制</span><br>[root@localhost ~]# jstack -F 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">内容太多,文件保存</span><br>[root@localhost ~]# jstack -F 34977 &gt; jstack.log<br></code></pre></td></tr></table></figure><h2 id="九-Jconsole"><a href="#九-Jconsole" class="headerlink" title="九 : Jconsole"></a>九 : Jconsole</h2><p>java 监控和管理控制台</p><p>在测试和性能调试的时候可以用到</p><p><img src="/../java/image-2020082101.png"> </p><h2 id="十-JvisualVM"><a href="#十-JvisualVM" class="headerlink" title="十 : JvisualVM"></a>十 : JvisualVM</h2><p>虚拟机工具, 可以看 GC, 内存, 堆栈</p><p>功能很全面啊</p><p><img src="/../java/image-2020082102.png"> </p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2020/08/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一-自动垃圾收集"><a href="#一-自动垃圾收集" class="headerlink" title="一 : 自动垃圾收集"></a>一 : 自动垃圾收集</h2><p>自动垃圾收集是查看堆内存, 识别哪些对象<strong>正在使用</strong>以及哪些对象<strong>未被删除</strong>以及<strong>删除</strong>未使用对象的过程</p><p>使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针; 程序的任何部分都不再引用未使用的对象或未引用的对象, 因此可以回收未引用对象使用的内存</p><p>例如 : 像 C 这样的编程语言中, 分配和释放内存是一个<strong>手动过程</strong>; 在 java 中, 解除分配内存的过程由<strong>垃圾收集器</strong>自动处理</p><h2 id="二-如何确定内存需要被回收"><a href="#二-如何确定内存需要被回收" class="headerlink" title="二 : 如何确定内存需要被回收"></a>二 : 如何确定内存需要被回收</h2><p>该过程的第一步称为<strong>标记</strong>; 这是垃圾收集器识别哪些内存正在使用而哪些不在使用的地方</p><p><img src="/../java/image-2020081401.png" alt="内存标记"> </p><p><strong>不同类型内存的判断方法</strong></p><ul><li>对象回收 : <u>引用计数</u>, 简单来说就是引用一次就加1, 用完之后就减1, java中很少用, 会造成循环引用的问题</li><li>对象回收 : <strong>可达性算法</strong></li><li>方法区回收</li></ul><h2 id="三-可达性分析算法"><a href="#三-可达性分析算法" class="headerlink" title="三 : 可达性分析算法"></a>三 : 可达性分析算法</h2><p>简单来说, 将对象及其引用关系看作一个图, 选定<strong>活动的对象</strong>作为 GC Roots, 然后跟踪引用链条, 如果一个对象和 GC Roots 之间不可达, 也就是不存在引用, 那么即可认为是可回收对象</p><p><img src="/../java/image-2020081402.png" alt="可达性分析算法"> </p><p><strong>可以作为 GC Root 的对象 :</strong></p><ol><li>虚拟机栈中正在引用的对象</li><li>本地方法栈中正在引用的对象</li><li>静态属性引用的对象</li><li>方法区常量引用的对象</li></ol><h2 id="四-引用类型和可达性级别"><a href="#四-引用类型和可达性级别" class="headerlink" title="四 : 引用类型和可达性级别"></a>四 : 引用类型和可达性级别</h2><p><strong>引用类型</strong></p><ol><li>强引用(StrongReference) : 最常见的普通对象(new Object())引用, 只要还有强引用指向一个对象, 就不会回收</li><li>软引用(SoftReference) : JVM 认为内存不足时, 才会去试图回收软引用指向的对象(缓存场景)</li><li>弱引用(WeakReference) : 虽然是引用, 但随时可能被回收掉</li><li>虚引用(Phantom) : 不能通过它访问对象, 关联对象被 finalized 以后, 执行指定逻辑的机制(Cleaner)</li></ol><p><strong>可达性级别</strong></p><ol><li>强可达(Strongly Reachable) : 一个对象可以有一个或多个线程可以不通过各种引用访问到的情况</li><li>软可达(Softly Reachable) : 就是当我们只能通过软引用才能访问到对象的状态</li><li>弱可达(Weakly Reachable) : 只能通过弱引用访问时的状态; 当弱引用被清除的时候, 就符合销毁条件</li><li>幻象可达(Phantom Reachable) : 不存在其他引用, 并且 finalize 过了, 只有幻象引用指向这个对象</li><li>不可达(unreachable) : 意味着对象可以被清楚了</li></ol><h2 id="五-垃圾收集算法"><a href="#五-垃圾收集算法" class="headerlink" title="五 : 垃圾收集算法"></a>五 : 垃圾收集算法</h2><p><strong>标记-清除 (Mark-Sweep) 算法</strong> : </p><ul><li>首先标识出所有要回收的对象, 然后进行清除; </li><li>标记清除过程效率有限, 有内存碎片化问题, 不适合特别大的堆; </li><li>收集算法基本基于<strong>标记-清除</strong>的思路进行改进</li></ul><p><strong>复制 (Copying) 算法 :</strong> </p><ul><li>划分两块同等大小的区域, 收集时将活着的对象复制到另一块区域; 原区域清空</li><li>拷贝过程中将对象顺序放置, 就可以避免内存碎片化; </li><li>复制 + 预留内存, 有一定的浪费</li></ul><p><strong>标记整理(Mark-Compact) :</strong> </p><ul><li>类似于<strong>标记-清除</strong>, 但为避免<u>内存碎片化</u>, 它会在清理过程中将<strong>对象移动</strong>, 以确保移动后的对象占用连续的内存空间</li><li>避免内存碎片化</li></ul><h2 id="六-分代收集"><a href="#六-分代收集" class="headerlink" title="六 : 分代收集"></a>六 : 分代收集</h2><p>根据对象的存活周期, 将内存划分为几个区域(Eden, form, to, Tenured), 不同区域菜哦也能够合适的垃圾收集算法</p><p>新对象会分配到 Eden, 如果超过<code>-XX:+PrentenureSizeThreshold:</code> 设置大对象直接进入老年代(Tenured)的阈值</p><p>新生代采用<strong>复制算法</strong> : Eden 中的对象经过一次 GC 后, 如果未回收则 Copy 进入 form; 第二次 GC 后, 将 Eden 和 form 中的对象统一 Copy 到 to; 第三次 GC 后, 将 Eden 和 to 中的对象 Copy 到 form 中; GC 一定次数未回收对象移动到老年代 <code>(-XX:MaxTenuringThreshold)</code></p><p><img src="/../java/image-2020081403.png" alt="新生代:复制算法"> </p><p>老年代采用<strong>标记整理</strong> : 标记 &#x3D;&gt; 清除 &#x3D;&gt; 整理</p><p><img src="/../java/image-2020081404.png" alt="老年代:标记整理"> </p><h2 id="七-垃圾收集器"><a href="#七-垃圾收集器" class="headerlink" title="七 : 垃圾收集器"></a>七 : 垃圾收集器</h2><h3 id="一-串行收集器"><a href="#一-串行收集器" class="headerlink" title="(一) 串行收集器"></a>(一) 串行收集器</h3><p><strong>Serial GC :</strong> <code>-XX:+UseSerialGC</code></p><ul><li>单个线程来执行所有垃圾收集工作, 适合单处理器设备</li><li><strong>Client 模式下 JVM 的默认选项</strong></li></ul><p><strong>Serial Old GC :</strong> <code>-XX:+UseSerialOldGC</code></p><ul><li>可以在老年代使用, 它采用了标记整理(Mark-Compact)算法, 区别于新生代的复制算法</li></ul><p><img src="/../java/image-2020081405.png" alt="串行收集器"></p><h3 id="二-并行收集器"><a href="#二-并行收集器" class="headerlink" title="(二) 并行收集器"></a>(二) 并行收集器</h3><p><strong>Parallel GC :</strong> <code>-XX:+UseParallelGC</code></p><p><strong>Parallel Old GC :</strong> <code>-XX:+UseParallelOldGC</code></p><p><u>server 模式 JVM 的默认 GC 选项</u>, 整体算法和 Serial 比较相似, 区别是新生代和老年代 GC 都是并行进行; 可以设置 GC 时间或吞吐量等值, 可以自动进行适应性调整 Eden, Survivor 大小和 MaxTenuringThreshold 的值</p><p>也称为吞吐量优先的 GC : 吞吐量 &#x3D; 用户代码运行时间&#x2F;(用户代码运行时间 + GC 停顿时间)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:ParallelGCThreads : 设置用于垃圾回收的线程数;通常情况下可以和CPU数量相等<br>-XX:MaxGCPauseMills : 设置最大垃圾收集停顿时间;它的值是一个大于0的整数;只能尽量满足这个值<br>-XX:GCTimeRatio : 设置吞吐量大小,它的值是一个0~100之间的整数<br>-XX:+UseAdaptiveSizePolicy : 打开自适应GC策略;以达到在堆大小,吞吐量和停顿时间之间的平衡点;默认开启<br></code></pre></td></tr></table></figure><h3 id="三-并发收集器"><a href="#三-并发收集器" class="headerlink" title="(三) 并发收集器"></a>(三) 并发收集器</h3><p><strong>CMS (Concurrent Mark Sweep) GC :</strong> <code>-XX:+UseConcMarkSweepGC</code></p><ul><li>专用<strong>老年代</strong>, 基于标记清除(Mark-Sweep)算法, 设计目标是尽量减少停顿时间</li><li>采用的标记清除算法, 存在着内存碎片化问题, 长时间运行等情况下发生 full GC, 导致恶劣的停顿</li><li>CMS 会占用更多的 CPU 资源, 并和用户线程争抢</li><li>减少了停顿时间, 这一点对于互联网 web 等对时间敏感的系统非常重要, 一直到今天, 仍然有很多系统使用 CMS GC</li></ul><p><img src="/../java/image-2020081406.png"> </p><h3 id="四-其他"><a href="#四-其他" class="headerlink" title="(四) 其他"></a>(四) 其他</h3><p><strong>ParNew GC :</strong> <code>-XX:+UseParNewGC</code></p><ul><li>并行收集器</li><li><strong>新生代</strong> GC 实现, 它实际是 Serial GC 的多线程版本</li><li>可以控制线程数量, 参数 : <code>-XX:ParallelGCThreads</code></li><li>最常见的<strong>应用场景</strong>是配合老年代的 CMS GC 工作; 参数 : <code>-XX:=UseConcMarkSweepGC</code></li></ul><p><img src="/../java/image-2020081407.png"> </p><p><strong>G1 GC :</strong> <code>-XX:+UseG1GC</code></p><ul><li>并发收集器</li><li>针对大堆内存设计的收集器, 兼顾吞吐量和停顿时间, JDK9 后默认选型, 目标是替代 CMS;</li><li>G1 将堆分成固定大小的区域, Region 之间是复制算法, 但整体上实际可看作是标记整理(Mark-Compact)算法, 可以有效地避免内存碎片;</li></ul><ul><li>红色新生代(Eden和Surivor)，淡蓝色老年代。找不到大内存时执行FullGC</li></ul><p><img src="/../java/image-2020081408.png"></p><h2 id="八-垃圾收集器组合"><a href="#八-垃圾收集器组合" class="headerlink" title="八 : 垃圾收集器组合"></a>八 : 垃圾收集器组合</h2><p><img src="/../java/image-2020081409.png"> </p><p>常用选择</p><ol><li>默认选择: Parallel Scavenge + Parallel Old</li><li>常用选择: ParNew + CMS</li><li>激进选择: G1</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2020/08/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一-类生命周期"><a href="#一-类生命周期" class="headerlink" title="一 : 类生命周期"></a>一 : 类生命周期</h2><pre><code class=" mermaid">graph LR加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化 --&gt; 使用 --&gt; 卸载</code></pre><p>重点关注: 从加载到初始化的过程</p><ol><li>加载 : 读取二进制内容</li><li>验证 : 验证class文件格式规范,语义分析,引用验证,字节码验证</li><li>准备 : 分配内存,设置类static修饰的变量初始值</li><li>解析 : 类,接口,字段,类方法等解析</li><li>初始化 : 为静态变量赋值,执行静态代码块</li><li>使用 : 创建实例对象</li><li>卸载 : 从JVM方法区中卸载</li></ol><h2 id="二-类加载器"><a href="#二-类加载器" class="headerlink" title="二 : 类加载器"></a>二 : 类加载器</h2><p><strong>类加载器负责装入类</strong>, 搜索网络, jar, zip, 文件夹, 二进制数据, 内存等指定位置的资源</p><p>一个 java 程序运行, 最少有三个类加载器实例, 负责不同类的加载</p><table><thead><tr><th>序号</th><th>加载器</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Bootstrap Loader</td><td>核心类库加载器</td><td>C&#x2F;C++ 实现, 无对应 java 类(null); 加载 <code>JRE_HOME/jre/lib</code> 目录, 或者用户配置的目录; JDK 核心类库 rt.jar…String…</td></tr><tr><td>2</td><td>Extension Class Loader</td><td>扩展类库加载器</td><td>ExtClassLoader 的实例; 加载 <code>JRE_HOME/jre/lib/ext</code> 目录, JDK 扩展包, 或者用户配置的目录</td></tr><tr><td>3</td><td>Application Class Loader</td><td>用户应用程序加载器</td><td>AppClassLoader 的实例; 加载 <code>java.class.path</code> 指定的目录, 用户应用程序 class-path 或者 java 命令运行时参数 -cp …</td></tr></tbody></table><h2 id="三-验证问题"><a href="#三-验证问题" class="headerlink" title="三 : 验证问题"></a>三 : 验证问题</h2><h3 id="一-查看类对应的加载器"><a href="#一-查看类对应的加载器" class="headerlink" title="(一) 查看类对应的加载器"></a>(一) 查看类对应的加载器</h3><p>通过 JDK-API 进行查看: java.lang.Class.getClassLoader, 返回装载类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查看类的加载器实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderView</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 加载核心类库的 BootStrap ClassLoader</span><br>        System.out.println(<span class="hljs-string">&quot;核心类库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader()<br>                           .loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader());<br>        <span class="hljs-comment">// 加载拓展库的 Extension ClassLoader</span><br>        System.out.println(<span class="hljs-string">&quot;拓展类库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader()<br>                           .loadClass(<span class="hljs-string">&quot;com.sun.nio.zipfs.ZipCoder&quot;</span>).getClassLoader());<br>        <span class="hljs-comment">// 加载应用程序的</span><br>        System.out.println(<span class="hljs-string">&quot;应用程序库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader());<br><br>        <span class="hljs-comment">// 双亲委派模型 Parents Delegation Model</span><br>        System.out.println(<span class="hljs-string">&quot;应用程序库加载器的父类：&quot;</span> + ClassLoaderView.class.getClassLoader().getParent());<br>        System.out.println(<br>            <span class="hljs-string">&quot;应用程序库加载器的父类的父类：&quot;</span> + ClassLoaderView.class.getClassLoader().getParent().getParent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个类是由 bootstrapClassLoader 加载的, 那么这个方法在这种实现中返回 null</p><h3 id="二-jvm-如何知道我们的类在何方"><a href="#二-jvm-如何知道我们的类在何方" class="headerlink" title="(二) jvm 如何知道我们的类在何方"></a>(二) jvm 如何知道我们的类在何方</h3><p>class 信息存放在不同的位置, 桌面 jar, 项目 bin 目录, target 目录等等</p><p>查看 openjdk 源代码 : sum.misc.Launcher.AppClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br></code></pre></td></tr></table></figure><p>结论 : 读取 java.class.path 配置, 指定去哪些地址加载类资源</p><p>验证过程 : 以 <code>hello world</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>System.in.read();<span class="hljs-comment">//阻塞进程,没有其他意义</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 java 进程 : jps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.jps 查看本机 java 进程</span><br>[root@localhost ~]# jps<br>2467 HelloWorld<br>2477 Jps<br></code></pre></td></tr></table></figure><p>查看运行时配置 : jcmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2.查看运行时配置: jcmd 进程号 VM.system_properties</span><br>[root@localhost ~]# jcmd<br>2467 HelloWorld<br>2487 sun.tools.jcmd.JCmd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看命令格式</span><br>[root@localhost ~]# jcmd -h<br>Usage: jcmd &lt;pid | main class&gt; &lt;command ...|PerfCounter.print|-f file&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看对应进程可选的<span class="hljs-built_in">command</span></span><br>[root@localhost ~]# jcmd 2467 help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统配置</span><br>[root@localhost ~]# jcmd 2467 VM.system_properties<br></code></pre></td></tr></table></figure><h3 id="三-类不会重复加载"><a href="#三-类不会重复加载" class="headerlink" title="(三) 类不会重复加载"></a>(三) 类不会重复加载</h3><p>类的唯一性: 同一个类加载器, 类名一样, 代表是同一个类</p><p><strong>识别方式 :</strong> ClassLoader Instance Id + PackaeName + ClassName</p><p><strong>验证方式 :</strong> 使用类加载器, 对同一个 class 类的不同版本, 进行多次加载, 检查是否会加载到最新的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-comment">// 创建一个新的类加载器</span><br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-comment">// 加载class</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br>            <span class="hljs-comment">// 创建对象(反射)</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>); <br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论 :</strong> 程序运行中修改 HelloService 中代码, 经重新编译后, 输出内容无变化, 说明 <code>.class</code> 文件不会被重复加载</p><h3 id="四-类的卸载"><a href="#四-类的卸载" class="headerlink" title="(四) 类的卸载"></a>(四) 类的卸载</h3><p>类什么时候会被卸载? 满足如下两个条件 : </p><ol><li>该 Class 所有的实例都已经被 GC</li><li>加载该类的 ClassLoader 实例已经被 GC</li></ol><p><strong>验证方式 :</strong> jvm 启动中增加 -<code>verbose:class</code> 参数, 输出类加载和卸载的日志信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            <br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>);<br>            System.out.println();<br><br>            <span class="hljs-comment">// help gc  -verbose:class</span><br>            newInstance = <span class="hljs-literal">null</span>;<br>            loader = <span class="hljs-literal">null</span>;<br>        &#125;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-双亲委派模型"><a href="#五-双亲委派模型" class="headerlink" title="(五) 双亲委派模型"></a>(五) 双亲委派模型</h3><pre><code class=" mermaid">graph TDbootstrap顶层类加载器 --查找--&gt; ext扩展类库类加载器ext扩展类库类加载器 --委托--&gt; bootstrap顶层类加载器ext扩展类库类加载器 --查找--&gt; app用户应用程序类加载器app用户应用程序类加载器 --委托--&gt; ext扩展类库类加载器app用户应用程序类加载器 --查找--&gt; 最底端子类加载器最底端子类加载器 --委托--&gt; app用户应用程序类加载器</code></pre><p>为了避免重复加载, <strong>由下到上逐级委托, 由上到下主机查找</strong></p><ul><li>首先<strong>不会自己去尝试加载</strong>类, 而是<strong>把这个请求委托给父加载器</strong>去完成</li><li>每一个层次的加载器都是如此, 因此所有的类加载请求都会传给上层的启动类加载器</li><li><strong>只有当父加载器</strong>反馈自己<strong>无法</strong>完成该<strong>加载</strong>请求(该加载器的搜索范围中没有找到对应的类)时, 子加载器<strong>才会尝试自己去加载</strong></li></ul><p><strong>注意 :</strong> 类加载器之间不存在父类子类的关系, “双亲”是翻译, 可以理解为逻辑上定义的上下级关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-comment">// 父加载器</span><br><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">parentLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-comment">// 每次循环都创建新的类加载器</span><br>            <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;, parentLoader);<br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>);<br>            System.out.println();<br><br>            <span class="hljs-comment">// help gc  -verbose:class</span><br>            newInstance = <span class="hljs-literal">null</span>;<br>            loader = <span class="hljs-literal">null</span>;<br>        &#125;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考 :</strong> 很多优秀框架的<strong>热加载</strong>功能会不会是每次都创建新的加载器</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty零拷贝</title>
    <link href="/2020/07/31/netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/07/31/netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ByteBuf"><a href="#一-ByteBuf" class="headerlink" title="一 : ByteBuf"></a>一 : ByteBuf</h2><p>ByteBuf 是为解决 ByteBuffer 的问题和满足网络应用程序开发人员的日常需求而设计的。</p><p>JDK ByteBuffer的缺点︰</p><ul><li><strong>无法动态扩容 :</strong> 长度是固定, 不能动态扩展和收缩, 当数据大于ByteBuffer容量时, 会发生索引越界异常。</li><li><strong>API使用复杂 :</strong> 读写的时候需要手工调用flip()和rewind()等方法, 使用时需要非常谨慎的使用这些api,否则很容出现错误</li></ul><p>ByteBuf 做了哪些增强</p><ul><li>API操作便捷性</li><li>动态扩容</li><li>多种 ByteBuf实现</li><li>高效的零拷贝机制</li></ul><h2 id="二-ByteBuf-操作"><a href="#二-ByteBuf-操作" class="headerlink" title="二 : ByteBuf 操作"></a>二 : ByteBuf 操作</h2><p>ByteBuf 三个<strong>重要属性</strong> : capacity容量、readerIndex读取位置、writerIndex写入位置。</p><p>提供了两个指针变量来支持顺序读和写操作, 分别是readerIndex和写操作writerIndex</p><p>常用方法定义</p><ul><li>随机访问索引 getByte</li><li>顺序读read*</li><li>顺序写write*</li><li>清除已读内容discardReadBytes</li><li>清除缓冲区clear</li><li>搜索操作</li><li>标记和重置</li><li>引用计数和释放</li></ul><p>下图显示了一个缓冲区是如何被两个指针分割成三个区域的</p><p><img src="/../java/image-2020073101.png" alt="image-2020073101"> </p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apiTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个非池化的ByteBuf, 大小为10个字节</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;原始ByteBuf为====================&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;1.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 2.写入一段内容</span><br>        <span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        buf.writeBytes(bytes);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;2.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 3.读取一段内容</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> buf.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> buf.readByte();<br>        System.out.println(<span class="hljs-string">&quot;读取的bytes为====================&gt;&quot;</span> + Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;b1, b2&#125;));<br>        System.out.println(<span class="hljs-string">&quot;读取一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;3.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 4.将读取的内容丢弃</span><br>        buf.discardReadBytes();<br>        System.out.println(<span class="hljs-string">&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;4.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 5.清空读写指针</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;将读写指针清空后ByteBuf为==========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;5.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 6.再次写入一段内容, 比第一段内容少</span><br>        <span class="hljs-type">byte</span>[] bytes2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        buf.writeBytes(bytes2);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes2));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;6.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 7.将ByteBuf清零</span><br>        buf.setZero(<span class="hljs-number">0</span>, buf.capacity());<br>        System.out.println(<span class="hljs-string">&quot;将内容清零后ByteBuf为==============&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;7.ByteBuf中的内容为================&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 8.再次写入一段超过容量的内容</span><br>        <span class="hljs-type">byte</span>[] bytes3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>        buf.writeBytes(bytes3);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes3));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;8.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-comment">//  随机访问索引 getByte</span><br>        <span class="hljs-comment">//  顺序读 read*</span><br>        <span class="hljs-comment">//  顺序写 write*</span><br>        <span class="hljs-comment">//  清除已读内容 discardReadBytes</span><br>        <span class="hljs-comment">//  清除缓冲区 clear</span><br>        <span class="hljs-comment">//  搜索操作</span><br>        <span class="hljs-comment">//  标记和重置</span><br>        <span class="hljs-comment">//  完整代码示例：参考</span><br>        <span class="hljs-comment">// 搜索操作 读取指定位置 buf.getByte(1);</span><br>        <span class="hljs-comment">//</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-ByteBuf-动态扩容"><a href="#三-ByteBuf-动态扩容" class="headerlink" title="三 : ByteBuf 动态扩容"></a>三 : ByteBuf 动态扩容</h2><p>capacity默认值:256字节、最大值:Integer.MAX_VALUE ( 2GB)</p><p><code>write*</code> 方法调用时, 通过 <code>AbstractByteBuf.ensureWritable0</code> 进行检查。</p><p>容量计算方法 : AbstractByteBufAllocator. calculateNewCapacity (新capacity的最小要求, capacity最大值), 根据新capacity的最小值要求, 对应有两套计算方法:</p><ol><li><strong>没超过4兆 :</strong> 从64字节开始, 每次增加一倍, 直至计算出来的newCapacity满足新容量最小要求。示例 : 当前大小256, 已写250, 继续写10字节数据, 需要的容量最小要求是261, 则新容量是  64 * 2 * 2 * 2&#x3D;512</li><li><strong>超过4兆 :</strong> 新容量 &#x3D; 新容量最小要求&#x2F;4兆 * 4兆＋4兆; 示例:当前大小3兆, 已写3兆, 继续写2兆数据, 需要的容量最小要求是5兆, 则新容量是9兆(不能超过最大值)。</li></ol><h2 id="四-ByteBuf-的具体实现"><a href="#四-ByteBuf-的具体实现" class="headerlink" title="四 : ByteBuf 的具体实现"></a>四 : ByteBuf 的具体实现</h2><p>3个维度, 8种实现</p><p><img src="/../java/image-2020073102.png" alt="image-2020073102"> </p><p>unsafe意味着不安全的操作。但是更底层的操作会带来性能提升和特殊功能, Netty中会尽力使用unsafe。</p><p>Java语言很重要的特性是“一次编写到处运行”, 所以它针对底层的内存或者其他操作, 做了很多封装。而unsafe提供了一系列我们操作底层的方法, 可能会导致不兼容或者不可知的异常。</p><ul><li>Info.仅返回一些低级的内存信息 : addressSize, pageSize</li><li>Objects.提供用于操作对象及其字段的方法 : allocatelnstance, objectFieldOffset</li><li>Classes.提供用于操作类及其静态字段的方法 : staticFieldoffset, defineClass, defineAnonymousClass, ensureClassInitialized</li><li>Synchronization.低级的同步原语 : monitorEnter, tryMonitorEnter, monitorExit, compareAndSwaplnt, putOrderedInt</li><li>Memory.直接访问内存方法 : allocateMemory, copyMemory, freeMemory, getAddress, getln, tputlnt</li><li>Arrays.操作数组 : arrayBaseOffset, arrayIndexScale</li></ul><p>在使用中, 都是通过 ByteBufAllocator 分配器进行申请, 同时分配器具备有内存管理的功能</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆外内存的常规API</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectByteBufDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apiTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个非池化的ByteBuf, 大小为10个字节</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.directBuffer(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;原始ByteBuf为====================&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">// System.out.println(&quot;1.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 2.写入一段内容</span><br>        <span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        buf.writeBytes(bytes);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;2.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 3.读取一段内容</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> buf.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> buf.readByte();<br>        System.out.println(<span class="hljs-string">&quot;读取的bytes为====================&gt;&quot;</span> + Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;b1, b2&#125;));<br>        System.out.println(<span class="hljs-string">&quot;读取一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">//System.out.println(&quot;3.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 4.将读取的内容丢弃</span><br>        buf.discardReadBytes();<br>        System.out.println(<span class="hljs-string">&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;4.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 5.清空读写指针</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;将读写指针清空后ByteBuf为==========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;5.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 6.再次写入一段内容, 比第一段内容少</span><br>        <span class="hljs-type">byte</span>[] bytes2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        buf.writeBytes(bytes2);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes2));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;6.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 7.将ByteBuf清零</span><br>        buf.setZero(<span class="hljs-number">0</span>, buf.capacity());<br>        System.out.println(<span class="hljs-string">&quot;将内容清零后ByteBuf为==============&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;7.ByteBuf中的内容为================&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 8.再次写入一段超过容量的内容</span><br>        <span class="hljs-type">byte</span>[] bytes3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>        buf.writeBytes(bytes3);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes3));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;8.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-PooledByteBuf-对象、内存复用"><a href="#五-PooledByteBuf-对象、内存复用" class="headerlink" title="五 : PooledByteBuf 对象、内存复用"></a>五 : PooledByteBuf 对象、内存复用</h2><p><strong>PoolThreadCache :</strong> PooledByteBufAllocator 实例维护的一个线程变量。</p><p>多种分类的 MemoryRegionCache <strong>数组</strong>用作内存缓存，MemoryRegionCache内部是链表，队列里面存Chunk</p><p>PoolChunk里面维护了内存引用，内存复用的做法就是把 buf 的 memory 指向 chunk 的 memory</p><p>PooledByteBufAllocator.ioBuffer<strong>运作过程</strong>梳理</p><p><img src="/../java/image-2020073103.png" alt="image-2020073103"> </p><h2 id="六-零拷贝机制"><a href="#六-零拷贝机制" class="headerlink" title="六 : 零拷贝机制"></a>六 : 零拷贝机制</h2><p>Netty的零拷贝机制，是一种应用层的实现。和底层JVM、操作系统内存机制并无过多关联。</p><p>CompositeByteBuf，将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝</p><p><img src="/../java/image-2020073104.png" alt="image-2020073104">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">compositeByteBuf</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> compositeByteBuf.addComponents(<span class="hljs-literal">true</span>, buffer1, buffer2);<br></code></pre></td></tr></table></figure><p>wrapedBuffer()方法，将byte[]数组包装成ByteBuf对象。</p><p><img src="/../java/image-2020073105.png" alt="image-2020073105"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><p>slice()方法。将一个ByteBuf对象切分成多个ByteBuf对象。</p><p><img src="/../java/image-2020073106.png" alt="image-2020073106"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> buffer1.slice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 零拷贝</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZeroCopyTest</span> &#123;<br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(arr);<br>        System.out.println(byteBuf.getByte(<span class="hljs-number">4</span>));<br>        arr[<span class="hljs-number">4</span>] = <span class="hljs-number">6</span>;<br>        System.out.println(byteBuf.getByte(<span class="hljs-number">4</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sliceTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> buffer1.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        newBuffer.unwrap();<br>        System.out.println(newBuffer.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compositeTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">3</span>);<br>        buffer1.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">3</span>);<br>        buffer2.writeByte(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">compositeByteBuf</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br>        <span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> compositeByteBuf.addComponents(<span class="hljs-literal">true</span>, buffer1, buffer2);<br>        System.out.println(newBuffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty责任链</title>
    <link href="/2020/07/24/netty%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <url>/2020/07/24/netty%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一-设计模式-责任链模式"><a href="#一-设计模式-责任链模式" class="headerlink" title="一 : 设计模式 - 责任链模式"></a>一 : 设计模式 - 责任链模式</h2><p>责任链模式(Chain of Responsibility Pattern)为请求创建了一个处理对象的链。<br><strong>发起请求和具体处理请求的过程进行解耦</strong> : 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可, 无须关心请求的处理细节和请求的传递</p><pre><code class=" mermaid">graph LR请求 --&gt; 责任链调用 --chains--&gt; handler1 --&gt; handler2 --&gt; handler3 --&gt; handler-n --&gt; ... </code></pre><h3 id="一-实现责任链模式"><a href="#一-实现责任链模式" class="headerlink" title="(一) : 实现责任链模式"></a>(一) : 实现责任链模式</h3><p>实现责任链模式4个要素 : </p><ol><li>处理器抽象类</li><li>具体的处理器实现类</li><li>保存处理器信息</li><li>处理执行</li></ol><p>伪代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 集合形式存储: 类似tomcat中filters</span><br><span class="hljs-comment">// 1.处理器抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandler</span><span class="hljs-params">(Object arg0)</span>; <br>&#125;<br><br><span class="hljs-comment">// 2.处理器具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><br><span class="hljs-comment">// 3.创建集合并存储所有处理器实例信息</span><br><span class="hljs-type">List</span> <span class="hljs-variable">handlers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();<br>handlers.add(handler1, handler2, handler3);<br><br><span class="hljs-comment">// 4.处理请求，调用处理器()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Process</span><span class="hljs-params">(request)</span>&#123;<br>    <span class="hljs-keyword">for</span>( handler in handlers)&#123;<br>        handler.doHandler(request) ;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 发起请求调用，通过责任链处理请求</span><br>call.process(request);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//链表形式调用: 参考netty的实现形式</span><br><span class="hljs-comment">// 1.处理器抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> &#123;<br>    AbstractHandle next;<span class="hljs-comment">//下一个节点</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandler</span> <span class="hljs-params">(Object argo)</span>; <span class="hljs-comment">// handler方法</span><br>&#125;<br><span class="hljs-comment">// 2.处理器具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue;&#125;<br><br><span class="hljs-comment">// 3.将处理器串成链表存储</span><br><span class="hljs-comment">// pipeline=头[ handler1 -&gt; handler2 -&gt;handler3]尾</span><br><br><span class="hljs-comment">// 4.处理请求，调用处理器(从头到尾)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Process</span><span class="hljs-params">( request)</span>&#123;<br>    handler = pipeline.findOne;<br>    <span class="hljs-comment">//查找第一个</span><br>    <span class="hljs-keyword">while</span>(hand != <span class="hljs-literal">null</span>)&#123;<br>        handler.doHandler(request);<br>        handler = handler.next();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-Netty-中的-ChannelPipeline-责任链"><a href="#二-Netty-中的-ChannelPipeline-责任链" class="headerlink" title="(二) : Netty 中的 ChannelPipeline 责任链"></a>(二) : Netty 中的 ChannelPipeline 责任链</h3><p><strong>Pipeline管道</strong>保存了通道所有处理器信息。</p><p>创建新channel时自动创建一个专有的pipeline。入站<strong>事件</strong>和出站<strong>操作</strong>会调用pipeline上的处理器</p><p><img src="/../java/image-2020072401.png"> </p><h2 id="二-事件"><a href="#二-事件" class="headerlink" title="二 : 事件"></a>二 : 事件</h2><h3 id="一-入站事件和出站事件"><a href="#一-入站事件和出站事件" class="headerlink" title="(一) 入站事件和出站事件"></a>(一) 入站事件和出站事件</h3><p><strong>入站事件 :</strong> 通常指I&#x2F;O线程生成了入站数据。(通俗理解:从socket底层自己往上冒上来的事件都是入站)</p><p>比如EventLoop收到selector的OP_READ事件，入站处理器调用socketChannel.read(ByteBuffer)接收到数据后，这将导致通道的ChannelPipeline中包含的下一个中的channelRead方法被调用。</p><p><strong>出站事件 :</strong> 经常是指I&#x2F;O线程执行实际的输出操作。(通俗理解:想主动往socket底层操作的事件的都是出站)</p><p>比如bind方法用意是请求server socket绑定到给定的SocketAddress，这将导致通道的ChannelPipeline中包含的下一个出站处理器中的bind方法被调用。</p><h3 id="二-Netty-中事件的定义"><a href="#二-Netty-中事件的定义" class="headerlink" title="(二) Netty 中事件的定义"></a>(二) Netty 中事件的定义</h3><p>入站事件(inbound)</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>fireChannelRegistered</td><td>channel注册事件</td></tr><tr><td>fireChannelUnregistered</td><td>channel解除注册事件</td></tr><tr><td>fireChannelActive</td><td>channel活跃事件</td></tr><tr><td>fireChannelInactive</td><td>channel非活跃事件</td></tr><tr><td>fireExceptionCaught</td><td>异常事件</td></tr><tr><td>fireUserEventTriggered</td><td>用户自定义事件</td></tr><tr><td>fireChannelRead</td><td>channel读事件</td></tr><tr><td>fireChannelReadComplete</td><td>channel读完成事件</td></tr><tr><td>fireChannelWritabilityChanged</td><td>channel写状态变化事件</td></tr></tbody></table><p>出站事件(outbound)</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>bind</td><td>端口绑定事件</td></tr><tr><td>connect</td><td>连接事件</td></tr><tr><td>disconnect</td><td>断开连接事件</td></tr><tr><td>close</td><td>关闭事件</td></tr><tr><td>deregister</td><td>解除注册事件</td></tr><tr><td>flush</td><td>刷新数据到网络事件</td></tr><tr><td>read</td><td>读事件，用于注册OP_READ到selector</td></tr><tr><td>write</td><td>写事件</td></tr><tr><td>writeAndFlush</td><td>写出数据事件</td></tr></tbody></table><h2 id="三-处理器"><a href="#三-处理器" class="headerlink" title="三 : 处理器"></a>三 : 处理器</h2><h3 id="一-Pipeline-中的-handler-是什么"><a href="#一-Pipeline-中的-handler-是什么" class="headerlink" title="(一) Pipeline 中的 handler 是什么"></a>(一) Pipeline 中的 handler 是什么</h3><p><strong>ChannelHandler :</strong> 用于处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作, 并转发到 ChannelPipeline 中的下一个处理器; 这个顶级接口定义功能很弱, 实际使用时会去实现以下两大子接口 : 处理入站 I&#x2F;O 事件的 ChannelInBoundHandler, 处理出站 I&#x2F;O 操作的 ChannelOutBoundHandler</p><p><strong>适配器类 :</strong> 为了开发方便, 避免所有 handler 去实现一遍接口方法, Netty 提供了简单的实现类</p><ul><li>处理入站 I&#x2F;O 事件 : ChannelInboundHandlerAdapter</li><li>处理出站 I&#x2F;O 事件 : ChannelOutboundHandlerAdapter</li><li>同时处理入站和出站事件 : ChannelDuplexHandler</li></ul><p><strong>ChannelHandlerContext :</strong> 实际存储在 Pipeline 中的对象并非 ChannelHandler, 而是上下文对象; 将 handler 包裹在上下文对象中, 通过上下文对象与它所属的 ChannelPipeline 交互, 向上或向下传递事件或者修改 pipeline 都是通过上下文对象</p><h3 id="二-维护-Pipeline-中的-handler"><a href="#二-维护-Pipeline-中的-handler" class="headerlink" title="(二) 维护 Pipeline 中的 handler"></a>(二) 维护 Pipeline 中的 handler</h3><p>ChannelPipeline是线程安全的，ChannelHandler可以在任何时候添加或删除。</p><p>例如，你可以在即将交换敏感信息时插入加密处理程序，并在交换后删除它。</p><p>一般操作，初始化的时候增加进去，较少删除。</p><p>Pipeline 中管理 handler 的API</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>addFirst</td><td>最前面插入</td></tr><tr><td>addLast</td><td>最后面插入</td></tr><tr><td>addBefore</td><td>插入到指定处理器前面</td></tr><tr><td>addAfter</td><td>插入到指定处理器后面</td></tr><tr><td>remove</td><td>移除指定处理器</td></tr><tr><td>removeFirst</td><td>移除第一个处理器</td></tr><tr><td>removeLast</td><td>移除最后一个处理器</td></tr><tr><td>replace</td><td>替换指定的处理器</td></tr></tbody></table><p>伪代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ...;<br>p.addLast(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundOutboundHandlerX</span>()); <span class="hljs-comment">// 聚合处理器</span><br></code></pre></td></tr></table></figure><h3 id="三-handler-的执行分析"><a href="#三-handler-的执行分析" class="headerlink" title="(三) handler 的执行分析"></a>(三) handler 的执行分析</h3><p>按之前伪代码逻辑, 现在的责任链如图所示</p><pre><code class=" mermaid">graph TDE[ChannelDuplexHandler5] --- D[Outbound Handler 4] --- C[Outbound Handler 3] --- B[Inbound Handler 2] --- A[Inbound Handler 1] </code></pre><p>由此可以推断 : </p><ul><li>当入站事件时, 执行顺序是 : 1 &#x3D;&gt; 2 &#x3D;&gt; 3 &#x3D;&gt; 4 &#x3D;&gt; 5</li><li>当出站事件时, 执行顺序是 : 5 &#x3D;&gt; 4 &#x3D;&gt; 3 &#x3D;&gt; 2 &#x3D;&gt; 1</li></ul><p>在这一原则之上, ChannelPipeline在执行时会进行选择3和4为出站处理器, 因此, 实际执行是 :</p><ul><li>入站事件的执行顺序是 1 &#x3D;&gt; 2 &#x3D;&gt; 5, 1和2为入站处理器</li><li>出站事件的执行顺序是 5 &#x3D;&gt; 4 &#x3D;&gt; 3</li></ul><p>不同的入站事件会触发handler不同的方法执行 : </p><ul><li><p>上下文对象中 <code>fire**</code> 开头的方法, 代表<strong>入站</strong>事件传播和处理</p></li><li><p>其余的方法代表<strong>出站</strong>事件的传播和处理。</p></li></ul><h2 id="四-分析"><a href="#四-分析" class="headerlink" title="四 : 分析"></a>四 : 分析</h2><h3 id="一-分析-registered-入站事件的处理"><a href="#一-分析-registered-入站事件的处理" class="headerlink" title="(一) 分析 registered 入站事件的处理"></a>(一) 分析 registered 入站事件的处理</h3><p><img src="/../java/image-2020072402.png"> </p><p>ServerSocketChannel.pipeline的变化</p><p><img src="/../java/image-2020072403.png" alt="image-2020072403"> </p><h3 id="二-分析-bind-出站事件的处理"><a href="#二-分析-bind-出站事件的处理" class="headerlink" title="(二) 分析 bind 出站事件的处理"></a>(二) 分析 bind 出站事件的处理</h3><p><img src="/../java/image-2020072404.png" alt="image-2020072404"> </p><h3 id="三-分析-accept-入站事件的处理"><a href="#三-分析-accept-入站事件的处理" class="headerlink" title="(三) 分析 accept 入站事件的处理"></a>(三) 分析 accept 入站事件的处理</h3><p><img src="/../java/image-2020072405.png" alt="image-2020072405"> </p><p>这是一个分配的过程，main Group负责accept，然后分配sub Group负责read</p><h3 id="四-分析-read-入站事件的处理"><a href="#四-分析-read-入站事件的处理" class="headerlink" title="(四) 分析 read 入站事件的处理"></a>(四) 分析 read 入站事件的处理</h3><p>pipeline分析的关键4要素:什么事件、有哪些处理器、哪些会被触发、执行顺序</p><p><img src="/../java/image-2020072406.png" alt="image-2020072406"> </p><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五 : 小结"></a>五 : 小结</h2><p>用户在管道中有一个或多个 channelhandler 来接收 I&#x2F;O 事件(例如读取)和请求 I&#x2F;O 操作(例如写入和关闭)</p><p>一个典型的服务器在每个通道的管道中都有以下处理程序, 但是根据协议和业务逻辑的复杂性和特征, 可能会有所不同</p><ul><li><p>协议解码器 : 将二进制数据(例如 ByteBuf)转换为 Java 对象</p></li><li><p>协议编码器 : 将 Java 对象转换为二进制数据</p></li><li><p>业务逻辑处理程序 : 执行实际的业务逻辑(例如数据库访问)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty线程模型</title>
    <link href="/2020/07/17/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/17/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Netty-简介"><a href="#一-Netty-简介" class="headerlink" title="一 : Netty 简介"></a>一 : Netty 简介</h2><p>Netty 是一个高性能, 高可扩展性的异步事件驱动的<strong>网络应用程序框架</strong>, 它极大地简化了 TCP 和 UDP 客户端和服务器开发等网络编程</p><p>官网 : <a href="https://netty.io/">https://netty.io/</a></p><p>Netty 重要的四个内容</p><ol><li>Reactor 线程模型 : 一种高性能的多线程程序设计思路</li><li>Netty 中自己定义的 Channel 概念 : 增强版的通道概念</li><li>ChannelPipeline 责任链设计模式 : 事件处理机制</li><li>内存管理 : 增强的 ByteBuffer 缓冲区</li></ol><h2 id="二-Netty-整体结构"><a href="#二-Netty-整体结构" class="headerlink" title="二 : Netty 整体结构"></a>二 : Netty 整体结构</h2><p><img src="/../java/image-2020071701.png" alt="image-2020071701"> </p><p>可以看出包含三大块 </p><ol><li>支持 Socket 等多种传输方式</li><li>提供了多种协议的编解码实现</li><li>核心设计包含<strong>事件处理模型, API的使用, ByteBuffer 的增强</strong></li></ol><h2 id="三-Netty-线程模型"><a href="#三-Netty-线程模型" class="headerlink" title="三 : Netty 线程模型"></a>三 : Netty 线程模型</h2><p>为了让 NIO 处理更好的利用多线程特性, Netty 实现了 Reactor 线程模型</p><p><img src="/../java/image-2020071702.png" alt="image-2020071702"> </p><p>Reactor 模型中有四个核心概念 : </p><ol><li>Resources 资源(请求&#x2F;任务)</li><li>Synchronous Event Demutiplexer 同步事件复用器</li><li>Dispatcher 分配器</li><li>Request Handler 请求处理器</li></ol><h2 id="四-EventLoopGroup-初始化过程"><a href="#四-EventLoopGroup-初始化过程" class="headerlink" title="四 : EventLoopGroup 初始化过程"></a>四 : EventLoopGroup 初始化过程</h2><p>如图所示, 两组 EventLoopGroup (Main&amp;Sub) 处理不同通道的事件</p><p><img src="/../java/image-2020071703.png" alt="image-2020071703"> </p><p>源码示例 : example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SslContext</span> <span class="hljs-variable">sslCtx</span> <span class="hljs-operator">=</span> ServerUtil.buildSslContext();<br><br>        <span class="hljs-comment">// Configure the server.</span><br>        <span class="hljs-comment">// 创建EventLoopGroup: accept线程组 NioEventLoop</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 指定线程数量,否则采用默认值</span><br>        <span class="hljs-comment">// 创建EventLoopGroup: I/O线程组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">EchoServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServerHandler</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 服务端启动引导工具类</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">// 配置服务端处理的reactor线程组以及服务端的其他配置</span><br>            b.group(bossGroup, workerGroup)<br>                .channel(NioServerSocketChannel.class)<br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                        <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>                            p.addLast(sslCtx.newHandler(ch.alloc()));<br>                        &#125;<br>                        <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                        p.addLast(serverHandler);<br>                    &#125;<br>                &#125;);<br><br>            <span class="hljs-comment">// Start the server. 通过bind启动服务</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.bind(PORT).sync();<br><br>            <span class="hljs-comment">// Wait until the server socket is closed. 阻塞主线程,知道网络服务被关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Shut down all event loops to terminate all threads. 关闭线程组</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-EventLoop-的启动"><a href="#五-EventLoop-的启动" class="headerlink" title="五 : EventLoop 的启动"></a>五 : EventLoop 的启动</h2><p>EventLoop 自身实现了 Executor 接口, 当调用 executor 方法提交任务时, 则判断是否启动, 未启动则调用内置的 executor 创建新线程来触发 run() 执行</p><p><img src="/../java/image-2020071704.png" alt="image-2020071704"> </p><h2 id="六-Bind-绑定端口过程"><a href="#六-Bind-绑定端口过程" class="headerlink" title="六 : Bind 绑定端口过程"></a>六 : Bind 绑定端口过程</h2><p>如图所示</p><p><img src="/../java/image-2020071705.png" alt="image-2020071705">  </p><h2 id="七-Channel-概念"><a href="#七-Channel-概念" class="headerlink" title="七 : Channel 概念"></a>七 : Channel 概念</h2><p>netty 中的 Channel 是一个抽象的概念, 可以理解为对 JDK NIO Channel 的增强和拓展; </p><p>增强了很多属性和方法, 完整信息可以看源码, 下面罗列几个常见的属性和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultAttributeMap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Channel</span> &#123;<br>    <span class="hljs-comment">// 通道内时间处理链路</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultChannelPipeline pipeline; <br>    <span class="hljs-comment">// 绑定的EventLoop,用于执行操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AbstractChannel.PausableChannelEventLoop eventLoop;<br>    <span class="hljs-comment">// 提供IO相关操作的封装</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><br>    <span class="hljs-comment">// 父类方法,返回通道配置信息</span><br>    ChannelConfig <span class="hljs-title function_">config</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 开始读数据,触发读取链路调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Channel <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        pipeline.read();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 写数据,触发链路调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> pipeline.write(msg);<br>    &#125;<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> &#123;<br>        <span class="hljs-keyword">return</span> pipeline.bind(localAddress);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八 : 小结"></a>八 : 小结</h2><p>毕竟抽象的设计模式, 在学习过程中会有难懂的地方, 所以着重需要结合代码理解</p><p>这里的目的有两个 : 领会 Reactor 的理念, 掌握代码示例中具体的写法</p><p><strong>重点关注服务端开发,</strong> 因为服务端要应对海量连接, 难度大, 而客户端仅仅是一个连接</p><p><strong>Reactor 多线程模式的设计, 是 Netty 高性能很重要的一个原因</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO非阻塞网络编程</title>
    <link href="/2020/07/10/NIO/"/>
    <url>/2020/07/10/NIO/</url>
    
    <content type="html"><![CDATA[<h2 id="一-java-NIO"><a href="#一-java-NIO" class="headerlink" title="一 : java NIO"></a>一 : java NIO</h2><p>始于 java 1.4, 提供了新的 JAVA IO 操作非阻塞 API; 用意是替代 Java IO 和 Java Networking 相关的 API</p><p>NIO 中有三个核心组件 : Buffer, Channel, Selector</p><h2 id="二-Buffer-缓冲区"><a href="#二-Buffer-缓冲区" class="headerlink" title="二 : Buffer 缓冲区"></a>二 : Buffer 缓冲区</h2><p><strong>缓冲区</strong>本质上是一个可以写入数据的内存块(类似数组), 然后可以再次读取; 此内存块包含在 NIO Buffer 对象中, 该对象提供了一组方法, 可以更轻松地使用内存块; </p><p>相比较直接对数组的操作, <strong>Buffer API 更加容易操作和管理;</strong> </p><p>使用 Buffer 进行数据写入与读取, 需要进行如下<strong>四个步骤</strong> : </p><ol><li>将数据写入缓冲区</li><li>调用 <code>buffer.flip()</code>, 转换为读取模式</li><li>缓冲区读取数据</li><li>调用 <code>buffer.clear()</code> 或 <code>buffer.compact()</code> 清除缓冲区</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建一个byte字节缓冲区，容量是4</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 默认写入模式，查看三个重要的指标</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;初始化：capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br>        <span class="hljs-comment">// 写入2字节的数据</span><br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">1</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">2</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 再看数据</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)</span><br>        System.out.println(<span class="hljs-string">&quot;#######开始读取&quot;</span>);<br>        byteBuffer.flip();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> byteBuffer.get();<br>        System.out.println(a);<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> byteBuffer.get();<br>        System.out.println(b);<br>        System.out.println(String.format(<span class="hljs-string">&quot;读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据</span><br>        <span class="hljs-comment">// clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式</span><br>        byteBuffer.compact(); <span class="hljs-comment">// buffer : 1 , 3</span><br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">3</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">4</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">5</span>);<br>        System.out.println(String.format(<span class="hljs-string">&quot;最终的情况，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// rewind() 重置position为0</span><br>        <span class="hljs-comment">// mark() 标记position的位置</span><br>        <span class="hljs-comment">// reset() 重置position为上次mark()标记的位置</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一-Buffer-工作原理"><a href="#一-Buffer-工作原理" class="headerlink" title="(一) Buffer 工作原理"></a>(一) Buffer 工作原理</h3><p>Buffer <strong>三个重要属性</strong> </p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>capacity</td><td>作为一个内存块, Buffer 具有一定的固定大小, 也称为<strong>容量</strong></td></tr><tr><td>position</td><td>写入模式时代表写数据的<strong>位置</strong>; 读取模式时代表读取数据的<strong>位置</strong></td></tr><tr><td>limit</td><td>写入模式, <strong>限制</strong>等于 buffer 的容量; 读取模式下, limit 等于写入的数据量</td></tr></tbody></table><p>读写模式</p><p><img src="/../java/image-2020071001.png" alt="读写模式"> </p><h3 id="二-ByteBuffer-内存类型"><a href="#二-ByteBuffer-内存类型" class="headerlink" title="(二) ByteBuffer 内存类型"></a>(二) ByteBuffer 内存类型</h3><p>ByteBuffer 为性能关键型代码提供了**直接内存(direct堆外)<strong>和</strong>非直接内存(heap堆)**两种实现</p><p>堆外内存获取的方式: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//堆内存(非直接内存)</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//直接内存(堆外内存)</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">directByteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>好处 : </p><ol><li>进行网络 IO 或者文件 IO 时比 heapBuffer 少一次拷贝(file&#x2F;socket &#x3D;&gt; OS memory &#x3D;&gt; jvm heap); GC 会移动对象内存, 在写 file 或 socket 的过程中, jvm 的实现中, 会先把数据复制到堆外, 再进行写入</li><li>GC 范围之外, 降低 GC 压力, 但实现了自动管理; DirectByteBuffer 中有一个 Cleaner 对象(PhantomReference), Cleaner 被 GC 前会执行 clean(), 触发 DirectByteBuffer 中定义的 Deallocator</li></ol><p><strong>建议 :</strong> </p><ol><li>性能确实可观的时候才去使用; 分配给大型, 长寿命的对象或应用(网络传输, 文件读写场景)</li><li>通过虚拟机参数 MaxDirectMemorySize 限制大小, 防止耗尽整个及其的内存</li></ol><h2 id="三-Channel-通道"><a href="#三-Channel-通道" class="headerlink" title="三 : Channel 通道"></a>三 : Channel 通道</h2><p>在 BIO 编程中一切网络操作是通过 socket + io 两者组合进行操作的, 也就是需要 io 包和 net 包; </p><pre><code class=" mermaid">graph LRA1[代码] --byte数据写入--&gt; outputStream ---|网络| inputStream --代码读取内容,read阻塞读取--&gt; B1[代码]</code></pre><p>而在 NIO 中则只需要 nio 包即可</p><pre><code class=" mermaid">graph LRA2[代码] --&gt; B2[buffer] --&gt;|缓冲区数据写入通道| C2[channel] ---|网络| D2[channel] --&gt;|通道数据写入缓冲区| E2[buffer] --&gt; F2[代码] </code></pre><p>Channel 的 API 涵盖了 UDP&#x2F;TCP 网络和文件 IO</p><ul><li>FileChannel</li><li><strong>DatagramChannel</strong></li><li><strong>SocketChannel</strong></li><li><strong>ServerSocketChannel</strong></li></ul><p>和标准 IO Stream 操作的区别</p><ul><li>在一个通道内进行读取和写入</li><li>stream 通常是单向的(inupt 或 ouput)</li><li>可以非阻塞读取和写入通道</li><li>通道始终读取或写入缓冲区</li></ul><h3 id="一-SocketChannel"><a href="#一-SocketChannel" class="headerlink" title="(一) SocketChannel"></a>(一) SocketChannel</h3><p>SocketChannel 用于建立 TCP 网络连接, 类似 java.net.Socket; </p><p>有两种创建 SocketChannel 形式 :</p><ol><li>客户端主动发起和服务器的连接</li><li>服务端获取的新连接</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 客户端主动发起连接的方式</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br>        socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-keyword">while</span> (!socketChannel.finishConnect()) &#123;<br>            <span class="hljs-comment">// 没连接上,则一直等待</span><br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>        <span class="hljs-comment">// 发送内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>            <span class="hljs-comment">// 发送请求数据 - 向通道写入数据</span><br>            socketChannel.write(buffer);<br>        &#125;<br>        <span class="hljs-comment">// 读取响应</span><br>        System.out.println(<span class="hljs-string">&quot;收到服务端响应:&quot;</span>);<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">// 读取服务端返回 - 读取缓冲区的数据: int bytesRead = socketChannel.read(byteBuffer)</span><br>        <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>            <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        requestBuffer.flip();<br>        <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>        requestBuffer.get(content);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>        scanner.close();<br>        <span class="hljs-comment">// 关闭连接</span><br>        socketChannel.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>write 写 : write() 在尚未写入任何内容时就可能返回了; 需要在循环中调用 write()</li><li>read 读 : read() 可能直接返回而根本不读取任何数据, 根据返回的 int 值判断读取了多少字节</li></ul><h3 id="二-ServerSocketChannel"><a href="#二-ServerSocketChannel" class="headerlink" title="(二) ServerSocketChannel"></a>(二) ServerSocketChannel</h3><p>ServerSocketChannel 可以监听新建的 TCP 连接通道, 类似 ServerSocket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建网络服务端</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>)); <span class="hljs-comment">// 绑定端口</span><br>        System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept(); <span class="hljs-comment">// 获取新tcp连接通道</span><br>            <span class="hljs-comment">// tcp请求 读取/响应</span><br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认是阻塞的,一定要设置为非阻塞</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ socketChannel.getRemoteAddress());<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        socketChannel.write(buffer);<span class="hljs-comment">// 非阻塞</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这种低效的循环检查,会是NIO服务端的正确开发方式吗 ?</span><br><span class="hljs-comment">         * 用到了非阻塞的API,在设计上,和BIO可以有很大的不同,需要仅需改进</span><br><span class="hljs-comment">         * 其实可以有这样一种思路,如果有连接,则将连接存起来,在没有连接的时候进行数据的读取和处理</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serverSocketChannel.accept()</code>, 如果该通道处于非阻塞模式, 那么如果没有挂起的连接, 该方法将立即返回 null ; <strong>必须检查</strong>返回的 SocketChannel 是否为 null</p><h2 id="四-Selector-选择器"><a href="#四-Selector-选择器" class="headerlink" title="四 : Selector 选择器"></a>四 : Selector 选择器</h2><p>Selector 是一个 java NIO 组件, 可以检查一个或多个 NIO 通道, 并确定哪些通道已准备好进行读取或写入; <strong>实现单个线程可以管理多个通道, 从而管理多个网络连接</strong></p><pre><code class=" mermaid">graph LRThread --&gt; Selector Selector --&gt; A1[Channel]Selector --&gt; A2[Channel]Selector --&gt; A3[Channel]  </code></pre><p>一个线程使用 Selector 监听多个 channel 的不同事件(四个事件分别对应 SelectionKey 四个常量) : </p><table><thead><tr><th>名称</th><th>描述</th><th>常量</th></tr></thead><tbody><tr><td>OP_CONNECT</td><td>Connect 连接</td><td>SelectionKey.OP_CONNECT</td></tr><tr><td>OP_ACCEPT</td><td>Accept 准备就绪</td><td>SelectionKey.OP_ACCEPT</td></tr><tr><td>OP_READ</td><td>Read 读取</td><td>SelectionKey.OP_READ</td></tr><tr><td>OP_WRITE</td><td>Write 写入</td><td>SelectionKey.OP_WRITE</td></tr></tbody></table><p>实现一个线程处理多个通道的核心概念理解 : <strong>事件驱动机制</strong></p><p>非阻塞的网络通道下, 开发者通过 Selector 注册对于通道感兴趣的事件类型, 线程通过监听事件来触发相应的代码执行</p><p><strong>拓展 : 更底层是操作系统的多路复用机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 注册感兴趣的事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br><span class="hljs-comment">// 由 accept 轮询, 变成了事件通知的方式</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// select 收到新的事件, 方法才会返回</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br>    <span class="hljs-keyword">if</span>(readyChannels == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKey();<br>    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br>    <span class="hljs-keyword">while</span>(keyIterator.hasNext())&#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-comment">// 判断不同的事件类型, 执行对应的逻辑处理</span><br>        <span class="hljs-comment">// key.isAcceptable()</span><br>        <span class="hljs-comment">// key.isConnectable()</span><br>        <span class="hljs-comment">// key.isReadable()</span><br>        <span class="hljs-comment">// key.isWritable()</span><br>        keyIterator.remove()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例(服务端)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServerV2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建网络服务端ServerSocketChannel</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br><br>        <span class="hljs-comment">// 2. 构建一个Selector选择器,并且将channel注册上去</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 将serverSocketChannel注册到selector</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, serverSocketChannel);<br>        <span class="hljs-comment">// 对serverSocketChannel上面的accept事件感兴趣(serverSocketChannel只能支持accept操作)</span><br>        selectionKey.interestOps(SelectionKey.OP_ACCEPT); <br><br>        <span class="hljs-comment">// 3. 绑定端口</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 不再轮询通道,改用下面轮询事件的方式.select方法有阻塞效果,直到有事件通知才会有返回</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历查询结果e</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-comment">// 被封装的查询结果</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.attachment();<br>                    <span class="hljs-comment">// 将拿到的客户端连接通道,注册到selector上面</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSocketChannel</span> <span class="hljs-operator">=</span> server.accept(); <span class="hljs-comment">// mainReactor 轮询accept</span><br>                    clientSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    clientSocketChannel.register(selector, SelectionKey.OP_READ, clientSocketChannel);<br>                    System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + clientSocketChannel.getRemoteAddress());<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.attachment();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                            <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束(此处做一个简单的判断:超过0字节就认为请求结束了)</span><br>                            <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                        requestBuffer.flip();<br>                        <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                        requestBuffer.get(content);<br>                        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                        System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span> + socketChannel.getRemoteAddress());<br>                        <span class="hljs-comment">// TODO 业务操作 数据库 接口调用等等</span><br><br>                        <span class="hljs-comment">// 响应结果 200</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                                <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                                <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                            socketChannel.write(buffer);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        <span class="hljs-comment">// e.printStackTrace();</span><br>                        key.cancel(); <span class="hljs-comment">// 取消事件订阅</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            selector.selectNow();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题: 此处一个selector监听所有事件,一个线程处理所有请求事件. 会成为瓶颈! 要有多线程的运用</p><h2 id="五-NIO-对比-BIO"><a href="#五-NIO-对比-BIO" class="headerlink" title="五 : NIO 对比 BIO"></a>五 : NIO 对比 BIO</h2><p>BIO 线程模型</p><p><img src="/../java/image-2020071002.png"> </p><ul><li>阻塞 IO , 线程等待时间长</li><li>一个线程负责一个连接处理</li><li>线程多且利用率低</li></ul><p>NIO 线程模型</p><p><img src="/../java/image-2020071003.png"> </p><ul><li>非阻塞 IO , 线程利用率更高</li><li>一个线程处理多个连接事件</li><li>性能更强大</li></ul><p>总结 : 如果你的程序需要支撑大量的连接, 使用 NIO 是最好的方式; Tomcat8 中, 已经完全取出 BIO 相关的网络处理代码, 默认采用 NIO 进行网络处理</p><h2 id="六-NIO-与多线程结合的改进方案"><a href="#六-NIO-与多线程结合的改进方案" class="headerlink" title="六 : NIO 与多线程结合的改进方案"></a>六 : NIO 与多线程结合的改进方案</h2><p>Doug Lea 的著名文章《Scalable IO in Java》; 地址 : <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p><strong>Worker Thread Pools</strong> : Reactor 线程接收请求 &#x3D;&gt; 分发给线程池处理请求</p><p><img src="/../java/image-2020071004.png"> </p><p><strong>Using Multiple Reactors</strong> : mainReactor 接收 &#x3D;&gt; 分发给 subReactor 读写 &#x3D;&gt; 具体业务逻辑分发给单独的线程池处理</p><p><img src="/../java/image-2020071005.png"> </p><p>代码示例 : NIO selector 多路复用reactor线程模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServerV3</span> &#123;<br>    <span class="hljs-comment">/** 处理业务操作的线程 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">workPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装了selector.select()等事件轮询的代码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        Selector selector;<br>        LinkedBlockingQueue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Selector监听到有事件后,调用这个方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">ReactorThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            selector = Selector.open();<br>        &#125;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 轮询Selector事件</span><br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 执行队列中的任务</span><br>                    Runnable task;<br>                    <span class="hljs-keyword">while</span> ((task = taskQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    selector.select(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">// 获取查询结果</span><br>                    Set&lt;SelectionKey&gt; selected = selector.selectedKeys();<br>                    <span class="hljs-comment">// 遍历查询结果</span><br>                    Iterator&lt;SelectionKey&gt; iter = selected.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-comment">// 被封装的查询结果</span><br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> key.readyOps();<br>                        <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>                        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">SelectableChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SelectableChannel) key.attachment();<br>                                channel.configureBlocking(<span class="hljs-literal">false</span>);<br>                                handler(channel);<br>                                <span class="hljs-keyword">if</span> (!channel.isOpen()) &#123;<br>                                    key.cancel(); <span class="hljs-comment">// 如果关闭了,就取消这个KEY的订阅</span><br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                                key.cancel(); <span class="hljs-comment">// 如果有异常,就取消这个KEY的订阅</span><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    selector.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-comment">// 为什么register要以任务提交的形式，让reactor线程去处理？</span><br>            <span class="hljs-comment">// 因为线程在执行channel注册到selector的过程中，会和调用selector.select()方法的线程争用同一把锁</span><br>            <span class="hljs-comment">// 而select()方法实在eventLoop中通过while循环调用的，争抢的可能性很高，为了让register能更快的执行，就放到同一个线程来处理</span><br>            FutureTask&lt;SelectionKey&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; channel.register(selector, <span class="hljs-number">0</span>, channel));<br>            taskQueue.add(futureTask);<br>            <span class="hljs-keyword">return</span> futureTask.get();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!running) &#123;<br>                running = <span class="hljs-literal">true</span>;<br>                start();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel serverSocketChannel;<br>    <span class="hljs-comment">// 1、创建多个线程 - accept处理reactor线程 (accept线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] mainReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 2、创建多个线程 - io处理reactor线程  (I/O线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] subReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">8</span>];<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化线程组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newGroup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建IO线程,负责处理客户端连接以后socketChannel的IO读写</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subReactorThreads.length; i++) &#123;<br>            subReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    <span class="hljs-comment">// work线程只负责处理IO处理，不处理accept事件</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (SocketChannel) channel;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (ch.isOpen() &amp;&amp; ch.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到数据,来自：&quot;</span> + ch.getRemoteAddress());<br><br>                    <span class="hljs-comment">// TODO 业务操作 数据库、接口...</span><br>                    workPool.submit(() -&gt; &#123;<br>                    &#125;);<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        ch.write(buffer);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建mainReactor线程, 只负责处理serverSocketChannel</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mainReactorThreads.length; i++) &#123;<br>            mainReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">incr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 只做请求分发，不做具体的数据读取</span><br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (ServerSocketChannel) channel;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ch.accept();<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 收到连接建立的通知之后，分发给I/O线程继续去读取数据</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> incr.getAndIncrement() % subReactorThreads.length;<br>                    <span class="hljs-type">ReactorThread</span> <span class="hljs-variable">workEventLoop</span> <span class="hljs-operator">=</span> subReactorThreads[index];<br>                    workEventLoop.doStart();<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> workEventLoop.register(socketChannel);<br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                &#125;<br>            &#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化channel,并且绑定一个eventLoop线程</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、 创建ServerSocketChannel</span><br>        serverSocketChannel = ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 2、 将serverSocketChannel注册到selector</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(mainReactorThreads.length);<br>        mainReactorThreads[index].doStart();<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> mainReactorThreads[index].register(serverSocketChannel);<br>        selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定端口</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//  1、 正式绑定端口，对外服务</span><br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        System.out.println(<span class="hljs-string">&quot;启动完成，端口8080&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NIOServerV3</span> <span class="hljs-variable">nioServerV3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NIOServerV3</span>();<br>        <span class="hljs-comment">// 1.创建main和sub两组线程</span><br>        nioServerV3.newGroup(); <br>        <span class="hljs-comment">// 2.创建serverSocketChannel，注册到mainReactor线程上的selector上</span><br>        nioServerV3.initAndRegister();<br>        <span class="hljs-comment">// 3.为serverSocketChannel绑定端口</span><br>        nioServerV3.bind(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七 : 小结"></a>七 : 小结</h2><p>NIO 为开发者提供了功能丰富及强大的 IO 处理 API, 但是在应用于网络应用开发的过程中, 直接使用 JDK 提供的 API, 比较繁琐; 而且要想将性能进行提升, 光有 NIO 还不够, 还需要将多线程技术与之结合起来</p><p>因为网络编程本身的复杂性, 以及 JDK API 开发的使用难度较高, 所以在开源社区中, 捅出来很多 JDK NIO 进行封装, 增强后的网络编程框架, 例如 : Netty, Mina等 </p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIO阻塞式网络编程</title>
    <link href="/2020/07/03/BIO/"/>
    <url>/2020/07/03/BIO/</url>
    
    <content type="html"><![CDATA[<h2 id="一-简单-C-x2F-S-程序"><a href="#一-简单-C-x2F-S-程序" class="headerlink" title="一 : 简单 C&#x2F;S 程序"></a>一 : 简单 C&#x2F;S 程序</h2><p>服务端示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<span class="hljs-comment">// 阻塞</span><br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 接收数据、打印</span><br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream(); <span class="hljs-comment">// net + i/o</span><br>                <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                String msg;<br>                <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 没有数据，阻塞</span><br>                    <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(msg);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    request.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOClient</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> s.getOutputStream();<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        out.write(msg.getBytes(charset)); <span class="hljs-comment">// 阻塞，写完成</span><br>        scanner.close();<br>        s.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-Http-协议"><a href="#二-Http-协议" class="headerlink" title="二 : Http 协议"></a>二 : Http 协议</h2><p>代码示例(和浏览器交互)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用多线程技术</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;tomcat 服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 接收数据、打印</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    String msg;<br>                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 阻塞</span><br>                        <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        System.out.println(msg);<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        request.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求数据包解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一部分: 请求行,请求类型,资源路径以及HTTP版本</span><br>GET /servlet-demo-1.0.0/index HTTP/1.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二部分: 请求头部,紧接着请求行(即第一行)之后的部分,用来说明服务器要使用的附加信息</span><br>Cache-Control: max-age=O<br>Accept: text/html<br>Accept-Language: zh-Hans-CN,zh-Hans;q=0.5<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Chrome/64.0.3282.140<br>Accept-Encoding: gzip, deflate<br>Host: 127.0.0.1:8080<br>Connection: Keep-Alive<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三部分: 空行,请求头部后面的空行是必须的请求头部和数据主体之间必须有换行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第四部分: 请求数据也叫主体,可以添加任意的数据(没有则不显示)</span><br></code></pre></td></tr></table></figure><p>响应数据包解析 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一部分: 状态行。HTTP版本、状态码、状态消息</span><br>HTTP/1.1 200 OK<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二部分: 响应报头部,紧接着请求行（即第一行)之后的部分,用来说明服务器要使用的附加信息</span><br>Content-Length: 11<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三部分:空行,头部后面的空行是必须的头部和数据主体之间必须有换行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第四部分:响应正文。可以添加任意的数据。例如“Hello World”</span><br>Hello World<br></code></pre></td></tr></table></figure><p>响应状态码</p><table><thead><tr><th>状态码</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>临时响应</td><td>表示临时响应并需要请求者继续执行操作的状态代码</td></tr><tr><td>2xx</td><td>成功</td><td>表示成功处理了请求的状态代码</td></tr><tr><td>3xx</td><td>重定向</td><td>表示要完成请求,需要进一步操作; 通常这些状态代码用来重定向</td></tr><tr><td>4xx</td><td>请求错误</td><td>这些状态代码表示请求可能出错,妨碍了服务器的处理</td></tr><tr><td>5xx</td><td>服务器错误</td><td>这些状态码表示服务器在尝试处理请求时发生内部错误; 这些错误可能是服务器本身的错误, 而不是请求出错</td></tr></tbody></table><h2 id="三-服务端升级版"><a href="#三-服务端升级版" class="headerlink" title="三 : 服务端升级版"></a>三 : 服务端升级版</h2><p>代码示例(和浏览器交互, 返回 Http 内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 接收数据、打印</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    String msg;<br>                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        System.out.println(msg);<br>                    &#125;<br><br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> request.getOutputStream();<br>                    outputStream.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>                    outputStream.write(<span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span>.getBytes());<br>                    outputStream.write(<span class="hljs-string">&quot;Hello World&quot;</span>.getBytes());<br>                    outputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        request.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-BIO-阻塞IO的含义"><a href="#四-BIO-阻塞IO的含义" class="headerlink" title="四 : BIO - 阻塞IO的含义"></a>四 : BIO - 阻塞IO的含义</h2><p><strong>阻塞(blocking) IO</strong> : 资源不可用时, IO 请求一致阻塞, 直到反馈结果(有数据或超时)</p><p><strong>非阻塞(non-blocking) IO</strong> : 资源不可用时, IO 请求离开返回, 返回数据标识资源不可用</p><p><strong>同步(synchronous) IO</strong> : 应用阻塞在发送或接受数据的状态, 直到数据成功传输或返回失败</p><p><strong>异步(asynchronous) IO</strong> : 应用发送或接受数据后立刻返回, 实际处理时异步执行的</p><p><strong>总结</strong> : 阻塞和非阻塞是<u>获取资源</u>的方式, 同步和异步是程序如何<u>处理资源</u>的逻辑设计; </p><ul><li>代码中使用的 API: ServerSocket#accept, InputStream#read 都是阻塞的 API</li><li>操作系统地层 API 中, 默认 Socket 操作都是 Blocking 型, send&#x2F;recv 等接口都是阻塞的</li></ul><p><strong>带来的问题</strong> : 阻塞导致在处理网络 I&#x2F;O 时, 一个线程只能处理一个网络连接</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/UDP协议</title>
    <link href="/2020/06/19/TCP&amp;UDP/"/>
    <url>/2020/06/19/TCP&amp;UDP/</url>
    
    <content type="html"><![CDATA[<h2 id="一-OSI-网络七层模型"><a href="#一-OSI-网络七层模型" class="headerlink" title="一 : OSI 网络七层模型"></a>一 : OSI 网络七层模型</h2><p>为使不同计算机厂家的计算机能够互相通信, 以便在更大的范围内建立计算机网络, 有必要建立一个国际范围的网络体系结构标准</p><p><img src="/../java/image-2020061901.png" alt="OSI 网络七层模型"> </p><p>也就是说 101010111100 中包含的数据内容为 : MAC 头部 + LLC 头部 + IP 头部 + TCP 头部 + 数据</p><h2 id="二-各层的主要功能"><a href="#二-各层的主要功能" class="headerlink" title="二 : 各层的主要功能"></a>二 : 各层的主要功能</h2><p><strong>低三层</strong> </p><ul><li>物理层 : 使原始的数据比特流能在物理介质上传输</li><li>数据链路层 : 通过校验, 确认和反馈重发等手段, 形成稳定的数据链路(01010101)</li><li>网络层 : 进行路由选择和流量控制(IP 协议)</li></ul><p><strong>中间层</strong></p><ul><li>传输层 : 提供可靠的端口到端口的数据传输服务(TCP&#x2F;UDP协议)</li></ul><p><strong>高三层</strong></p><ul><li>会话层 : 负责建立 , 管理和终止进程之间的会话和数据交换</li><li>表示层 : 负责数据格式转换, 数据加密与解密, 压缩与解压缩等</li><li>应用层 : 为用户的应用进程提供网络服务</li></ul><h2 id="三-传输控制协议-TCP"><a href="#三-传输控制协议-TCP" class="headerlink" title="三 : 传输控制协议 TCP"></a>三 : 传输控制协议 TCP</h2><p>传输控制协议(TCP) 使 Internet 一个重要的传输层协议; TCP 提供面向连接, 可靠, 有序, 字节流传输服务; 应用程序在使用 TCP 之前, 必须先建立 TCP 连接</p><p><img src="/../java/image-2020061902.png"> </p><p>标志位说明</p><table><thead><tr><th>标志位</th><th>说明</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针</td></tr><tr><td><strong>ACK</strong></td><td>确认序号</td></tr><tr><td>PSH</td><td>有 DATA 数据传输</td></tr><tr><td>RST</td><td>连接重置</td></tr><tr><td><strong>SYN</strong></td><td>建立连接</td></tr><tr><td><strong>FIN</strong></td><td>关闭连接</td></tr></tbody></table><h2 id="四-TCP-握手机制"><a href="#四-TCP-握手机制" class="headerlink" title="四 : TCP 握手机制"></a>四 : TCP 握手机制</h2><p>三次握手过程</p><p><img src="/../java/image-2020061903.png" alt="三次握手">  </p><p>四次挥手过程</p><p><img src="/../java/image-2020061904.png" alt="四次挥手"> </p><h2 id="五-用户数据报协议-UDP"><a href="#五-用户数据报协议-UDP" class="headerlink" title="五 : 用户数据报协议 UDP"></a>五 : 用户数据报协议 UDP</h2><p>用户数据报协议 UDP 是 Internet 传输层协议; 提供无连接, 不可靠, 数据报尽力传输服务</p><p><img src="/../java/image-2020061905.png" alt="UDP数据结构"> </p><p>开发应用人员在 <strong>UDP 上构建应用, 关注以下几点 :</strong> </p><ol><li>应用进程更容易控制发送什么数据以及何时发送</li><li>无需建立连接</li><li>无连接状态</li><li>首部开销小</li></ol><h2 id="六-UDP-和-TCP-比较"><a href="#六-UDP-和-TCP-比较" class="headerlink" title="六 : UDP 和 TCP 比较"></a>六 : UDP 和 TCP 比较</h2><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>无连接</td></tr><tr><td>提供可靠性保证</td><td>不可靠</td></tr><tr><td>慢</td><td>快</td></tr><tr><td>资源占用多</td><td>资源占用少</td></tr></tbody></table><p>什么时候会用到UDP呢? 对数据可靠性要求不高的情况, 例如音视频聊天, 物联网数据上报之类; 也就是说我们的关注点是现在发生了什么而不是过去发生了什么</p><h2 id="七-Socket-编程"><a href="#七-Socket-编程" class="headerlink" title="七 : Socket 编程"></a>七 : Socket 编程</h2><p>Internet 中应用最广泛的网络应用编程接口, 实现与 3 种底层协议接口:</p><ul><li>数据报类型套接字 SOCK_DGRAM (面向 UDP 接口)</li><li>流式套接字 SOCK_STREAM (面向 TCP 接口)</li><li>原始套接字 SOCK_RAW (面向网络层协议接口 IP, ICMP 等)</li></ul><p>主要 socket API 及其调用过程 :</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">创建套接字 <span class="hljs-operator">=</span>&gt; 端点绑定 <span class="hljs-operator">=</span>&gt; 发送数据 <span class="hljs-operator">=</span>&gt; 接收数据 <span class="hljs-operator">=</span>&gt; 释放套接字<br></code></pre></td></tr></table></figure><p>Socket API 函数定义</p><ul><li>listen(), accept() 函数只能用于服务器端</li><li>connect() 函数只能用于客户端</li><li>socket(), bind(), send(), recv(), sendto(), recvfrom(), close()</li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FutureTask源码剖析</title>
    <link href="/2020/06/12/FutureTask/"/>
    <url>/2020/06/12/FutureTask/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Future"><a href="#一-Future" class="headerlink" title="一 : Future"></a>一 : Future</h2><p>Future 表示异步计算的结果, 提供了用于检查计算是否完成, 等待计算完成以及获取结果的方法</p><p><img src="/../java/image-2020061201.png" alt="image-2020061201"></p><p>Future 和 Callable</p><ol><li><p>Callable 和 Runnable 一样的业务定义, 但本质上有区别(返回值, 异常定义), 表面的区别并不是最重要的, 重要的是我们要看内在, <strong>内在的一个本质上的点是 Callable 是被 Runnable 调用的, 也就是说 <code>call()</code> 运行在 <code>run()</code> 里面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread并不能传入Callable, 但是我们可以通过FutureTask来使用callable</span><br>Callable&lt;Object&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callalbe</span>&lt;Object&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object call <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>FutureTask&lt;Object&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当然也可以用线程池直接使用</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>executorService.submit(callable);<br></code></pre></td></tr></table></figure></li><li><p>在线程执行完后可以直接在 futureTask 中拿结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">futureTask.get();<br></code></pre></td></tr></table></figure></li></ol><h2 id="二-FutureTask-应用"><a href="#二-FutureTask-应用" class="headerlink" title="二 : FutureTask 应用"></a>二 : FutureTask 应用</h2><p><img src="/../java/image-2020061202.png" alt="image-2020061202"> </p><p>总的执行时间, 取决于执行最慢的逻辑</p><p>逻辑之间无依赖关系, 可同时执行, 则可以应用<strong>多线程技术进行优化</strong></p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceFutureTask</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-comment">// Future &lt; &gt;  Callable</span><br>        <span class="hljs-comment">// 和runnable一样的业务定义,但是本质上是有区别的: 返回值 异常 call run.</span><br>        Callable&lt;JSONObject&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;JSONObject&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-comment">// 1. 先从调用获取用户基础信息的http接口</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://www.tony.com/userinfo-api/get?userId=&quot;</span> + userId, String.class);<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(value);<br>                System.out.println(<span class="hljs-string">&quot;userinfo-api用户基本信息接口调用时间为&quot;</span> + (System.currentTimeMillis() - userinfoTime));<br>                <span class="hljs-keyword">return</span> userInfo;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 通过多线程运行callable</span><br>        FutureTask&lt;JSONObject&gt; userInfoFutureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(userInfoFutureTask).start();<br><br>        FutureTask&lt;JSONObject&gt; intergralInfoTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 2. 再调用获取用户积分信息的接口</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">integralApiTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">intergral</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://www.tony.com/integral-api/get?userId=&quot;</span> + userId,<br>                    String.class);<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">intergralInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(intergral);<br>            System.out.println(<span class="hljs-string">&quot;integral-api积分接口调用时间为&quot;</span> + (System.currentTimeMillis() - integralApiTime));<br>            <span class="hljs-keyword">return</span> intergralInfo;<br>        &#125;);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(intergralInfoTask).start();<br><br>        <span class="hljs-comment">// 3. 合并为一个json对象</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        result.putAll(userInfoFutureTask.get()); <span class="hljs-comment">// 会等待任务执行结束</span><br>        result.putAll(intergralInfoTask.get());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-线程安全性级别"><a href="#三-线程安全性级别" class="headerlink" title="三 : 线程安全性级别"></a>三 : 线程安全性级别</h2><p>《Effective Java》- Joshua J.Block 提到, 工具类需要显示的说明它的安全性级别 :</p><ol><li><strong>不可变的</strong> : 这个类的实例是不可变的; 这样的例子包括 String, Long, BigInteger</li><li><strong>无条件的线程安全</strong> : 这个类的实例是可变的, 但是这个类有组偶的内部同步; 例子包括 Random, ConcurrentHashMap</li><li><strong>有条件的线程安全</strong> : 除了有些方法为进行安全的并发使用而需要外部同步之外, 这种线程安全级别与无条件相同; 例如包括: Collections.synchronized 包装返回的集合, 他们的迭代器要求外部同步</li><li><strong>非线程安全</strong> : 这个类的实例是可变的; 为了并发使用它们, 客户必须利用自己选择的外部同步包围每个方法调用, 例子包括 ArrayList</li><li><strong>线程对立</strong> : 这个类不能安全地被多个线程并发使用, 即使所有的方法调用都被外围同步包围</li></ol><h2 id="四-JDK-学习思路汇总"><a href="#四-JDK-学习思路汇总" class="headerlink" title="四 : JDK 学习思路汇总"></a>四 : JDK 学习思路汇总</h2><p>积累 : 由基层知识再到封装的工具类, 足够多的 “因” 才能推理出 “果”; 基层不代表基础, 不代表简单;</p><p>思路 : 从顶层看使用, 从底层看原理</p><p>结语 : 多线程编程中, 不变的是<strong>内存模型</strong>和<strong>线程通信</strong>两个核心技术点, 变化的是各种程序设计想法(算法)</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fork/Join并发处理框架</title>
    <link href="/2020/06/05/Fork&amp;Join/"/>
    <url>/2020/06/05/Fork&amp;Join/</url>
    
    <content type="html"><![CDATA[<h2 id="一-用来做什么"><a href="#一-用来做什么" class="headerlink" title="一 : 用来做什么"></a>一 : 用来做什么</h2><p>ForkJoinPool 是 ExecutorService 接口的实现, 它专为可以递归分解成小块的工作而设计; </p><p>fork&#x2F;join 框架将任务分配给线程池中的工作线程, 充分利用多处理器的优势, 提高程序性能</p><p>使用 fork&#x2F;join 框架的第一步是编写执行一部分工作的代码; 类似的伪代码如下</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">如果<span class="hljs-comment">(当前工作部分足够小)</span><br>直接做这项工作<br>其他<br>把当前工作分成两部分<br>调用这两个部分并等待结果<br></code></pre></td></tr></table></figure><p>将此代码包装在 ForkJoinTask 子类中, 通常是 RecursiveTask (可以返回结果) 或 RecursiveAction</p><h2 id="二-意图梳理"><a href="#二-意图梳理" class="headerlink" title="二 : 意图梳理"></a>二 : 意图梳理</h2><p>关键点 :  : 分解任务fork出新任务, 汇集join任务执行结果</p><pre><code class=" mermaid">graph TD提交任务 --&gt; ForkJoinTaskForkJoinTask --fork--&gt; process-1process-1 --&gt; process-1.1process-1 --&gt; process-1.2ForkJoinTask --fork--&gt; process-2process-2 --&gt; process-2.1process-2 --&gt; process-2.2process-2.1 -. join .-&gt; process-2process-2.2 -. join .-&gt; process-2</code></pre><h2 id="三-经典网关场景-查询多个系统数据"><a href="#三-经典网关场景-查询多个系统数据" class="headerlink" title="三 : 经典网关场景, 查询多个系统数据"></a>三 : 经典网关场景, 查询多个系统数据</h2><p>移动互联网的情况</p><ul><li>一个接口请求要获取很多信息</li><li>后端分布式系统, 拆分成多个子系统</li></ul><p>后端接口执行(大概流程)</p><ol><li>收到一个请求</li><li>调用多个服务接口获取其他系统的数据</li><li>最后汇总返回</li></ol><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-comment">// 1. 先从调用获取用户基础信息的http接口</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://172.16.0.1/userinfo-api/get?userId=&quot;</span> + userId, String.class);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(value);<br>        System.out.println(<span class="hljs-string">&quot;userinfo-api用户基本信息接口调用时间为&quot;</span> + (System.currentTimeMillis() - userinfoTime));<br><br>        <span class="hljs-comment">// 2. 再调用获取用户积分信息的接口</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">integralApiTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">intergral</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://172.16.0.1/integral-api/get?userId=&quot;</span> + userId,<br>                String.class);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">intergralInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(intergral);<br>        System.out.println(<span class="hljs-string">&quot;integral-api积分接口调用时间为&quot;</span> + (System.currentTimeMillis() - integralApiTime));<br><br>        <span class="hljs-comment">// 再调用一个接口 +n秒</span><br><br>        <span class="hljs-comment">// 3. 合并为一个json对象</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        result.putAll(userInfo);<br>        result.putAll(intergralInfo);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意 : 代码逻辑涉及到串行的过程, 运行时间会发生累计, 随着需要调用的接口的数量的增多, 响应时间会越来越长</p><p>针对于<strong>响应时间限制</strong>, 通常开发公司会有明确规定, 例如 : 内部调用的核心接口的响应时间通常为10ms, 对外可以扩展到50ms</p><p>代码优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpJsonRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;JSONObject&gt; &#123;<br><br>    RestTemplate restTemplate;<br>    ArrayList&lt;String&gt; urls;<br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br><br>    HttpJsonRequest(RestTemplate restTemplate, ArrayList&lt;String&gt; urls, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>        <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>        <span class="hljs-built_in">this</span>.urls = urls;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-comment">// 就是实际去执行的一个方法入口(任务拆分)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> JSONObject <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> end - start; <span class="hljs-comment">// 代表当前这个task需要处理多少数据</span><br>        <span class="hljs-comment">// 自行根据业务场景去判断是否是大任务,是否需要拆分</span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.get(start);<br>            <span class="hljs-comment">// TODO 如果只有一个接口调用,立刻调用</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, String.class);<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> JSONObject.parseObject(response);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 接口调用完毕&quot;</span> + (System.currentTimeMillis() - userinfoTime) + <span class="hljs-string">&quot; #&quot;</span> + url);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果是多个接口调用,拆分成子任务  7,8,   9,10</span><br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;任务拆分一次&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, start, x);<span class="hljs-comment">// 负责处理哪一部分?</span><br>            httpJsonRequest.fork();<br><br>            <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, x + <span class="hljs-number">1</span>, end);<span class="hljs-comment">// 负责处理哪一部分?</span><br>            httpJsonRequest1.fork();<br><br>            <span class="hljs-comment">// join获取处理结果</span><br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            result.putAll(httpJsonRequest.join());<br>            result.putAll(httpJsonRequest1.join());<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并行调用http接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceForkJoin</span> &#123;<br>    <span class="hljs-comment">// 本质是一个线程池,默认的线程数量:CPU的核数</span><br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">10</span>, ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>            <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// fork/join</span><br>        <span class="hljs-comment">// forkJoinPool.submit()</span><br>        ArrayList&lt;String&gt; urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        urls.add(<span class="hljs-string">&quot;http://172.16.0.1/userinfo-api/get?userId=&quot;</span> + userId);<br>        urls.add(<span class="hljs-string">&quot;http://172.16.0.1/integral-api/get?userId=&quot;</span> + userId);<br><br>        <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, <span class="hljs-number">0</span>, urls.size() - <span class="hljs-number">1</span>);<br>        ForkJoinTask&lt;JSONObject&gt; forkJoinTask = forkJoinPool.submit(httpJsonRequest);<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinTask.get();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-实现思路"><a href="#四-实现思路" class="headerlink" title="四 : 实现思路"></a>四 : 实现思路</h2><p>每个 Worker 线程都维护一个任务队列, 即 ForkJoinWorkerThread 中的任务队列</p><p>任务队列是双向队列, 这样可以同时实现 LIFO(last in first out, 后进先出) 和 FIFO(first in first out, 先进先出)</p><p>子任务会被加入到原先任务所在 worker 线程的任务队列(workQueue); worker 线程用 LIFO 的方法取出任务, 后进队列的任务先取出来(子任务总是后加入队列, 但是需要先执行); <strong>当任务队列为空, 会随机从其他的 worker 的队列中拿走一个任务执行</strong>(工作窃取: steal work);</p><p>如果一个 worker 线程遇到了 join 操作, 而这时候, 正在处理其他任务, 会等到这个任务结束; 否则直接返回</p><p>如果一个 worker 线程窃取任务失败, 它会用 yield 或者 sleep 之类的方法休息一会儿, 再尝试(如果所有线程都是空闲状态, 即没有任务运行, 那么该线程也会进入阻塞状态等待新任务的到来)</p><h2 id="五-适用"><a href="#五-适用" class="headerlink" title="五 : 适用"></a>五 : 适用</h2><p><strong>使用尽可能少的线程池</strong> : 再大多数情况下, 最好的决定是为每个应用程序或系统使用一个线程池</p><p>如果不需要特定调整, 请使用默认的公共线程池</p><p>使用合理的阈值将 ForkJoinTask 拆分为子任务</p><p>避免在 ForkJoinTask 中出现任何阻塞</p><p><strong>适用场景</strong> : 数据处理, 结果汇总, 统计等; </p><p><strong>java8实例 :</strong> java.util.Arrays 类用于其 parallelSort() 方法就用到了 fork&#x2F;join; 其目的是进行内存运算方面的操作, 因此<strong>不适合</strong>用于网络接口调用, 数据库查询, 文件操作等; 所以如果需要使用, 只定义一个 ForkJoinPool 就好, 线程数量尽量和 CPU 核数差不多, 主要进行非阻塞的代码处理</p><h2 id="六-结语"><a href="#六-结语" class="headerlink" title="六 : 结语"></a>六 : 结语</h2><p>总结 :</p><ol><li>本质上是一个线程池, 如果需要使用, 只需要定义一个 ForkJoinPool 即可</li><li>线程数量尽量和 CPU 核心数差不多; 例如 8 核 CPU 就设置 8 个线程</li><li>适用于非阻塞(non blocking)的代码处理; 如网络接口调用, 数据库查询, 文件操作等操作<strong>并不适用</strong></li></ol><p>工作窃取带来的性能提升偏理论, API 的复杂性高, 实际研发中可控性来说不如其他 API, <strong>非内存操作并不适用</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器类(二)</title>
    <link href="/2020/05/29/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB2/"/>
    <url>/2020/05/29/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB2/</url>
    
    <content type="html"><![CDATA[<h2 id="一-List"><a href="#一-List" class="headerlink" title="一 : List"></a>一 : List</h2><p>单纯的 List 如果实际操作过程中, 不可以一边遍历一边删除, 这时就可以用到 CopyOnWriteArrayList</p><p>CopyOnWriteArrayList 容器即<strong>写时复制</strong>的容器, 实现原理 :</p><ol><li>对当前 List 加锁</li><li>将原先的 array 复制一个新的数组(newElements)</li><li>对复制的数组进行修改</li><li>对原有数组进行替换</li></ol><p>和 ArrayList 比较, 优点是并发安全, 缺点有两个 :</p><ol><li>多了内存占用: 写数据是 copy 一份完整的数据, 单独进行操作; 占用双份内存</li><li>数据一致性: 数据写完之后, 其他线程不一定是马上读取到最新内容</li></ol><h2 id="二-Set"><a href="#二-Set" class="headerlink" title="二 : Set"></a>二 : Set</h2><p>set 和 list 重要区别 : <strong>不重复</strong>; 重要 API 实现原理及特点</p><table><thead><tr><th>实现</th><th>原理</th><th>特点</th></tr></thead><tbody><tr><td>HashSet</td><td>通过 HashMap 进行存储, 将 value 作为 key, 从而实现了 Set 数据不重复的作用</td><td>非线程安全</td></tr><tr><td>CopyOnWriteArraySet</td><td>基于 CopyOnWriteArrayList</td><td>线程安全</td></tr><tr><td>ConcurrentSkipListSet</td><td>基于 ConcurrentSkipListMap</td><td>线程安全, 有序, 查询快</td></tr></tbody></table><h2 id="三-Queue"><a href="#三-Queue" class="headerlink" title="三 : Queue"></a>三 : Queue</h2><p>重要 API 介绍</p><table><thead><tr><th>方法</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>add</td><td>增加一个元素</td><td>如果队列已满, 则抛出一个 illealStateException 异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空, 则抛出一个 NoSuchElementException 异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空, 则抛出一个 NoSuchElementException 异常</td></tr><tr><td>offer</td><td>添加一个元素并返回 true</td><td>如果队列已满, 则返回 false</td></tr><tr><td>poll</td><td>移除并返回队列头部的元素</td><td>如果队列为空, 则返回 null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空, 则返回 null</td></tr><tr><td>put</td><td>添加一个元素</td><td><strong>如果队列满, 则阻塞</strong></td></tr><tr><td>take</td><td>移除并返回队列头部的元素</td><td><strong>如果队列为空, 则阻塞</strong></td></tr></tbody></table><p><strong>ArrayBlockingQueue :</strong> 基于数组的阻塞循环队列, 此队列按FIFO(先进先出)原则对元素进行排序; 注意put和offer的区别: put会阻塞, offer不会阻塞直接返回false</p><p><strong>LinkedBlockingQueue :</strong> 基于链表的队列,此队列按 FIFO 排序; 如果有阻塞需求,用这个; 类似生产者消费者模式</p><p><strong>ConcurrentLinkedQueue :</strong> 优势: 无锁; 注意: 批量操作不提供原子性保证(addAll,removeAll,retainAll,containsAll,equals,and toArray); 坑: size() 每次都是便利整个链表,最好不要频繁调用; 如果没有阻塞要求,用这个挺好(堆积数据)</p><p><strong>PriorityQueue :</strong> 是一个带优先级的队列,而不是先进先出; 元素按优先级顺序被移除,该队列也没有上限; 没有容量限制,自动扩容; 虽然在逻辑上是无界的,但是由于资源被耗尽,所以试图执行添加操作可能会导致OutOfMemoryError; 如果队列为空,那么取出元素的take操作就会阻塞,所以它的检索操作take是受阻的; 另外,加入该队列的元素要具有比较能力</p><p><strong>PriorityBlockingQueue :</strong> 封装了 PriorityQueue; 是一个带优先级的队列, 而不是先进先出队列; 元素按优先级顺序被移除, 该队列也没有上限; 没有容量限制的, 自动扩容; 芮苒此队列逻辑上是无界的, 但是由于资源被耗尽, 所以试图执行添加操作可能会导致 OutOfMemoryError; 但如果队列为空, 那么取元素的操作take就会阻塞, 所以它的检索操作take是受阻的; 另外, 加入队列中的元素要具有比较能力</p><p><strong>DelayQueue :</strong> 基于PriorityQueue来实现的, 是一个存放Delayed 元素的无界阻塞队列; 只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素; 如果延迟都还没有期满，则队列没有头部，并且poll将返回null; 当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时; 则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素</p><p><strong>SynchronousQueue :</strong> 这是一个神奇的队列, 因为他不存数据, 手把手的交互数据; 非阻塞方法无效, 只能使用阻塞方法 put&#x2F;take</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器类</title>
    <link href="/2020/05/22/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <url>/2020/05/22/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-学习方法"><a href="#一-学习方法" class="headerlink" title="一 : 学习方法"></a>一 : 学习方法</h2><p><strong>逻辑思维能力是梳理学习方法的基础</strong>; 养成线程思维: 两个或者多个给概念,像一条线串起来</p><p>首先要经过<strong>演绎推导法</strong>进行<strong>因果推理</strong>; 比如java中网络编程只提供了BIO和NIO两种方式, 所以一切框架中, 涉及到网络处理的, 都可以用这两个知识点去探究原理</p><p>然后采用<strong>归纳总结法</strong>提出可能正确的<strong>猜想</strong>; 比如线上10台服务器, 有三台总是每天会自动重启, 收集相关信息后, 发现是运维在修改监控系统配置的时候, 漏掉了提高这三台服务器的重启阈值</p><p>最后要使用<strong>类比法</strong>进行思维固化; 比如<strong>集群</strong>概念就好像是马在拉车,一匹马拉不动的时候,就是用多匹马去拉; <strong>分布式</strong>的概念, 就像是理发的过程中, 洗头发和剪头发是不同的人负责的</p><h2 id="二-推理-HashMap-的实现"><a href="#二-推理-HashMap-的实现" class="headerlink" title="二 : 推理 HashMap 的实现"></a>二 : 推理 HashMap 的实现</h2><p>数据要存储</p><ul><li>涉及到数据结构 : <strong>数组</strong>, <strong>链表</strong>, <strong>栈</strong>, <strong>树</strong>, <strong>队列</strong></li></ul><p>数组的插入和查找</p><ul><li><strong>顺序查找 :</strong> 插入时按先后顺序插入, 查找时轮询扫描进行对比</li><li><strong>二分查找 :</strong> 插入时进行排序; 查找时将 n 个元素分成大致相等的两部分, 减少复杂度</li><li><strong>分块查找 :</strong> 分块查找是二分查找和顺序查找的一种改进</li><li><strong>哈希表 :</strong> 对元素的关键信息进行 hash 计算, 求出下标后直接插入或查找; 常用的实现是除留余数法</li></ul><p>哈希冲突, 数组位置已存在值</p><ul><li>hash(key2) &#x3D; hash(key1); 链地址法; ReHash1(key2) 再次计算 hash;</li></ul><p>合理控制数组和链表的长度</p><ul><li>动态扩容 resize()</li></ul><h2 id="三-HashMap"><a href="#三-HashMap" class="headerlink" title="三 : HashMap"></a>三 : HashMap</h2><p>jdk1.7:</p><ul><li>数据结构 : 数组 + 链表, Entry&lt;K,V&gt;[] table;</li><li>实现原理 : 计算key的hash值,然后根据数组长度进行除留余数法确定数组位置; 如果是存入,先判定key存在不存在,若存在覆盖value的值;若不存在,则放在链表的最后, 如果是读取采用顺序查找法进行比对</li><li>扩容规则 : 初始容量 16, 扩容因子 0.75;<ol><li>如果有初始长度, 则会以最靠近指定长度的2的幂次进行定容,例如: 519则会定为1024</li><li>如果储存的值超过容量的 0.75 倍, 以 2 倍方式进行扩容, 存储的元素会重新排列</li></ol></li></ul><p>jdk1.8:</p><ul><li>数据结构: Node&lt;K,V&gt;[] table; 别以为有啥变化, Node 和 Entry 结构一样; 在jdk1.7的基础上进行了改进,在数据结构上引入了树形结构</li><li>链表阈值8, 最小容量 64<ol><li>如果单个链表容量超过 8, 该链表则自动转为红黑树</li><li>如果链表达到8, 但是数组没有超过 64, 只会 resize 而不会生成树</li></ol></li><li>由于有扩容机制的存在, 所以用到红黑树的概率很低, 同时, 维护树也是对性能的消耗</li></ul><h2 id="四-ConcurrentHashMap"><a href="#四-ConcurrentHashMap" class="headerlink" title="四 : ConcurrentHashMap"></a>四 : ConcurrentHashMap</h2><p>jdk1.7</p><ul><li>数据结构 : Segment&lt;K,V&gt;[] segments;<ul><li>Segment是个啥? 每个存储单元称为segment, 结构上没有任何区别, 但是它继承了ReentrantLock, 每个segment中包含一个 HashEntry[]</li><li>那HashEntry又是个啥? 主要包含hash值, key, value 和 next, 就是HashMap中的Entry呀! 那 Segment 不就是个map吗, 也就是说每个 segment 就是一个 HashMap</li></ul></li><li>设计原理 :<ul><li>也就是说 ConcurrentHashMap 不能扩容,但是 Segment 可以扩容</li><li>这不是有病吗? 这设计太鬼才了! 是否会存在设计过度的嫌疑, 我感觉有点绕弯; Segment 的数量定死就是16个,还高大上的起了个名字叫<strong>分段锁</strong>, 但实质上也就只能支持16个并发量</li><li>既然是为了提高并发操作的安全性, 那我为什么不在每个 HashMap 中的每个 Entry 上加一把锁呢</li></ul></li><li>扩容规则 : 和 HashMap 稍微有些区别, 数组的容量是固定的16个</li></ul><p>jdk1.8</p><ul><li>数据结构 : Node&lt;K,V&gt; table; 数组 + 链表</li><li>初始容量16, 扩容银子 0.75, 阈值也是 8, 最小容量 64</li><li>设计原理 : 设计思路完全改变, 和HashMap是一样的; 那怎么保证线程安全和并发量的? synchronized? Lock接口? CAS?; 查看源码,初始化是通过CAS实现的, put 是 sync</li><li>但是它是怎么保证线程安全的呢?<ol><li>初始化采用 cas 机制</li><li>put 的时候, 如果当前位置为 null, 采用 cas 机制</li><li>如果不为 null, 则使用同步关键字</li></ol></li></ul><h2 id="五-ConcurrentSkipListMap"><a href="#五-ConcurrentSkipListMap" class="headerlink" title="五 : ConcurrentSkipListMap"></a>五 : ConcurrentSkipListMap</h2><p>特点 : <strong>有序链表</strong>实现, <strong>无锁</strong>实现; value 不能为空; 层级越高跳跃性越大, 数据越少, 查询理论变快;</p><p>和 HashMap 的结构完全不一样, 跳表中包含了一个 index, 在 index 中存储 Node 节点的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> &#123;<br>    Node node;<br>    Index right; <span class="hljs-comment">//先比对入口索引, 如果大于入口索引,则向右进行比对</span><br>    Index down;  <span class="hljs-comment">//如果小于右边的索引, 则向下比对</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    String key;<br>    String value;<br>    Node next;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入 Node 节点的时候, 随机创建索引(创建一个随机数, 如果是偶数, 就创建索引); 如果数据量大, 索引量大也会导致查询效率降低, 这时候引入索引分级的概念</p><p>索引分级: 根据生成的随机数的<strong>二进制数的连续为 1 的数量</strong>来确定 level ; 每层的元素, headIndex 固定为所有 node 中最小的</p><p>查找数据时, 按照<strong>先从左到右, 后从上到下</strong>的顺序查找; 时间复杂度O(log n), 空间复杂度O(n); 性能提升思路就是常说的空间换时间, 数据库索引类似的概念, skiplist 在很多开源组件中有使用 (level DB, Redis)</p><p>关于线程安全方面, 依然还是采用 CAS 机制</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程工具类</title>
    <link href="/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Semaphore"><a href="#一-Semaphore" class="headerlink" title="一 : Semaphore"></a>一 : Semaphore</h2><p>又称<strong>信号量</strong>, 控制多个线程争抢许可</p><p>核心API : </p><ul><li>acquire : 获取一个许可, 如果没有就等待</li><li>release : 释放一个许可</li><li>availablePermits : 方法得到可用的数目</li></ul><p><strong>经典场景 :</strong> 代码并发处理限流</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 4个客人2个技师</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;来到红浪漫, 现有技师: &quot;</span> + semaphore.availablePermits());<br>                    <span class="hljs-keyword">if</span> (semaphore.availablePermits() == <span class="hljs-number">0</span>) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;没技师了...&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 开始等</span><br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;有技师, 准备按摩...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000L</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;按摩结束, 离开...&quot;</span>);<br>                    semaphore.release();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;, i + <span class="hljs-string">&quot;哥: &quot;</span>).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-CountDownLatch"><a href="#二-CountDownLatch" class="headerlink" title="二 : CountDownLatch"></a>二 : CountDownLatch</h2><p>java1.5 被引入的一个工具类, 常被成为<strong>倒计数器</strong>; 创建对象时, 传入指定数值作为线程参与的数量</p><p>API</p><ul><li>await : 方法等待计数器值变为 0, 在这之前, 线程进入等待状态</li><li>countdown : 计数器数值减一, 直到为 0</li></ul><p><strong>适用场景 :</strong> 经常用于等待其他线程执行到某一节点, 再继续执行当前线程代码</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 4个运动员赛跑,未比完人数为0时,公布成绩</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: 起跑...&quot;</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> + random.nextInt(<span class="hljs-number">3</span>);<br>                    Thread.sleep(s * <span class="hljs-number">1000L</span>);<br>                    countDownLatch.countDown();<br>                    record.put(Thread.currentThread().getName(), s);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: 跑完了...&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;, i + <span class="hljs-string">&quot;号运动员&quot;</span>).start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<br>            System.out.println(<span class="hljs-string">&quot;比赛结束, 公布成绩: &quot;</span> + record.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实场景</p><ol><li>统计线程执行情况</li><li>压力测试中, 使用 countDownLatch 实现最大程度的并发处理</li><li>多线程之间, 相互通信, 比如线程异步调用完接口, 结果通知</li></ol><h2 id="三-CyclicBarrier"><a href="#三-CyclicBarrier" class="headerlink" title="三 : CyclicBarrier"></a>三 : CyclicBarrier</h2><p>java1.5 加入, 又称为<strong>线程栅栏</strong>; 创建对象时, 指定展览线程数量</p><p>API</p><ul><li>await : 等指定数量的线程都处于等待状态时, 继续执行后续代码</li><li>barrierAction : 线程数量到了指定量之后, 自动出发执行指定任务</li></ul><p>和 CountDownLatch 重要区别在于, CyclicBarrier 对象可以多次出发执行</p><p><strong>经典场景 :</strong></p><ol><li>数据量比较大时, 实现批量插入数据到数据库</li><li>数据统计, 30 个线程统计 30 天数据, 全部统计完毕后, 执行汇总</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS抽象队列同步器</title>
    <link href="/2020/05/08/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <url>/2020/05/08/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-同步锁的本质-排队"><a href="#一-同步锁的本质-排队" class="headerlink" title="一 : 同步锁的本质 - 排队"></a>一 : 同步锁的本质 - 排队</h2><p>同步的方式 : 独享锁 - 单个队列窗口, 共享锁 - 多个队列窗口</p><p>抢锁的方式 : 公平锁(先来后到抢锁), 非公平锁(插队抢)</p><p>没抢到锁的处理方式 : 快速尝试多次(CAS自旋), 阻塞等待</p><p>唤醒阻塞线程的方式(叫号器) : 全部通知, 通知下一个</p><h2 id="二-AQS-抽象队列同步器"><a href="#二-AQS-抽象队列同步器" class="headerlink" title="二 : AQS 抽象队列同步器"></a>二 : AQS 抽象队列同步器</h2><p>提供了对资源占用, 释放; 线程的等待, 唤醒等等接口和具体实现</p><p>可以用在各种需要控制资源争用的场景中(ReentrantLock&#x2F;CountDownLatch&#x2F;Semahpore)</p><p><img src="/../java/image-2020050801.png" alt="image-2020050801"></p><p>其中定义的接口可以分为<strong>独占资源</strong>接口和<strong>共享资源</strong>接口两类; 其中独占资源接口包括 acquire, release, tryAcquire(未实现), tryRelease(未实现); 而共享资源接口则包括 acquireShared, releaseShared, tryAcquireShared(未实现), tryReleaseShared(未实现)</p><ul><li>acquire, acquireShared : 定义了资源争用的逻辑, 如果没拿到, 则等待</li><li><strong>tryAcquire, tryAcquireShared :</strong> 实际执行占用资源的操作, 如何判定一个由使用者具体去实现</li><li>release, releaseShared : 定义释放资源的逻辑, 释放之后, 通知后续节点进行争抢</li><li><strong>tryRelease, tryReleaseShared :</strong> 实际执行资源释放的操作, 具体的 AQS 使用者去实现</li></ul><p>AQS 内部主体 : state(状态), exclusiveOwner(占有者), Node(锁的等待者链表, 从head &#x3D;&gt; tail)</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AQSdemo</span> &#123;<br>    <span class="hljs-comment">// 同步资源状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 当前锁的拥有者</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <span class="hljs-comment">// java q 线程安全</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">addQ</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!tryAcquire()) &#123;<br>            <span class="hljs-keyword">if</span> (addQ) &#123;<br>                <span class="hljs-comment">// 塞到等待锁的集合中</span><br>                waiters.offer(Thread.currentThread());<br>                addQ = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 挂起这个线程</span><br>                LockSupport.park();<br>                <span class="hljs-comment">// 后续，等待其他线程释放锁，收到通知之后继续循环</span><br>            &#125;<br>        &#125;<br>        waiters.remove(Thread.currentThread());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// cas 修改 owner 拥有者</span><br>        <span class="hljs-keyword">if</span> (tryRelease()) &#123;<br>            Iterator&lt;Thread&gt; iterator = waiters.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">waiter</span> <span class="hljs-operator">=</span> iterator.next();<br>                LockSupport.unpark(waiter); <span class="hljs-comment">// 唤醒线程继续 抢锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断量够不够</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">addQ</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (tryAcquireShared() &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (addQ) &#123;<br>                <span class="hljs-comment">// 塞到等待锁的集合中</span><br>                waiters.offer(Thread.currentThread());<br>                addQ = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 挂起这个线程</span><br>                LockSupport.park();<br>                <span class="hljs-comment">// 后续，等待其他线程释放锁，收到通知之后继续循环</span><br>            &#125;<br>        &#125;<br>        waiters.remove(Thread.currentThread());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// cas 修改 owner 拥有者</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared()) &#123;<br>            Iterator&lt;Thread&gt; iterator = waiters.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">waiter</span> <span class="hljs-operator">=</span> iterator.next();<br>                LockSupport.unpark(waiter); <span class="hljs-comment">// 唤醒线程继续 抢锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AtomicInteger <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(AtomicInteger state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-资源占用流程-acquire"><a href="#三-资源占用流程-acquire" class="headerlink" title="三 : 资源占用流程(acquire)"></a>三 : 资源占用流程(acquire)</h2><p><img src="/../java/image-2020050802.jpg" alt="image-2020050802"></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock接口和ReentrantLock/ReadWriteLock</title>
    <link href="/2020/04/24/Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/04/24/Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Lock-的核心API"><a href="#一-Lock-的核心API" class="headerlink" title="一 : Lock 的核心API"></a>一 : Lock 的核心API</h2><p>synchronized 关键字使用固然简单, 但是我们<strong>无法控制同步代码停止</strong>, 除非抛异常; </p><p>Lock 提供了很丰富的 API : </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>lock</td><td>获取锁的方法, 若锁被其他线程获取, 则等待(阻塞)</td></tr><tr><td>lockInterruptibly</td><td>在锁的获取过程中可以中断当前线程</td></tr><tr><td>tryLock</td><td>尝试非阻塞的获取锁, 立即返回</td></tr><tr><td>unlock</td><td>释放锁</td></tr></tbody></table><h2 id="二-ReentrantLock"><a href="#二-ReentrantLock" class="headerlink" title="二 : ReentrantLock"></a>二 : ReentrantLock</h2><p><strong>独享锁; 可重入锁</strong>; 支持公平锁, 非公平锁两种模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果需要正确中断等待锁的线程,必须将获取锁放在try&#123;&#125;外面;</span><br><span class="hljs-comment">         * 否则会抛出 IllegalMonitorStateException,</span><br><span class="hljs-comment">         * 由于finally却无论如何都要执行,而等待线程根本就没有拿到锁,也就是锁没有锁定监视器</span><br><span class="hljs-comment">         */</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...method body</span><br>            b(); <span class="hljs-comment">// 此方法带锁, 同一线程可以重复进入</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 这里必须用finally将锁释放掉,否则一旦出现异常容易出现死锁</span><br>            lock.unlock(); <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-comment">//...</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行过程 :</strong></p><ul><li>初始化 : 未锁, ReentrantLock, 持有者(null), 计数(0)</li><li>调用 a() : 第一次锁, ReentrantLock, 持有者(线程-0), 计数(1) </li><li>a() 中又调用 b() : 第二次锁, ReentrantLock, 持有者(线程-0), 计数(2)</li><li>b() 执行完毕 : 解锁, ReentrantLock, 持有者(线程-0), 计数(1)</li><li>a() 执行完毕 : 解锁, ReentrantLock, 持有者(null), 计数(0)</li></ul><h2 id="三-ReadWriteLock"><a href="#三-ReadWriteLock" class="headerlink" title="三 : ReadWriteLock"></a>三 : ReadWriteLock</h2><p>维护一对关联锁, 一个用于只读操作, 一个用于写入; 读锁可以由多个读线程同时持有, 写锁是排他的; </p><ul><li><strong>适用场景 :</strong> 适合读取线程比写入线程多的场景(读多写少), 改进互斥锁的性能</li><li><strong>示例场景 :</strong> 缓存组件, 集合的并发线程安全性改造</li></ul><p>代码示例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-comment">// 多线程同时读/写</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.read(Thread.currentThread());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.read(Thread.currentThread());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.write(Thread.currentThread());<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">// 多线程读,共享锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        readWriteLock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;正在进行“读”操作&quot;</span>);<br>            &#125;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;“读”操作完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 写,独占锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        readWriteLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;正在进行“写”操作&quot;</span>);<br>            &#125;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;“写”操作完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>锁降级</strong>指的是写锁降级成为读锁; 把持住当前拥有的写锁的同时, 再获取到读锁, 然后释放写锁的过程</p><p>写锁是线程独占, 读锁是共享, 所以, <strong>写 &#x3D;&gt; 读是升级</strong>(读 &#x3D;&gt; 写, 是不能实现的)</p><h2 id="四-Condition"><a href="#四-Condition" class="headerlink" title="四 : Condition"></a>四 : Condition</h2><p>Object 中的 wait(), notify(), notifyAll() 方法是和 synchronized 配合使用的, 可以唤醒一个或者全部(单个等待集);</p><p>Condition 是需要与 Lock 配合使用的, 提供多个等待集合, 更精确的控制; <strong>底层是 park&#x2F;unpark 机制</strong>; 用于替代 wait&#x2F;notify; </p><p>经典场景 : JDK 中的队列实现</p><ul><li>多线程读写队列 : 写入数据时, 唤醒读取线程继续执行; 读取数据后, 通知写入队列继续执行</li></ul><p>代码示例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * condition 实现队列线程安全</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueDemo</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 指定条件的等待 - 等待有空位</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 指定条件的等待 - 等待不为空</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 定义数组存储数据</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> putptr, takeptr, count;<br><br>    <span class="hljs-comment">// 写入数据的线程,写入进来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) <span class="hljs-comment">// 数据写满了</span><br>                notFull.await(); <span class="hljs-comment">// 写入数据的线程,进入阻塞</span><br>            items[putptr] = x;<br>            <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>            ++count;<br>            notEmpty.signal(); <span class="hljs-comment">// 唤醒指定的读取线程</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 读取数据的线程,调用take</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                notEmpty.await(); <span class="hljs-comment">// 线程阻塞在这里,等待被唤醒</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>            <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>            --count;<br>            notFull.signal(); <span class="hljs-comment">// 通知写入数据的线程,告诉他们取走了数据,继续写入</span><br>            <span class="hljs-keyword">return</span> x;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA锁相关术语及同步关键字synchronized</title>
    <link href="/2020/04/17/synchronized%E5%92%8C%E9%94%81/"/>
    <url>/2020/04/17/synchronized%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-java-中锁的概念"><a href="#一-java-中锁的概念" class="headerlink" title="一 : java 中锁的概念"></a>一 : java 中锁的概念</h2><p><strong>自旋锁 :</strong> 为了不放弃 CPU 执行事件, 循环的使用 CAS 技术对数据尝试进行更新, 直至成功</p><p><strong>悲观锁 :</strong> 假定会发生并发冲突, 同步所有对数据的相关操作, 从读数据就开始上锁</p><p><strong>乐观锁 :</strong> 假定没有冲突, 在修改数据时如果发现数据和之前获取的不一致, 则读最新的数据, 修改后重试修改</p><p><strong>独享锁(写) :</strong> 给资源加上写锁, 线程可以修改资源, 其他线程不能再加锁;(单写)</p><p><strong>共享锁(读) :</strong> 给资源加上读锁后只能读不能改, 其他线程也只能加读锁, 不能加写锁;(多读)</p><p><strong>可重入锁, 不可重入锁 :</strong> 线程拿到一把锁之后, 可以自由进入同一把锁所同步的其他代码</p><p><strong>公平锁, 非公平锁 :</strong> 争抢锁的顺序, 如果是按先来后到, 则为公平</p><p>几种重要的锁实现方式 : <code>synchronized</code>, <code>ReentrantLock</code>, <code>ReentrantReadWriteLock</code></p><h2 id="二-同步关键字-synchronized"><a href="#二-同步关键字-synchronized" class="headerlink" title="二 : 同步关键字 synchronized"></a>二 : 同步关键字 synchronized</h2><p>属于最基本的线程通信机制, 基于<strong>对像监视器</strong>实现的; java中的每一个对象都与一个监视器相关联, 一个线程可以锁定或者解锁监视器; <strong>一次只有一个线程可以锁定监视器;</strong> 试图锁定该监视器的任何其他线程都会被阻塞, 直到它们可以获得该监视器上的锁定为止</p><p><strong>特性 :</strong> 可重入, 独享, 悲观锁</p><p><strong>锁的范围 :</strong> 类锁, 对象锁, 锁消除, 锁粗化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-comment">/*static*/</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 我开始执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3000L</span>);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 我执行结束&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncDemo</span>().test()).start();<br>        Thread.sleep(<span class="hljs-number">1000L</span>); <span class="hljs-comment">// 等1秒钟,让前一个线程启动起来</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncDemo</span>().test()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果 :</strong> 线程不会同步</p><p><strong>原理分析 :</strong> <code>synchronized</code> 的加锁原理是锁定<strong>对象监视器</strong>, 每个对象都对应各自的监视器</p><p><strong>解决方案 :</strong> </p><ol><li>加静态关键字 <code>static</code>, 提升为类锁</li><li>为临界区添加同步代码块, 指定共用的锁, 但需要是类锁</li></ol><p><strong>提示 :</strong> 同步关键字, 不仅是实现同步, 根据 JMM 规定还能保证可见性(读取最新主内存数据, 结束后写入主内存)</p><h2 id="三-同步关键字加锁原理"><a href="#三-同步关键字加锁原理" class="headerlink" title="三 : 同步关键字加锁原理"></a>三 : 同步关键字加锁原理</h2><p>HotSpot 中, 对象在内存中存储的布局可以分为三块区域 : <strong>对象头</strong>(Header), <strong>实例数据</strong>(Instance Data)和<strong>对齐填充</strong>(Padding)</p><p>普通对象的<strong>对象头</strong>(Header)包括两部分 : <strong>Mark Word</strong> 和 <strong>Class Metadata Address</strong> (类型指针), 如果是数组对象还包括一个额外的 <strong>Array length</strong> 数组长度部分</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64bit</td><td><strong>Mark Word</strong></td><td>存储对象hashCode或锁信息等运行时数据。</td></tr><tr><td>32&#x2F;64bit</td><td><strong>Class Metadata Address</strong></td><td>存储到对象类型数据的指针</td></tr><tr><td>32&#x2F;64bit</td><td><strong>Array length</strong></td><td>数组的长度(如果当前对象是数组)</td></tr></tbody></table><p>其中 <strong>mark word</strong> 用于存储对象自身的运行时数据, 如: 哈希码(HashCode), GC分代年龄(age), 是否偏向锁(0&#x2F;1), 锁标志位(tag), 线程持有的锁状态(state), 偏向线程ID(Thread ID), 偏向时间戳等等(epoch); 占用内存大小与虚拟机位长一致(32&#x2F;64bit)</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">Bitfield</span>|<span class="hljs-string">Tag</span>|<span class="hljs-string">State</span>|<br>|<span class="hljs-string">HashCode</span>|<span class="hljs-string">age</span>|<span class="hljs-string">0</span>|<span class="hljs-string">01</span>|<span class="hljs-string">Unlocked</span>|<br>|<span class="hljs-string">Lock record address</span>|<span class="hljs-string">00</span>|<span class="hljs-string">Light-weight locked</span>|<br>|<span class="hljs-string">Monitor address</span>|<span class="hljs-string">10</span>|<span class="hljs-string">heavy-weight locked</span>|<br>|<span class="hljs-string">Forwarding address, etc</span>|<span class="hljs-string">11</span>|<span class="hljs-string">marked for GC</span>|<br>|<span class="hljs-string">Thread ID</span>|<span class="hljs-string">epoch</span>|<span class="hljs-string">age</span>|<span class="hljs-string">1</span>|<span class="hljs-string">01</span>|<span class="hljs-string">biased/biasable</span>|<br></code></pre></td></tr></table></figure><p><strong>默认情况下 jvm 锁会经历 :</strong> 偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁</p><p>参考文献 : </p><ul><li><a href="https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf">https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf</a> </li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></li></ul><h3 id="一-轻量级锁"><a href="#一-轻量级锁" class="headerlink" title="(一) 轻量级锁"></a>(一) 轻量级锁</h3><p>对象初始化的时候是无锁的, mark word 记录的是 hashCode, age 和偏移状态</p><p><strong>加锁原理 :</strong> 线程栈开辟一个空间, 存储当前锁定对象的 mark word 信息; 这个空间就是 lock record, 它可以存储多个锁定的对象信息, 如果对象被锁定了, mark word 的内容会变为 lock record address</p><p>加锁前</p><p><img src="D:\blog\source\java\image-2020041701.png"> </p><p>加锁后</p><p><img src="/../java/image-2020041702.png"> </p><p>使用 CAS 修改 mark word 完毕, 则 mark word 中的 tag 进入 00 状态</p><p>解锁的过程, 则是一个逆向恢复 mark word 的过程</p><h3 id="二-偏向锁到轻量级锁"><a href="#二-偏向锁到轻量级锁" class="headerlink" title="(二) 偏向锁到轻量级锁"></a>(二) 偏向锁到轻量级锁</h3><p>偏向锁默认是开启的, <strong>偏向锁其实也是无锁</strong>, tag 值和无锁对象一样, 都是 01, 若出现锁竞争会升迁到轻量级锁</p><p><img src="/../java/image-2020041703.png"></p><p>未锁定或不可偏向对象经过自旋重锁之后, 会升迁为轻量级锁, mark word 的内容会修改为线程栈的 lock record address, 同时 tag 会修改为 00, 如果锁再次升级, 就会编程重量级锁, mark word 内容会修改为 monitor address , 同时 tag 会修改为 10</p><p>开启偏向锁的对象 mark word 内容为 thread ID|age|1 , tag 值仍然是 01, 这里需要注意的是 Thread ID 初始值为 0, 当第一个线程进行操作的时候, 会将 Thread ID 修改为自己的线程 ID, 一旦出现争抢会出现两种情况: 一种情况是如果对象没锁定, 则会变成未锁定且不偏向的对象, 也就是无锁对象; 如果对象已经锁定, 则会直接变成被轻量级锁定的对象</p><p><strong>总结 :</strong></p><ul><li><p>偏向标记第一次有用, 出现过争用后就没有用了; </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX: -UseBiasedLocking # 禁用使用偏置锁定<br></code></pre></td></tr></table></figure></li><li><p>偏向锁, 本质就是无锁, 如果没有发生过任何多线程争抢锁的情况, jvm 认为就是单线程, 无需做同步(jvm 为了少干活: 同步在 jvm 底层是有很多操作来实现的, 如果是没有争用, 就不需要去做同步)</p></li></ul><h3 id="三-重量级锁-监视器-monitor"><a href="#三-重量级锁-监视器-monitor" class="headerlink" title="(三) 重量级锁 - 监视器(monitor)"></a>(三) 重量级锁 - 监视器(monitor)</h3><p>修改 mark word 如果失败, 会自旋 CAS 一定次数, 该次数可以通过参数配置</p><p>超过次数, 仍未抢到锁, 则锁升级为重量级锁, 进入阻塞</p><p><img src="/../java/image-2020041704.png"></p><p>monitor 也叫做管程, 计算机操作系统原理中有提及类似概念, 一个对象会有一个对应的 monitor</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS机制和Atomic相关类</title>
    <link href="/2020/04/10/CAS%E6%9C%BA%E5%88%B6%E5%92%8CAtomic%E7%9B%B8%E5%85%B3%E7%B1%BB/"/>
    <url>/2020/04/10/CAS%E6%9C%BA%E5%88%B6%E5%92%8CAtomic%E7%9B%B8%E5%85%B3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h2 id="一-CAS-机制"><a href="#一-CAS-机制" class="headerlink" title="一 : CAS 机制"></a>一 : CAS 机制</h2><p>Compare and swap 比较和交换; 属于硬件同步原语, 处理器提供了基本内存操作的原子性保证</p><p>CAS 操作需要输入两个数值, 一个旧值 A (期望操作前的值)和一个新值 B, 在操作期间先比较下旧值有没有发生变化, 如果没有发生变化, 才交换成新值, 发生了变化则不交换</p><p><img src="/../java/image-2020041001.png" alt="image-2020041001"> </p><p>JAVA 中的 sun.misc.Unsafe 类, 提供了 <code>compareAndSwapInt()</code> 和 <code>compareAndSwapLong()</code> 等几个方法实现 CAS</p><h2 id="二-JUC包内的原子操作封装类"><a href="#二-JUC包内的原子操作封装类" class="headerlink" title="二 : JUC包内的原子操作封装类"></a>二 : JUC包内的原子操作封装类</h2><p>数值</p><ul><li>AtomicBoolean : 原子更新布尔类型</li><li>AtomicInteger : 原子更新整型</li><li>AtomicLong : 原子更新长整型</li></ul><p>数组</p><ul><li>AtomicIntegerArray : 原子更新整型数组数组里的元素</li><li>AtomicLongArray : 原子更新长整型数组里的元素</li><li>AtomicReferenceArray : 原子更新引用类型数组里的元素</li></ul><p>字段</p><ul><li>AtomicIntegerFieldUpdate : 原子更新整形的字段的更新器</li><li>AtomicLongFieldUpdate : 原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdate : 原子更新引用类型里的字段</li></ul><p>引用类型</p><ul><li>AtomicReference : 原子更新引用类型</li><li>AtomicStampedReference : 原子更新带有版本号的引用类型</li><li>AtomicMarkableReference : 原子更新带有标记为的引用类型</li></ul><p>jdk1.8 更新</p><ul><li>更新器 : DoubleAccumulator, LongAccumulator</li><li>计数器 : DoubleAdder, LongAdder</li><li>计数器增强版, 高并发下性能更好</li><li>频繁更新但不太频繁读取的汇总统计信息时使用</li><li>分成多个操作单元, 不同线程更新不同的单元</li><li>只有需要汇总的时候才计算所有单元的操作</li></ul><h2 id="三-CAS-的三个问题"><a href="#三-CAS-的三个问题" class="headerlink" title="三 : CAS 的三个问题"></a>三 : CAS 的三个问题</h2><ol><li>循环 + CAS, 自旋的实现让所有线程都处于高频运行, 争抢 CPU 执行事件的状态; 如果操作长时间不成功, 会带来很大的 CPU 资源消耗</li><li>仅针对单个变量的操作, 不能用于多个变量来实现原子操作</li><li>ABA 问题 : 简单来说就是 value&#x3D;A, 线程1将A改成B, 线程2又将B改成A, 这是线程3将A改成C, 这时线程3是不知道 value 的值曾经有过变动的</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之原子操作</title>
    <link href="/2020/04/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/04/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>原子操作操作可以是一个步骤, 也可以是多个操作步骤, 但是其顺序不可以被打乱, 也不可以被切割而只执行其中的一部分(不可中断性); </p><p><strong>将整个操作视作一个整体是原子性的核心特征</strong></p><h2 id="二-解决方案"><a href="#二-解决方案" class="headerlink" title="二 : 解决方案"></a>二 : 解决方案</h2><ol><li>加锁</li><li>循环 CAS</li></ol><h2 id="三-示例"><a href="#三-示例" class="headerlink" title="三 : 示例"></a>三 : 示例</h2><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>        i++; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是三个步骤 : </p><ol><li>加载 i</li><li>计算 i+1 </li><li>赋值 i</li></ol><p>存在<strong>竟态条件</strong>, 线程不安全, 需要转变为原子操作才能安全; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>    i++; <br>&#125;<br></code></pre></td></tr></table></figure><p>上例只是针对一个变量的原子操作改进, 我们也可以实现更大逻辑的原子操作</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之共享资源/不可变性/竟态条件/临界区</title>
    <link href="/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <url>/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-竟态条件与临界区"><a href="#一-竟态条件与临界区" class="headerlink" title="一 : 竟态条件与临界区"></a>一 : 竟态条件与临界区</h2><p>多个线程访问了相同的资源, 向这些资源做了写操作时, 对执行顺序有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>临界区 :</strong> <code>incr()</code> 内部就是临界区域, 关键部分代码的多线程并发执行, 会对执行结果产生影响</p><p><strong>竟态条件 :</strong> 可能发生在临界区域内的特殊条件; 多线程执行 <code>incr()</code> 中的 <code>i++</code> 关键代码时, 产生了竟态条件</p><h2 id="二-共享资源"><a href="#二-共享资源" class="headerlink" title="二 : 共享资源"></a>二 : 共享资源</h2><p>如果一段代码是线程安全的, 则它不包含竟态条件; 只有当多个线程更新共享资源时, 才会发生竟态条件</p><p>栈封闭时, 不会在线程之间共享的变量, 都是线程安全的</p><p>局部对象引用本身不共享, 但是引用的对象存储在共享堆中; 如果方法内创建的对象, 只是在方法中传递, 并且不对其他线程可用, 那么也是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">LocalObject</span> <span class="hljs-variable">localObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalObject</span>();<br>    localObject.callMethod();<br>    method2(localObject);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(LocalObject localObject)</span>&#123;<br>    localObject.setValue(<span class="hljs-string">&quot;value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则判定 :</strong> 如果创建, 使用和处理资源, 永远不会逃脱单个线程的控制, 该资源的使用时线程安全的</p><h2 id="三-不可变对象"><a href="#三-不可变对象" class="headerlink" title="三 : 不可变对象"></a>三 : 不可变对象</h2><p>创建不可变的共享对象来保证对象在线程间共享时不会被修改, 从而实现线程安全; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例被创建, value 变量就不能在被修改, 这就是不可变性</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用volatile解决可见性问题及阻止指令重排序</title>
    <link href="/2020/03/20/volatile/"/>
    <url>/2020/03/20/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="一-线程操作的定义"><a href="#一-线程操作的定义" class="headerlink" title="一 : 线程操作的定义"></a>一 : 线程操作的定义</h2><p>操作定义</p><ul><li>write : 要写的变量以及要写的值</li><li>read : 要读的变量以及可见的写入值(由此, 我们可以确定可见的值)</li><li>lock : 要锁定的管程(监视器 monitor)</li><li>unlock : 要解锁的管程</li><li>外部操作(socket等等…)</li><li>启动和终止</li></ul><p>程序顺序 : 如果一个程序没有数据竞争, 那么程序的所有执行看起来都是顺序一致的</p><h2 id="二-对于同步的规则定义"><a href="#二-对于同步的规则定义" class="headerlink" title="二 : 对于同步的规则定义"></a>二 : 对于同步的规则定义</h2><ol><li>对于监视器 m 解锁与所有后续操作对于 m 的加锁同步</li><li>对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步</li><li>启动线程的操作与线程中的第一个操作同步</li><li>对于每个属性写入默认值(0, false, null)与每个线程对其进行的操作同步</li><li>线程 T1 的最后操作与线程 T2 发现线程 T1 已经结束同步(isAlive, join可以判断线程是否终结)</li><li>如果线程 T1 中断了 T2, 那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步; 通过抛出 InterruptedException 异常, 或者调用 Thread.interrupted 或 Thread.isInterrupted</li></ol><h2 id="三-happens-before-先行发生原则"><a href="#三-happens-before-先行发生原则" class="headerlink" title="三 : happens-before 先行发生原则"></a>三 : happens-before 先行发生原则</h2><p><strong>happens-before 关系</strong>主要用于强调两个有冲突的动作之间的顺序, 以及定义数据争用的发生时机</p><p><strong>具体的虚拟机实现</strong>, 有必要确保以下原则的成立 : </p><ul><li>某个线程中的每个动作都 happens-before 该线程中该动作后面的动作</li><li>某个管程上的 unlock 动作 happens-before 同一个管程上后续的 lock 动作</li><li>对某个 volatile 字段的写操作 happens-before 每个后续对该 volatile 字段的读操作</li><li>在某个线程对象上调用 start() 方法 happens-before 该启动了线程中的任意动作</li><li>某个线程中的所有动作 happens-before 任意其他线程成功从该线程对象上的 join() 中返回</li><li>如果某个动作 a happens-before 动作 b, 且 b happens-before 动作 c, 则有 a happens-before c</li></ul><p>当程序包含两个没有被 happens-before 关系排序的冲突访问时, 就称存在<strong>数据争用</strong>; <strong>遵守了这个原则, 也就意味着有些代码不能进行重排序, 有些数据不能缓存</strong></p><h2 id="四-使用-volatile-解决可见性问题及阻止指令重排序"><a href="#四-使用-volatile-解决可见性问题及阻止指令重排序" class="headerlink" title="四 : 使用 volatile 解决可见性问题及阻止指令重排序"></a>四 : 使用 volatile 解决可见性问题及阻止指令重排序</h2><p><strong>可见性问题 :</strong> 让一个线程对共享变量的修改, 能够及时的被其他先成功看到</p><p>根据 jmm(Java Memory Model) 中规定的 happens-before 和同步原则</p><ul><li>对某个 volatile 字段的写操作 happens-before 每个后续对该 volitile 字段的读操作</li><li>对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步</li></ul><p>要满足这些条件, 所以 volatile 关键字就有这些功能</p><ol><li>禁止缓存 : volatile 变量的访问控制符会加 <code>ACC_VOLATILE</code></li><li>对 volatile 变量相关的指令不做重排序</li></ol><h2 id="五-final-在-JMM-中的处理"><a href="#五-final-在-JMM-中的处理" class="headerlink" title="五 : final 在 JMM 中的处理"></a>五 : final 在 JMM 中的处理</h2><p>final 在对象的构造函数中设置对象的字段, 当线程看到该对象时, 将始终看到该对象的 final 字段的正确构造版本; 伪代码实例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">static</span> FinalDemo f;<br>&#125;<br><br>f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">finalDemo</span>(); <span class="hljs-comment">//读取到的 f.x 一定最新, x 为 final 字段</span><br></code></pre></td></tr></table></figure><p>如果在构造函数中设置字段后发生读取, 则会看到该 final 字段分配的值, 否则它将看到默认值; 伪代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">finalDemo</span><span class="hljs-params">()</span>&#123;<br>    x = <span class="hljs-number">1</span>;<br>    y = x; <span class="hljs-comment">// y等于1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取该共享对象的 final 成员变量之前, 先要读取共享对象; 伪代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceObj</span>(); <br>k = r.f; <br><span class="hljs-comment">// 这两个操作不能重排序</span><br></code></pre></td></tr></table></figure><p>通常 static final 是不可以修改的字段; 然而 System.in, System.out 和 System.err 是 static final 字段, 遗留原因, 必须允许通过 set 方法改变, 我们将这些字段称为写保护, 以区别与普通 final 字段</p><h2 id="六-word-tearing-字节处理"><a href="#六-word-tearing-字节处理" class="headerlink" title="六 : word tearing 字节处理"></a>六 : word tearing 字节处理</h2><p>一个字段或元素的更新不得与任务其他字段或元素的读取或者更新交互; 特别是, 分别更新字节数组的相邻元素的两个线程不得干涉或交互, 也不需要同步以确保顺序一致性</p><p>有些处理器(尤其是早期的 Alphas 处理器)没有提供写单个字节的功能; 在这样的处理器上更新 byte 数组, 若只是简单的读取整个额呢绒, 更新对应的字节, 然后将整个内容再写回内存, 将是不合法的</p><p>这个问题有时候被称为**”字分裂(word tearing)”**, 在单独更新单个字节有难度的处理器上, 就需要寻求其他方式了</p><p>基本不需要考虑这个, 了解就好</p><h2 id="七-double-和-long-的特殊处理"><a href="#七-double-和-long-的特殊处理" class="headerlink" title="七 : double 和 long 的特殊处理"></a>七 : double 和 long 的特殊处理</h2><p>虚拟机规范中, 写64位的 double 和 long 分成了两次32位值的操作; 由于不是原子操作, 可能导致读取到某次写操作中 64 位的前 32 位, 以及另外一次写操作的后 32 位</p><p><strong>读写 volatile 的 long 和 double 总是原子的; 读写引用也总是原子的</strong></p><p>商业 jvm 不会存在这个问题, 虽然规范没有要求实现原子性, 但是考虑到实际应用, 大部分实现了原子性</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之可见性问题</title>
    <link href="/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-指令重排序-jit"><a href="#一-指令重排序-jit" class="headerlink" title="一 : 指令重排序(jit)"></a>一 : 指令重排序(jit)</h2><p>Java 编程语言的语义允许编译器和微处理器执行优化，这些优化可以与不正确的同步代码交互，从而产生看似矛盾的行为。</p><ul><li><p>重排序</p><p><img src="D:\blog\source\java\image-2020031301.png"> </p></li><li><p>等效交换</p><p><img src="D:\blog\source\java\image-2020031302.png"></p></li></ul><p>通常 javac 将程序源码编译, 转换成 java 字节码(.class), jvm 通过解释字节码将其翻译成相应的机器指令, 逐条读入, 逐条解释翻译; 经过解释运行, 其运行速度必定会比可运行的二进制字节码程序慢; 为了提高运行速度, 引入了 <strong>jit</strong> 技术</p><p>当 <strong>jit</strong> 编译启用时(默认是启用的), jvm 读入 <strong>.class 文件</strong>解释后, 将其发给 jit 编译器; jit 编译器将字节码编译成本机机器代码(汇编指令), 在执行时 jit 会把翻译过的机器码保存起来, 已备下次使用; 因此从理论上来说, 采用该 jit 技术能够接近曾经纯编译技术</p><p>而 java 的指令重排序优化是在 jit 编译阶段, 因此 class 文件是看不出来的, 所以 javap 命令无法帮到你; 如果想要继续向下探索, 可以查看 jit 编译后的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过设置 jvm 的参数, 可以打印出 jit 编译的内容(非class文件)</span><br>server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭jit优化</span><br>-Djava.compiler=NONE<br></code></pre></td></tr></table></figure><p>这些优化可以与不正确的同步代码交互, 从而产生看似矛盾的行为; 这些优化是以单线程为角度的, 当发生多线程运行的时候可能会出现不确定的错误</p><h2 id="二-Shared-Variables"><a href="#二-Shared-Variables" class="headerlink" title="二 : Shared Variables"></a>二 : Shared Variables</h2><p>Shared Variables : 共享变量</p><p>可以在线程之间共享的内存称为<strong>共享内存</strong>或<strong>堆内存</strong>; 所有实例字段, 静态字段和数组元素都存储在堆内存中</p><p>如果至少有一个访问是写的, 那么对同一个变量的两次访问(读或写)是冲突的</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存模型</title>
    <link href="/2020/03/06/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/03/06/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-多线程中的问题"><a href="#一-多线程中的问题" class="headerlink" title="一 : 多线程中的问题"></a>一 : 多线程中的问题</h2><ol><li>所见非所得</li><li>无法肉眼去检测程序的准确性</li><li>不同的运行平台有不同的表现</li><li>错误很难重现</li></ol><h2 id="二-从内存结构到内存模型"><a href="#二-从内存结构到内存模型" class="headerlink" title="二 : 从内存结构到内存模型"></a>二 : 从内存结构到内存模型</h2><p>每个线程都有自己的工作内存; 如果想要数据共享, 需要存放在主内存中</p><p><img src="/../java/image-2020030601.png" alt="image-2020030601"> </p><p>因为这种内存结构, 在多线程下数据交互会有各种情况出现</p><h2 id="三-工作内存缓存"><a href="#三-工作内存缓存" class="headerlink" title="三 : 工作内存缓存"></a>三 : 工作内存缓存</h2><p>cpu 运行时, 与 cpu 交互的主要是 cpu 缓存, 此时可能会出现不同 cpu 缓存中的数据不一致的情况</p><p><img src="/../java/image-2020030602.png" alt="image-2020030601"> </p><h2 id="四-内存模型的含义"><a href="#四-内存模型的含义" class="headerlink" title="四 : 内存模型的含义"></a>四 : 内存模型的含义</h2><p>内存模型描述程序的可能行为</p><p><strong>java 编程语言内存模型</strong>通过检查执行跟踪中的每个操作, 并根据某些规则检查该读操作观察到的写操作是否有效来工作</p><p>只要程序的所有执行产生结果都可以由内存模型预测; 具体的实现者任意实现, 包括操作的重新排序和删除不必要的同步</p><p>内存模型决定了在程序的每个点上可以读取什么值</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池应用及实现原理剖析</title>
    <link href="/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-为什么要用线程池"><a href="#一-为什么要用线程池" class="headerlink" title="一 : 为什么要用线程池"></a>一 : 为什么要用线程池</h2><p>线程是不是越多越好?</p><ol><li>线程在 java 中是一个对象, 更是操作系统的资源, 线程创建和销毁需要时间; 如果创建时间 + 销毁时间 &gt; 执行任务时间就很不合算</li><li>java 对象占用堆内存, 操作系统线程占用系统内存, 根据 jvm 规范, 一个线程默认最大栈大小 1M , 这个栈空间是需要从系统内存中分配的; 线程过多, 会消耗很多的内存</li><li>操作系统需要频繁切换线程上下文, 影响性能</li></ol><p><strong>线程池的推出, 就是为了方便的控制线程数量</strong></p><h2 id="二-线程池-API"><a href="#二-线程池-API" class="headerlink" title="二 : 线程池 API"></a>二 : 线程池 API</h2><p>三个接口两个实现类</p><table><thead><tr><th>类型</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>接口</td><td>Executor</td><td>最上层的接口, 定义了<strong>执行任务的方法 execute</strong></td></tr><tr><td>接口</td><td>ExecutorService</td><td>继承了 Executor 接口, 拓展了 Callable, Future, 关闭方法</td></tr><tr><td>接口</td><td>ScheduledExecutorService</td><td>继承了 ExecutorService, 增加了定时任务相关的方法</td></tr><tr><td>实现类</td><td>ThreadPoolExecutor</td><td><strong>基础, 标准的线程池实现</strong></td></tr><tr><td>实现类</td><td>ScheduledThreadPoolExecutor</td><td>继承了 ThreadPoolExecutor, 实现了 ScheduledExecutorService 中相关<strong>定时任务</strong>的方法, 可以认为时最丰富的实现类</td></tr></tbody></table><h3 id="一-ExecutorService"><a href="#一-ExecutorService" class="headerlink" title="(一) ExecutorService"></a>(一) ExecutorService</h3><p>方法定义和解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。</span><br>awaitTermination(<span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。</span><br>invokeAll(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks);<br><span class="hljs-comment">// 执行给定的任务，当所有任务完成或超时期满时(无论哪个首先发生)，返回保持任务状态和结果的 Future 列表。</span><br>invokeAll(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 执行给定的任务，如果某个任务已成功完成(也就是未抛出异常)，则返回其结果。</span><br>invokeAny(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks);<br><span class="hljs-comment">// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成(也就是未抛出异常)，则返回其结果。</span><br>invokeAny(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 如果此执行程序已关闭，则返回 true。</span><br>isShutdown();<br><span class="hljs-comment">// 如果关闭后所有任务都已完成，则返回 true。</span><br>isTerminated();<br><span class="hljs-comment">// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。</span><br>shutdown();<br><span class="hljs-comment">// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</span><br>shutdownNow();<br><span class="hljs-comment">// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。</span><br>submit(Callable&lt;T&gt; task);<br><span class="hljs-comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span><br>submit(Runnable task);<br><span class="hljs-comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span><br>submit(Runnable task, T result)<br></code></pre></td></tr></table></figure><h3 id="二-ScheduledExecutorService"><a href="#二-ScheduledExecutorService" class="headerlink" title="(二) ScheduledExecutorService"></a>(二) ScheduledExecutorService</h3><p>方法定义和解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。</span><br>schedule(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行在给定延迟后启用的一次性操作。</span><br>schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span><br>scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 </span><br>scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay, TimeUnit unit);<br></code></pre></td></tr></table></figure><p>schedule 方法</p><ul><li>创建并执行一个一次性任务; </li><li>过了延迟时间就会被执行</li></ul><p>scheduleAtFixedRate 方法</p><ul><li>创建并执行一个周期任务; </li><li>过了给定的初始延迟时间, 会第一次被执行; </li><li>执行过程中发生了异常, 那么任务就停止; </li><li><strong>一次任务执行时长超过了周期时间, 下一次任务会等到该次任务执行结束后, 立刻执行, 这也是它和 scheduleWithFixedDelay 的重要区别</strong></li></ul><p>scheduleWithFixedDelay 方法</p><ul><li>创建并执行一个周期性任务; </li><li>过了初始延迟时间, 第一次被执行, 后续以给定的周期时间执行; </li><li>执行过程中发生了异常, 那么任务就停止; </li><li><strong>一次任务执行时长超过了周期时间, 下一次任务会在该次任务执行结束的时间基础上, 计算执行延时;</strong></li><li><strong>对于超过周期的长时间处理任务的不同处理方式, 这是它和scheduledFixedRate的重要区别</strong></li></ul><h3 id="三-Executors-工具类"><a href="#三-Executors-工具类" class="headerlink" title="(三) Executors 工具类"></a>(三) Executors 工具类</h3><p>你可以自己实例化线程池, 也可以用 Executors 创建线程池的工厂类, 常用方法如下: </p><ul><li><strong>newFixedThreadPool(int nThreads):</strong> 创建一个固定大小, 任务队列容量无界的线程池; 推荐: <strong>核心线程数 &#x3D; 最大线程数</strong></li><li><strong>newCachedThreadPool():</strong> 创建的是一个大小无界的缓冲线程池; 它的任务队列是一个同步队列; 任务加入到池中, 如果池中有空闲线程, 则用空闲线程执行, 如无则创建新线程执行; 池中的线程空闲超过60秒, 将被销毁释放; 线程数随任务的多少变化, 适用于执行耗时较小的异步任务; 池的核心线程数为0, 最大线程数&#x3D;Integer.MAX_VALUE</li><li><strong>newSingleThreadExecutor():</strong> 只有一个线程来执行无界任务队列的单一线程池; 该线程池确保任务被加入的顺序一个一个一次执行; 当唯一的线程因任务异常中止时, 将创建一个新的线程来继续执行后续的任务; 与 newFixedThreadPool(1)的区别在于, 单一线程池的池大小在 newSingleThreadExecutor() 中硬编码, 不能在改变的</li><li><strong>newScheduledThreadPool(int corePoolSize):</strong> 能定时执行任务的线程池; 该池的核心线程数由参数指定, 最大线程数 &#x3D; Integer.MAX_VALUE</li></ul><h2 id="三-线程池原理"><a href="#三-线程池原理" class="headerlink" title="三 : 线程池原理"></a>三 : 线程池原理</h2><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="(一) 概念"></a>(一) 概念</h3><p><strong>线程池管理器 :</strong> 用于创建并管理线程池; 包括创建线程池, 销毁线程池, 添加新任务</p><p><strong>工作线程 :</strong> 线程池中线程, 在没有任务时处于等待状态, 可以循环的执行任务</p><p><strong>任务接口 :</strong> 每个任务必须实现的接口, 以供工作线程调度任务的执行, 它主要规定了任务的入口, 任务执行完后的收尾工作, 任务的执行状态等</p><p><strong>任务队列 :</strong> 用于存放没有处理的任务; 提供一种缓冲机制</p><h3 id="二-执行过程"><a href="#二-执行过程" class="headerlink" title="(二) 执行过程"></a>(二) 执行过程</h3><p>首先, 是否达到核心线程数量? </p><ul><li>没达到, 创建一个工作线程来执行任务</li><li>达到了, 进入工作队列</li></ul><p>其次, 工作队列是否已满? </p><ul><li>没满, 则将新提交的任务存储在工作队列里</li><li>满了, 创建新的线程</li></ul><p>最后, 是否达到线程池最大数量? </p><ul><li>没达到, 则创建一个新的工作线程来执行任务</li><li>达到了, 执行拒绝策略来处理这个任务</li></ul><p>过程梳理如图所示</p><pre><code class=" mermaid">graph LR执行 --&gt;  A&#123;没达到核心线程数&#125; --是--&gt; 创建新线程执行A&#123;没达到核心线程数&#125; --否--&gt; B&#123;工作队列没满?&#125;B&#123;工作队列没满?&#125; --是--&gt; 丢到队列B&#123;工作队列没满?&#125;--否--&gt; C&#123;没达到最大线程数?&#125;C&#123;没达到最大线程数?&#125; --是--&gt; 创建新线程</code></pre><h2 id="四-线程数量"><a href="#四-线程数量" class="headerlink" title="四 : 线程数量"></a>四 : 线程数量</h2><p>如何确定合适数量的线程? 要根据自己任务的类型进行判定</p><ul><li><strong>计算型任务 :</strong> cpu 数量的1~2倍数</li><li><strong>IO型任务 :</strong> 相对比计算型任务, 需要多一些线程, 要根据具体的 <strong>IO 阻塞时长</strong>进行考量决定; 如 tomcat 中默认的最大线程数为: 200</li></ul><p>也可考虑根据需要在一个<strong>最小数量和最大数量</strong>间自动增减线程数</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程封闭之ThreadLocal和栈封闭</title>
    <link href="/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/"/>
    <url>/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="一-线程封闭概念"><a href="#一-线程封闭概念" class="headerlink" title="一 : 线程封闭概念"></a>一 : 线程封闭概念</h2><p>多线程访问共享可变数据时, 涉及到线程间数据同步的问题, 并不是所有时候, 都要用到共享数据, 所以线程封闭概念就提出来了</p><p>数据都被封闭在各自的线程之中, 就不需要同步, 这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong></p><p>线程封闭的具体实现有: <strong>ThreadLocal</strong>, <strong>局部变量</strong></p><h2 id="二-ThreadLocal"><a href="#二-ThreadLocal" class="headerlink" title="二 : ThreadLocal"></a>二 : ThreadLocal</h2><p><strong>ThreadLocal 是 java 里一种特殊的变量</strong>, 它是一个<strong>线程级别变量</strong>, 每个线程都有一个 ThreadLocal, 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了, 在并发模式下是绝对安全的变量</p><p><strong>用法</strong>: <code>ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;();</code> 会自动在每一个线程上创建一个 T 的副本, 副本之间彼此独立, 互不影响; 可以用 ThreadLocal 存储一些参数, 以便在线程中多个方法中使用, <strong>用来代替方法传参的做法</strong>; </p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadLocalTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    value.set(<span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> value.get();<br>    System.out.println(<span class="hljs-string">&quot;线程1执行之前,主线程取到的值: &quot;</span> + v);<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> value.get();<br>        System.out.println(<span class="hljs-string">&quot;线程1取到的值: &quot;</span> + s);<br>        value.set(<span class="hljs-string">&quot;456&quot;</span>);<br><br>        s = value.get();<br>        System.out.println(<span class="hljs-string">&quot;重新设置后,线程1取到的值: &quot;</span> + s);<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">5000L</span>);<br>    v = value.get();<br>    System.out.println(<span class="hljs-string">&quot;线程1执行之后,主线程取到的值: &quot;</span> + v);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalDemo</span>().threadLocalTest();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>实在难以理解的, 可以理解为, jvm 维护了一个 Map&lt;Thread, T&gt;, 每个线程要用这个 T 的时候, 用当前的线程去 Map 里面取, 仅作为一个概念理解</p><h2 id="三-栈封闭"><a href="#三-栈封闭" class="headerlink" title="三 : 栈封闭"></a>三 : 栈封闭</h2><p><strong>局部变量</strong>的固有属性之一就是封闭在线程中</p><p>它们位于执行线程的栈中, 其他线程无法访问这个栈</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程通信</title>
    <link href="/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-通信的方式"><a href="#一-通信的方式" class="headerlink" title="一 : 通信的方式"></a>一 : 通信的方式</h2><p>要想实现多个线程之间的协同, 如: 线程执行先后顺序, 获取某个线程执行的结果等等</p><p>涉及到线程之间相互通信, 分为四类:</p><ul><li>文件共享</li><li>网络共享</li><li>共享变量</li><li>JDK 提供的线程协调 API (suspend&#x2F;resume, wait&#x2F;notify, park&#x2F;unpark)</li></ul><h2 id="二-文件共享"><a href="#二-文件共享" class="headerlink" title="二 : 文件共享"></a>二 : 文件共享</h2><ul><li><p>线程1在<strong>文件</strong>中写入数据, 线程2从文件中读取数据</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1 写入数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Files.write(Paths.get(<span class="hljs-string">&quot;a.txt&quot;</span>), (<span class="hljs-string">&quot;当前时间: &quot;</span> + System.currentTimeMillis()).getBytes());<br>                Thread.sleep(<span class="hljs-number">1000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 线程2 读数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                    <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;a.txt&quot;</span>));<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三-变量共享"><a href="#三-变量共享" class="headerlink" title="三 : 变量共享"></a>三 : 变量共享</h2><ul><li><p>线程-1在<strong>内存</strong>中写入数据, 线程-2从内存中读取数据</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1 写入数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    content = <span class="hljs-string">&quot;当前时间: &quot;</span> + System.currentTimeMillis();<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">// 线程2 读取数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                    System.out.println(content);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="四-线程协作-JDK-API"><a href="#四-线程协作-JDK-API" class="headerlink" title="四 : 线程协作-JDK API"></a>四 : 线程协作-JDK API</h2><p>JDK 中对于需要多线程协作完成某一任务的场景, 提供了对应API支持</p><p>多线程协作的典型场景是 : 生产者 - 消费者模型(线程阻塞, 线程唤醒); </p><pre><code class=" mermaid">sequenceDiagram消费者-&gt;&gt;+包子店:买包子包子店--&gt;&gt;-消费者:没有消费者-&gt;&gt;+消费者:等待生产者-&gt;&gt;包子店:生产包子生产者-&gt;&gt;消费者:通知有包子了</code></pre><h3 id="一-suspend-x2F-resume-机制-弃用"><a href="#一-suspend-x2F-resume-机制-弃用" class="headerlink" title="(一) suspend&#x2F;resume 机制(弃用)"></a>(一) suspend&#x2F;resume 机制(弃用)</h3><ul><li><p>作用: 调用 suspend 挂起目标线程, 通过 resume 可以恢复线程执行; 被弃用的主要原因是, 容易写出死锁的代码, 所以用 wait&#x2F;notify 和 park&#x2F;unpark 机制对它进行替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 买包子 =&gt; 如果没有包子 =&gt; 则进入等待 =&gt; 当生产出包子后通知消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">suspendResumeTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子, 进入等待&quot;</span>);<br>            Thread.currentThread().suspend();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    <span class="hljs-comment">// 3秒后通知消费者</span><br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    thread.resume();<br>    System.out.println(<span class="hljs-string">&quot;生产出包子,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>suspend 和 resume 死锁示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend并不会像wait一样释放锁,很容易出现死锁代码</span><br><span class="hljs-comment"> * 还是买包子, 但如果出现了锁竞争问题, 就会出现死锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">suspendResumeDeadLockTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                Thread.currentThread().suspend();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        thread.resume();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-wait-x2F-notify-机制"><a href="#二-wait-x2F-notify-机制" class="headerlink" title="(二) wait&#x2F;notify 机制"></a>(二) wait&#x2F;notify 机制</h3><ul><li><p>这些方法只能由同一对象锁的持有者线程调用, 也就是写在同步块里面, 否则会抛出 IllegalMonitorStateException 异常</p></li><li><p>wait 方法导致当前线程等待, 加入该对象的等待集合中, 并且放弃当前持有的对象锁</p></li><li><p>notify&#x2F;notifyAll 方法唤醒一个或者所有正在等待这个对象锁的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 正常的wait/notify</span><br><span class="hljs-comment"> * 还是买包子,可以有锁竞争,因为wait会释放锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotifyTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-built_in">this</span>.notify();<br>        System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意: 虽然会 wait 自动解锁, 但是<strong>对顺序有要求</strong>, 如果在 notify 被调用之后才开始wait方法的调用, 线程会永远处于 WAITING 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * wait/notify会释放锁, 但是如果出现先notify(通知)后wait(等待)</span><br><span class="hljs-comment"> * 这是线程就会一直等待, 也可以看作是另一种形式的死锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotifyWaitForeverTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">5000L</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后,生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-built_in">this</span>.notify();<br>        System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="三-park-x2F-unpark-机制"><a href="#三-park-x2F-unpark-机制" class="headerlink" title="(三) park&#x2F;unpark 机制"></a>(三) park&#x2F;unpark 机制</h3><ul><li><p>线程调用 park 则等待<strong>许可</strong>(permit), unpark 方法为指定线程提供”许可(permit)”</p></li><li><p><strong>不要求 park 和 unpark 方法的调用顺序</strong></p></li><li><p>多次调用 unpark 之后, 再调用 park , 线程会直接运行</p></li><li><p>但不会叠加, 也就是说, 连续多次调用 park 方法, 第一次会拿到”许可”直接运行, 后续调用会进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 正常的park/unPark</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnparkTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            LockSupport.park();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后生产包子&quot;</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    LockSupport.unpark(thread);<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意: 同步代码容易写出死锁代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * park/unpark虽然没有顺序要求, 但是如果不会释放锁</span><br><span class="hljs-comment"> * 如果出现锁竞争问题,还是要考虑死锁的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnparkDeadLockTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                LockSupport.park();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒,生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        LockSupport.unpark(thread);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="五-伪唤醒"><a href="#五-伪唤醒" class="headerlink" title="五 : 伪唤醒"></a>五 : 伪唤醒</h2><ul><li><p>警告: 之前代码中用 if 语句来判断是否进入等待状态, 这是错误的 !</p></li><li><p>官方建议应该在循环中检查等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒, 如果不在循环中检查等待条件, 程序就会在没有满足条件的情况下退出</p></li><li><p>伪唤醒是指线程并非因为 notify, notifyAll, unpark 等 api 调用而唤醒, 是更底层原因导致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//wait</span><br><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-keyword">while</span> (&lt;条件判断&gt;)<br>        obj.wait();<br>    ...<span class="hljs-comment">//执行后续操作&#125;</span><br>&#125;<br><span class="hljs-comment">// park</span><br><span class="hljs-keyword">while</span> (&lt;条件判断&gt;)<br>    LockSupport.park();<br>...<span class="hljs-comment">//执行后续操作</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存屏障和CPU缓存</title>
    <link href="/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/"/>
    <url>/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-CPU性能优化手段-缓存"><a href="#一-CPU性能优化手段-缓存" class="headerlink" title="一 : CPU性能优化手段-缓存"></a>一 : CPU性能优化手段-缓存</h2><p>为了提高程序运行的性能, 现代 CPU 在很多方面对程序进行了优化; 例如 : CPU 高速缓存, 尽可能地避免处理器访问主内存的时间开销, 处理器大多会利用缓存(cache)以提高性能</p><pre><code class=" mermaid">graph LRA1[CPU] --- B1[L1-L3缓存] --- 缓存一致性协议 --- 主内存A2[CPU] --- B2[L1-L3缓存] --- 缓存一致性协议A3[CPU] --- B3[L1-L3缓存] --- 缓存一致性协议</code></pre><h3 id="一-多级缓存"><a href="#一-多级缓存" class="headerlink" title="(一) 多级缓存"></a>(一) 多级缓存</h3><p>L1 Cache(一级缓存)是 CPU 第一层高速缓存, 分为数据缓存和指令缓存; 一般服务器 CPU 的 L1 缓存的容量通常在 <strong>32~4096KB</strong></p><p>L2 由于 L1 级高速缓存容量的限制, 为了再次提高CPU的运算速度, 在 CPU 外部放置一高速存储器, 即二级缓存</p><p>L3 现在的都是内置的; 作用是: L3缓存的应用可以进一步降低内存延迟, 同时提升大数据量计算时处理器的性能; 具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度; 一般是多核共享一个 L3 缓存</p><p><strong>读取顺序 :</strong> CPU 在读取数据时, 现在 L1 中寻找, 再从 L2 寻找, 再从 L3 寻找, 然后是内存, 再后是外存储器</p><h3 id="二-缓存同步协议"><a href="#二-缓存同步协议" class="headerlink" title="(二) 缓存同步协议"></a>(二) 缓存同步协议</h3><p>多 CPU 读取同样的数据进行缓存, 进行不同运算之后, 最终写入主内存以哪个 CPU 为准 ?</p><p>在这种高速缓存写的场景下, 有一个<strong>缓存一致性协议(MESI 协议)</strong>, 多数 CPU 厂商对它进行了实现; 它规定每条缓存有个状态位, 同时定义了下面四个状态 :</p><ul><li><strong>修改态(Modified)</strong> : 此 cache 行已被修改过(脏行), 内容已不同于主内存, 为此 cache 专有</li><li><strong>专有态(Exclusive)</strong> : 此 cache 行内容同于主存, 但不出现于其他 cache 中</li><li><strong>共享态(Shared)</strong> : 此 cache 行内容同于主存, 但也出现于其他 cache 中</li><li><strong>无效态(Invalid)</strong> : 此 cache 行 内容无效(空行)</li></ul><p>多处理器时, 单个 CPU 对缓存中数据进行了改动, 需要通知给其他 CPU; 也就是意味着, <strong>CPU 处理要控制自己的读写操作, 还要监听其他 CPU 发出的通知, 从而保证最终一致</strong></p><h2 id="二-CPU性能优化手段-运行时指令重排"><a href="#二-CPU性能优化手段-运行时指令重排" class="headerlink" title="二 : CPU性能优化手段-运行时指令重排"></a>二 : CPU性能优化手段-运行时指令重排</h2><p>指令重排的场景 : 当 CPU <strong>写缓存时</strong>发现缓存区块正被其他 CPU 占用, 为了提高 CPU 处理性能, 可能将后面的<strong>读缓存命令优先执行</strong></p><p><img src="D:\blog\source\java\image-2020020701.jpg"> </p><p>并非随便重排, 需要遵守 <strong>as-if-serial</strong> 语义</p><p><code>as-if-serial</code> 语义的意思指: 不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变; 编译器, runtime 和处理器都必须遵守 as-if-serial 语义</p><p>也就是说: 编译器和处理器<strong>不会对存在数据依赖关系的操作重排序</strong></p><h2 id="三-两个问题"><a href="#三-两个问题" class="headerlink" title="三 : 两个问题"></a>三 : 两个问题</h2><p>CPU 高速缓存下有一个问题 :</p><ul><li>缓存中的数据与主内存的数据并不是实时同步的, 各 CPU (或 CPU 核心) 间缓存的数据也不是实时同步;</li><li><strong>在同一个时间点, 各 CPU 所看到同一内存地址的数据的值可能时不一致的</strong></li></ul><p>CPU 执行指令重排序优化下有一个问题 :</p><ul><li>虽然遵守了 as-if-serial 语义, 但仅在单 CPU 自己执行的情况下能保证结果正确;</li><li>多核多线程中, 指令逻辑无法分辨因果关联, 可能出现<strong>乱序执行</strong>, 导致程序运行结果错误</li></ul><h2 id="四-内存屏障"><a href="#四-内存屏障" class="headerlink" title="四 : 内存屏障"></a>四 : 内存屏障</h2><p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题 : </p><ul><li><strong>写内存屏障(Store Memory Barrier)</strong>: 在指令后插入 Store Barrier, 能让写入缓存中的最新数据更新写入主内存, 让其他线程可见; 强制写入主内存, 这种显示调用, <strong>CPU 就不会因为性能考虑而去对指令重排</strong></li><li><strong>读内存屏障(Load Memory Barrier)</strong>: 在指令前插入 Load Barrier, 可以让高速缓存中的数据失效, 强制重新从主内存加载数据; 强制读取主内存内容, 让 CPU 缓存与主内存保持一致, <strong>避免了缓存导致的一致性问题</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程终止</title>
    <link href="/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/"/>
    <url>/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一-stop-不建议"><a href="#一-stop-不建议" class="headerlink" title="一 : stop(不建议)"></a>一 : stop(不建议)</h2><ul><li><p>stop : 中止线程, 并且清除监控器锁的信息, 但是可能导致线程安全问题, JDK 不建议用</p></li><li><p>destroy : JDK 未实现该方法</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">StopThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThread</span>();<br>        thread.start();<br>        <span class="hljs-comment">// 休眠1秒，确保i变量自增成功</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 暂停线程</span><br>        thread.stop(); <span class="hljs-comment">// 错误的终止</span><br>        <span class="hljs-keyword">while</span> (thread.isAlive()) &#123;<br>            <span class="hljs-comment">// 确保线程已经终止</span><br>        &#125; <br>        <span class="hljs-comment">// 输出结果</span><br>        thread.print();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 增加同步锁，确保线程安全</span><br>            ++i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 休眠10秒,模拟耗时操作</span><br>                Thread.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            ++j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印i和j</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot; j=&quot;</span> + j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-interrupt-推荐"><a href="#二-interrupt-推荐" class="headerlink" title="二 : interrupt(推荐)"></a>二 : interrupt(推荐)</h2><ul><li><p>如果目标线程在调用 Object class 的 wait(), wait(long) 或 wait(long, int) 方法, join(), join(long, int) 或者 sleep(long, int) 方法时被阻塞, 那么 interrupt 会生效, 该线程的中断状态将被清除, 抛出 InterruptedException 异常</p></li><li><p>如果目标线程是被 I&#x2F;O 或者 NIO 中的 Channel 所阻塞, 同样, I&#x2F;O 操作会被中断或者返回特殊异常值; 达到终止线程的目的</p></li><li><p>如果以上条件都不满足, 则会设置此线程的终端状态</p></li><li><p>代码示例, 修改之前的代码 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// thread.stop(); // 错误的终止</span><br>thread.interrupt(); <span class="hljs-comment">// 正确终止</span><br></code></pre></td></tr></table></figure></li><li><p>将 stop 改成 interrupt 后, 最终输出为 <code>i=1 j=1</code>, 数据一致</p></li></ul><h2 id="三-标志位-推荐"><a href="#三-标志位-推荐" class="headerlink" title="三 : 标志位(推荐)"></a>三 : 标志位(推荐)</h2><ul><li><p>代码逻辑中, 增加一个判断, 用来控制线程执行的中止</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 通过状态位来判断 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (flag) &#123; <span class="hljs-comment">// 判断是否运行</span><br>                    System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">// 3秒之后，将状态标志改为False，代表不继续运行</span><br>        Thread.sleep(<span class="hljs-number">3000L</span>);<br>        flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;程序运行结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程状态</title>
    <link href="/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-状态定义"><a href="#一-状态定义" class="headerlink" title="一 : 状态定义"></a>一 : 状态定义</h2><p>定义位置 : java.lang.Thread.State</p><p>线程状态 : 新建, 可运行, 阻塞, 等待, 超时等待, 终止</p><ul><li><strong>New</strong> : 尚未启动的线程的线程状态</li><li><strong>Runnable</strong> : 可运行线程的线程状态, 等待CPU调度</li><li><strong>Blocked</strong> : 线程阻塞, <strong>等待监视器锁定</strong>的线程状态; 处于 synchronized 同步代码块或方法中被阻塞</li><li><strong>Waiting</strong> : 等待线程的线程状态; 不带超时的方式(Object.wait, Thread.join, LockSupport.park)</li><li><strong>Time Waiting</strong> : 具有指定等待时间的等待线程的线程状态; 带超时的方式(Thread.sleep, Object.wait, Thread.join, LockSupport.parkNanos, LockSupport.parkUntil)</li><li><strong>Terminated</strong> : 终止线程的线程状态; 线程正常完成执行或者出现异常</li></ul><h2 id="二-线程状态切换"><a href="#二-线程状态切换" class="headerlink" title="二 : 线程状态切换"></a>二 : 线程状态切换</h2><p>这 6 种状态在一定条件下会发生转换</p><pre><code class=" mermaid">graph LRNew新线程 --开始--&gt; Runnable可运行状态Runnable可运行状态 --等待锁---&gt; Blocked阻塞状态Blocked阻塞状态 --已拿到锁---&gt; Runnable可运行状态Runnable可运行状态 --等待其他线程的通知---&gt; Waiting等待状态Waiting等待状态 --收到通知,继续执行---&gt; Runnable可运行状态Runnable可运行状态 --有超时时间的等待其他线程通知---&gt; A[Timed Waiting等待状态]A[Timed Waiting等待状态] --等待超时或者收到通知,继续执行---&gt; Runnable可运行状态    Runnable可运行状态 --执行结束---&gt; Terminated终止 </code></pre><ul><li><code>New</code> 新线程通过调用 <code>start</code> 进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>等待锁</strong>的时候会进入 <code>Blocked</code> 阻塞状态; 一旦拿到锁, 便会从 <code>Blocked</code> 阻塞状态进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>等待其他线程的通知时</strong>会进入 <code>Waiting</code> 等待状态; 一旦收到通知,继续执行时, 便会从 <code>Waiting</code> 等待状态进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>有超时时间的等待其他线程的通知时</strong>会进入 <code>Time Waiting</code> 定时等待状态; 一旦等待超时或者收到通知, 继续执行时则会进入 <code>Runnable</code> 状态</li><li><code>Runnable</code> 可运行状态在线程执行结束时会成为 <code>Terminated</code> 终止状态</li></ul><h2 id="三-代码演示"><a href="#三-代码演示" class="headerlink" title="三 : 代码演示"></a>三 : 代码演示</h2><ul><li><p>New &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止</span><br>    System.out.println(<span class="hljs-string">&quot;### 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止 ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread1当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>        System.out.println(<span class="hljs-string">&quot;thread1 执行了&quot;</span>);<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;没调用start方法,thread1当前状态: &quot;</span> + thread1.getState().toString());<br>    thread1.start();<br>    Thread.sleep(<span class="hljs-number">2000L</span>); <span class="hljs-comment">// 等待thread1执行结束，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待两秒,再看thread1当前状态: &quot;</span> + thread1.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>new &#x3D;&gt; Runnable &#x3D;&gt; Timed Waiting &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)</span><br>    System.out.println(<span class="hljs-string">&quot;### 第二种: 新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式) ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 进入超时等待, 时间1.5s</span><br>            Thread.sleep(<span class="hljs-number">1500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;thread2当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>        System.out.println(<span class="hljs-string">&quot;thread2 执行了&quot;</span>);<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;没调用start方法，thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    thread2.start();<br>    System.out.println(<span class="hljs-string">&quot;调用start方法，thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    Thread.sleep(<span class="hljs-number">200L</span>); <span class="hljs-comment">// 等待200毫秒，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待200毫秒，再看thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    Thread.sleep(<span class="hljs-number">3000L</span>); <span class="hljs-comment">// 再等待3秒，让thread2执行完毕，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待3秒，再看thread2当前状态: &quot;</span> + thread2.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>new &#x3D;&gt; Runnable &#x3D;&gt; Blocked &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止</span><br>    System.out.println(<span class="hljs-string">&quot;### 第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止 ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread3当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>            System.out.println(<span class="hljs-string">&quot;thread3 执行了&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>        System.out.println(<span class="hljs-string">&quot;没调用start方法，thread3当前状态: &quot;</span> + thread3.getState().toString());<br>        thread3.start();<br>        System.out.println(<span class="hljs-string">&quot;调用start方法，thread3当前状态: &quot;</span> + thread3.getState().toString());<br>        Thread.sleep(<span class="hljs-number">200L</span>); <span class="hljs-comment">// 等待200毫秒，再看状态</span><br>        System.out.println(<span class="hljs-string">&quot;等待200毫秒，再看thread3当前状态: &quot;</span> + thread3.getState().toString());<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">3000L</span>); <span class="hljs-comment">// 再等待3秒，让thread3执行完毕，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待3秒，让thread3抢到锁，再看thread3当前状态: &quot;</span> + thread3.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java程序运行堆栈分析</title>
    <link href="/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/"/>
    <url>/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>jvm 运行时数据区大致可以分为两部分 : <u>线程共享</u>部分和<u>线程独占</u>部分</p><p><img src="/../java/image-2020010301.jpg"></p><p><strong>线程共享</strong> : 所有线程能访问这块内存数据, 随虚拟机或者 <code>GC</code> 而创建和销毁; <strong>方法区</strong>和<strong>堆内存</strong>皆属此列</p><p><strong>线程独占</strong> : 每个线程都会有它的独立的空间, 随线程生命周期而创建和销毁; <strong>虚拟机栈</strong>, <strong>本地方法栈</strong>和<strong>程序计数器</strong>属于线程独占</p><h2 id="二-JVM运行时数据区"><a href="#二-JVM运行时数据区" class="headerlink" title="二 : JVM运行时数据区"></a>二 : JVM运行时数据区</h2><h3 id="一-方法区"><a href="#一-方法区" class="headerlink" title="(一) 方法区"></a>(一) 方法区</h3><p>jvm 启动时创建, 用来存储加载<u>类信息, 常量, 静态变量, 编译后的代码</u>等数据; </p><p><img src="/../java/image-2020010302.jpg"></p><p>虚拟机规范中这是一个逻辑区划, 具体实现根据不同虚拟机来实现; 例如: </p><ul><li>oracle 的 HotSpot 在 java7 中方法区放在<strong>永久代</strong>; </li><li>java8 放在<strong>元数据空间</strong> (metaspace), 并且通过 <code>GC</code> 机制对这个区域进行管理。</li></ul><h3 id="二-堆内存"><a href="#二-堆内存" class="headerlink" title="(二) 堆内存"></a>(二) 堆内存</h3><p>jvm 启动时创建, 存放<u>对象的实例</u>; <strong>垃圾回收器主要就是管理堆内存;</strong> </p><p><img src="/../java/image-2020010303.jpg"></p><p>如果满了, 就会出现 <code>OutOfMemroyError</code>; </p><p>堆内存还可以细分为 : <strong>新生代</strong>(<code>Eden</code>, <code>From Survivor(s0)</code> 和 <code>To Survivor(s1)</code>)和<strong>老年代</strong> (<code>Old</code>)</p><h3 id="三-虚拟机栈"><a href="#三-虚拟机栈" class="headerlink" title="(三) 虚拟机栈"></a>(三) 虚拟机栈</h3><p>随线程的生命周期创建和销毁, 每个线程都在在这个空间有一个私有的空间, 这个空间称为线程栈; </p><p><img src="/../java/image-2020010304.jpg"></p><p>线程栈由多个<u>栈帧 (Stack Frame)</u> 组成; 栈帧内容包含 : 局部变量表, 操作数栈, 动态链接, 方法返回地址和附加信息等; </p><p><strong>一个线程会执行一个或多个方法, 一个方法对应一个栈帧</strong>; </p><p>栈内存默认最大是 <strong>1M</strong>, 超出则抛出 <code>StackOverflowError</code></p><h3 id="四-本地方法栈"><a href="#四-本地方法栈" class="headerlink" title="(四) 本地方法栈"></a>(四) 本地方法栈</h3><p>和虚拟机栈功能类似, 虚拟机栈是为虚拟机执行java方法而准备的, 本地方法栈是为虚拟机使用 <code>Native</code> 本地方法而准备的;</p><p><img src="/../java/image-2020010305.jpg"></p><p>虚拟机规范没有规定具体的实现, 由不同的虚拟机厂商去实现;</p><p>HotSpot 虚拟机中虚拟机栈和本地方法栈的实现是一样的; 同样, 超出大小以后也会抛出 <code>StackOverflowError</code></p><h3 id="五-程序计数器"><a href="#五-程序计数器" class="headerlink" title="(五) 程序计数器"></a>(五) 程序计数器</h3><p>程序计数器 (Program Counter Register) 记录当前线程执行字节码的位置, 存储的是<u>字节码指令地址</u>, </p><p><img src="/../java/image-2020010306.jpg"></p><p>如果执行Native方法, 则计数器值为空;</p><p><strong>每个线程都在这个空间有一个私有的空间, 占用内存空间很少;</strong></p><p>CPU 同一时间, 只会执行一条线程中的指令; <code>jvm</code> 多线程会轮流切换并分配 <code>CPU</code> 执行时间; 线程切换后, 需要通过程序计数器, 来恢复正确的执行位置</p><h2 id="三-class文件内容"><a href="#三-class文件内容" class="headerlink" title="三 : class文件内容"></a>三 : class文件内容</h2><h3 id="一-概述-1"><a href="#一-概述-1" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p>class 文件包含 java 程序执行的字节码; 数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符; 文件开头有一个<code>ca fe ba be</code> (16进制)特殊的一个标志; </p><p><img src="/../java/image-2020010307.jpg"> </p><p>这个文件具有复杂且严格的格式, 专门给 jvm 读取其中的内容, 人类可以借助工具查看; 其中包含 : 版本信息, 访问标志, 常量池, 当前类, 超级类, 接口, 字段, 方法, 属性等信息</p><h3 id="二-内容分析"><a href="#二-内容分析" class="headerlink" title="(二) 内容分析"></a>(二) 内容分析</h3><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        System.out.println(a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反编译 class 文件并重定向到 txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac Demo.java</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">反编译将其写入txt文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">javap -v Demo.class &gt; Demo.txt</span><br></code></pre></td></tr></table></figure></li><li><p>版本号&#x2F;访问控制, 版本号规则 : JDK5,6,7,8 分别对应 49,50,51,52</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Demo</span><br>  <span class="hljs-symbol">minor</span> <span class="hljs-symbol">version: <span class="hljs-symbol">0</span></span> //次版本号<br>  <span class="hljs-symbol">major</span> <span class="hljs-symbol">version: <span class="hljs-symbol">52</span></span> //主版本号<br>  <span class="hljs-symbol">flags: <span class="hljs-symbol">ACC_PUBLIC</span>, <span class="hljs-symbol">ACC_SUPER</span></span> //访问标志<br></code></pre></td></tr></table></figure></li><li><p>常量池</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Constant pool:<br>   <span class="hljs-string">#1</span> = Methodref          <span class="hljs-string">#5</span>.<span class="hljs-string">#14</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-string">#2</span> = Fieldref           <span class="hljs-string">#15</span>.<span class="hljs-string">#16</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-string">#3</span> = Methodref          <span class="hljs-string">#17</span>.<span class="hljs-string">#18</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   <span class="hljs-string">#4</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#19</span>            <span class="hljs-comment">// Demo1</span><br>   <span class="hljs-string">#5</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#20</span>            <span class="hljs-comment">// java/lang/Object</span><br>   <span class="hljs-string">#6</span> = Utf8               &lt;init&gt;<br>   <span class="hljs-string">#7</span> = Utf8               ()V<br>   <span class="hljs-string">#8</span> = Utf8               Code<br>   <span class="hljs-string">#9</span> = Utf8               LineNumberTable<br>  <span class="hljs-string">#10</span> = Utf8               main<br>  <span class="hljs-string">#11</span> = Utf8               ([Ljava/lang/<span class="hljs-keyword">String</span>;)V<br>  <span class="hljs-string">#12</span> = Utf8               SourceFile<br>  <span class="hljs-string">#13</span> = Utf8               Demo1.java<br>  <span class="hljs-string">#14</span> = NameAndType        <span class="hljs-string">#6</span>:<span class="hljs-string">#7</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-string">#15</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#21</span>            <span class="hljs-comment">// java/lang/System</span><br>  <span class="hljs-string">#16</span> = NameAndType        <span class="hljs-string">#22</span>:<span class="hljs-string">#23</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  <span class="hljs-string">#17</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#24</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  <span class="hljs-string">#18</span> = NameAndType        <span class="hljs-string">#25</span>:<span class="hljs-string">#26</span>        <span class="hljs-comment">// println:(I)V</span><br>  <span class="hljs-string">#19</span> = Utf8               Demo1<br>  <span class="hljs-string">#20</span> = Utf8               java/lang/<span class="hljs-keyword">Object</span><br>  <span class="hljs-string">#21</span> = Utf8               java/lang/System<br>  <span class="hljs-string">#22</span> = Utf8               <span class="hljs-keyword">out</span><br>  <span class="hljs-string">#23</span> = Utf8               Ljava/io/PrintStream;<br>  <span class="hljs-string">#24</span> = Utf8               java/io/PrintStream<br>  <span class="hljs-string">#25</span> = Utf8               println<br>  <span class="hljs-string">#26</span> = Utf8               (I)V<br></code></pre></td></tr></table></figure></li><li><p>构造方法 : 示例中并没有写构造函数, 由此可见, 没有定义构造函数时, 会有隐式的无参构造函数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">Demo();</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">()V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=1,</span> <span class="hljs-string">args_size=1</span><br>      <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br>      <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>      <span class="hljs-attr">4:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 1:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>程序入口 main 方法 : stack(操作数栈), locals(为本地变量表)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><span class="hljs-string">//访问控制</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=3,</span> <span class="hljs-string">locals=5,</span> <span class="hljs-string">args_size=1</span><br>      <span class="hljs-string">/**</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">jvm执行引擎去执行这些源码编译过后的指令码</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">javap编译出来是操作符,class文件内存的是指令码</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">前面的数字,是偏移量(字节),jvm根据这个去区分不同的指令(查看jvm指令码表)</span><br>       <span class="hljs-string">*/</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">sipush</span>        <span class="hljs-number">500</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">100</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">istore_2</span><br>       <span class="hljs-attr">7:</span> <span class="hljs-string">iload_1</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">idiv</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">istore_3</span><br>      <span class="hljs-attr">11:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">50</span><br>      <span class="hljs-attr">13:</span> <span class="hljs-string">istore</span>        <span class="hljs-number">4</span><br>      <span class="hljs-attr">15:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#2        // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-attr">18:</span> <span class="hljs-string">iload_3</span><br>      <span class="hljs-attr">19:</span> <span class="hljs-string">iload</span>         <span class="hljs-number">4</span><br>      <span class="hljs-attr">21:</span> <span class="hljs-string">iadd</span><br>      <span class="hljs-attr">22:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#3        // Method java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-attr">25:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">line 4:</span> <span class="hljs-number">4</span><br>      <span class="hljs-attr">line 5:</span> <span class="hljs-number">7</span><br>      <span class="hljs-attr">line 6:</span> <span class="hljs-number">11</span><br>      <span class="hljs-attr">line 7:</span> <span class="hljs-number">15</span><br>      <span class="hljs-attr">line 8:</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="四-程序完整运行分析"><a href="#四-程序完整运行分析" class="headerlink" title="四 : 程序完整运行分析"></a>四 : 程序完整运行分析</h2><h3 id="一-加载信息到方法区"><a href="#一-加载信息到方法区" class="headerlink" title="(一) 加载信息到方法区"></a>(一) 加载信息到方法区</h3><p>此时属于线程共享部分的<strong>方法区</strong>会存在大量的类信息, 同时还存在运行时常量池字符串常量。</p><p>HotSpot 虚拟机 : 1.7及之前称为永久代, 1.8开始称为元数据空间。</p><h3 id="二-jvm-创建线程来执行代码"><a href="#二-jvm-创建线程来执行代码" class="headerlink" title="(二) jvm 创建线程来执行代码"></a>(二) jvm 创建线程来执行代码</h3><p>在虚拟机栈, 程序计数器内存区域中创建线程独占的空间。</p><p>虚拟机栈中存放<strong>Thread栈帧</strong>, 程序计数器中存放<strong>Thread执行位置</strong>(字节码指令地址)。</p><h3 id="三-方法区程序入口"><a href="#三-方法区程序入口" class="headerlink" title="(三) 方法区程序入口"></a>(三) 方法区程序入口</h3><p>main 方法栈帧初始化 : 5个本地变量, 变量0是方法参数 args</p><p><img src="/../execute/execute_00.png"> </p><h3 id="四-程序执行过程"><a href="#四-程序执行过程" class="headerlink" title="(四) 程序执行过程"></a>(四) 程序执行过程</h3><ol><li><p>将500压入操作数栈</p><p><img src="/../execute/execute_01.png"></p></li><li><p>弹出操作数栈栈顶500保存到本地变量表1</p><p><img src="/../execute/execute_02.png"></p></li><li><p>将100压入操作数栈</p><p><img src="/../execute/execute_03.png"></p></li><li><p>弹出操作数栈栈顶100保存到本地变量表2</p><p><img src="/../execute/execute_04.png"></p></li><li><p>读取本地变量1压入操作数栈</p><p><img src="/../execute/execute_05.png"></p></li><li><p>读取本地变量2压入操作数栈</p><p><img src="/../execute/execute_06.png"></p></li><li><p>将栈顶两int类型数相除, 结果入栈 500&#x2F;100&#x3D;5</p><p><img src="/../execute/execute_07.png"></p></li><li><p>将栈顶int类型值保存到局部变量3中</p><p><img src="/../execute/execute_08.png"></p></li><li><p>将50压入操作数栈</p><p><img src="/../execute/execute_09.png"></p></li><li><p>将栈顶int类型值保存到局部变量4中</p><p><img src="/../execute/execute_10.png"></p></li><li><p>获取类或接口字段的值并将其压入操作数栈</p><p><img src="/../execute/execute_11.png"></p></li><li><p>将本地变量3取出压入操作数栈</p><p><img src="/../execute/execute_12.png"></p></li><li><p>将本地变量4取出压入操作数栈</p><p><img src="/../execute/execute_13.png"></p></li><li><p>将栈顶两int类型数相加, 结果入栈</p><p><img src="/../execute/execute_14.png"></p></li><li><p>调用静态方法; jvm会根据这个方法的描述,创建新栈帧, 方法的参数从操作数栈中弹出来,压入虚拟机栈, 然后虚拟机会开始执行虚拟机栈最上面的栈帧; 执行完毕后,再继续执行main方法对应的栈帧</p><p><img src="/../execute/execute_15.png"></p></li><li><p>void函数返回, main方法执行结束</p><p><img src="/../execute/execute_16.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客图床</title>
    <link href="/2019/12/25/blog-images/"/>
    <url>/2019/12/25/blog-images/</url>
    
    <content type="html"><![CDATA[<h2 id="一-typora"><a href="#一-typora" class="headerlink" title="一 : typora"></a>一 : typora</h2><p>下载地址 : <a href="https://download2.typoraio.cn/windows/typora-setup-x64.exe">https://download2.typoraio.cn/windows/typora-setup-x64.exe</a></p><p>傻瓜式安装即可</p><h2 id="二-github"><a href="#二-github" class="headerlink" title="二 : github"></a>二 : github</h2><p>创建一个公开仓库 : blog_images</p><p>在 settings &#x3D;&gt; Developer settings &#x3D;&gt; Personal access tokens 里生成一个 token</p><h2 id="三-picgo"><a href="#三-picgo" class="headerlink" title="三 : picgo"></a>三 : picgo</h2><p>文件 &#x3D;&gt; 偏好设置 &#x3D;&gt; 图像, 做如下修改</p><p><img src="/../blog/image-2019122501.png" alt="image-2019122501"> </p><p>点击下载或更新, 下载 PicGo-Core(command-line)</p><p>下载完毕后, 点击打开配置文件, 或者手动打开 <code>C:/Users/&#123;用户名&#125;/.picgo/config.json</code>, 参考下面文件进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;current&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;github&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;github&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;repo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;info4z/blog_images&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;branch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;刚刚生成的 Personal access tokens&quot;</span><span class="hljs-punctuation">,</span>  <br>            <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;images&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;customUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/info4z/blog_images@main&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客美化</title>
    <link href="/2019/12/24/blog-theme/"/>
    <url>/2019/12/24/blog-theme/</url>
    
    <content type="html"><![CDATA[<h2 id="一-主题"><a href="#一-主题" class="headerlink" title="一 : 主题"></a>一 : 主题</h2><ul><li><p>博客搭建完毕后, 可以对其进行一定的美化, 可以使用 kaze 主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> git@github.com:theme-kaze/hexo-theme-kaze.git themes/kaze<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-站点配置"><a href="#二-站点配置" class="headerlink" title="二 : 站点配置"></a>二 : 站点配置</h2><ul><li><p>编辑博客根目录下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">冰清阁</span><span class="hljs-comment">#标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;差不多得了, 玩什么命呀...&#x27;</span><span class="hljs-comment">#简介或者格言</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">清月明风</span><span class="hljs-comment">#作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><span class="hljs-comment">#主题语言,查看themes\next\languages下面的具体名字</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-comment">#中国的时区</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://info4z.github.io</span><br><br><span class="hljs-comment"># 代码高亮</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">kaze</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="三-主题配置"><a href="#三-主题配置" class="headerlink" title="三 : 主题配置"></a>三 : 主题配置</h2><ul><li><p>修改 kaze下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Header config</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">冰清阁</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">清月明风</span><br><span class="hljs-attr">logo_img:</span> <span class="hljs-string">https://img.songhn.com/img/Y67gdd.png</span><br><span class="hljs-attr">author_img:</span> <span class="hljs-string">https://img.songhn.com/img/Y67gdd.png</span><br><span class="hljs-attr">author_description:</span> <span class="hljs-string">差不多得了,</span> <span class="hljs-string">玩什么命呀...</span><br></code></pre></td></tr></table></figure></li><li><p>目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Navbar config</span><br><span class="hljs-attr">menus:</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories</span><br>  <span class="hljs-attr">archive:</span> <span class="hljs-string">/archives</span><br>  <span class="hljs-attr">about:</span> <span class="hljs-string">/about</span><br>  <span class="hljs-attr">friends:</span> <span class="hljs-string">/friends</span><br></code></pre></td></tr></table></figure></li><li><p>当然了, 有些目录是不存在的, 需要手动创建</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo new page tags<br>$ hexo new page categories<br>$ hexo new page about<br>$ hexo new page friends<br></code></pre></td></tr></table></figure></li><li><p>搜索</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.json</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">posts</span><br>  <span class="hljs-attr">searchContent:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2019/12/24/blog-hexo/"/>
    <url>/2019/12/24/blog-hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="一-nodejs"><a href="#一-nodejs" class="headerlink" title="一 : nodejs"></a>一 : nodejs</h2><ul><li><p>官网 : <a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p></li><li><p>下载地址 : <a href="https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi">https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi</a> (长期维护版即可)</p></li><li><p>安装完成后 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看node版本</span><br>$ node -v<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-npm"><a href="#二-npm" class="headerlink" title="二 : npm"></a>二 : npm</h2><ul><li><p><code>node.js</code> 自带 <code>npm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看npm版本</span><br>$ npm -v<br></code></pre></td></tr></table></figure></li><li><p><code>npm</code> 有时候不是特别好用, 可以使用 <code>cnpm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></li><li><p>安装过程中可能会出现无法加载文件的问题, 解决方案如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以管理员身份运行powerShell</span><br>PS D:\Blog&gt; set-ExecutionPolicy RemoteSigned<br><br>执行策略更改<br>执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170<br>中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?<br>[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): A<br>PS D:\fore\jshERP-web&gt; get-ExecutionPolicy<br>RemoteSigned<br></code></pre></td></tr></table></figure></li><li><p>查看版本信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cnpm -v<br></code></pre></td></tr></table></figure></li></ul><h2 id="三-hexo"><a href="#三-hexo" class="headerlink" title="三 : hexo"></a>三 : hexo</h2><ul><li><p>使用 npm 安装 hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># npm和cnpm哪个好使用哪个</span><br>$ cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># init : Create a new Hexo folder</span><br>$ hexo init<br></code></pre></td></tr></table></figure></li><li><p>生成工具栏</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo new page tags <span class="hljs-comment"># 新增标签</span><br>$ hexo new page categories<span class="hljs-comment"># 新增分类</span><br></code></pre></td></tr></table></figure></li><li><p>新写文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new <span class="hljs-string">&quot;文章题目&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p>本地启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo server<br>$ hexo s<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo generate<br>$ hexo g<br></code></pre></td></tr></table></figure></li></ul><h2 id="四-github"><a href="#四-github" class="headerlink" title="四 : github"></a>四 : github</h2><ul><li><p>创建仓库, 这里只需要注意 <code>repository name</code> 的值为 : <code> 用户名.github.io</code></p></li><li><p>通过 <code>Settings</code> 查看 <code>Pages</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Your site is live at https://info4z.github.io/<span class="hljs-comment"># 这就是个人博客的地址</span><br></code></pre></td></tr></table></figure></li><li><p>编辑 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:info4z/info4z.github.io.git</span> <span class="hljs-comment"># 用ssh连接</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p>安装 git 部署插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>执行如下指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 清除缓存文件db.json和已生成的静态文件public</span><br>$ hexo clean   <br><span class="hljs-comment"># 生成网站静态文件到默认设置的public文件夹(generate)</span><br>$ hexo g<br><span class="hljs-comment"># 自动生成网站静态文件,并部署到设定的仓库(deploy)</span><br>$ hexo d<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/24/hello-world/"/>
    <url>/2019/12/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
