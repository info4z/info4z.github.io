<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ARM架构安装RabbitMQ</title>
    <link href="/2023/04/07/ARM%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <url>/2023/04/07/ARM%E6%9E%B6%E6%9E%84%E5%AE%89%E8%A3%85RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="一、安装erlang"><a href="#一、安装erlang" class="headerlink" title="一、安装erlang"></a>一、安装erlang</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载erlang</span><br>wget https://github.com/erlang/otp/releases/download/OTP-21.3.8.21/otp_src_21.3.8.21.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>yum -y install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz glibc-devel xmlto perl gtk2-devel binutils-devel<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压erlang</span><br>tar -zxvf otp_src_21.3.8.21.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建安装目录</span><br>mkdir /usr/local/erlang<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置安装目录</span><br>./configure --prefix=/usr/local/erlang<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装</span><br>make<br>make install<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入环境变量</span><br>vim /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ERLANG_HOME</span><br>export ERLANG_HOME=/usr/local/erlang<br>export PATH=$PATH:$ERLANG_HOME/bin<br>source /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">校验</span><br>erl -version<br></code></pre></td></tr></table></figure><h2 id="二、安装socat"><a href="#二、安装socat" class="headerlink" title="二、安装socat"></a>二、安装socat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y socat<br></code></pre></td></tr></table></figure><h2 id="三、安装RabbitMQ"><a href="#三、安装RabbitMQ" class="headerlink" title="三、安装RabbitMQ"></a>三、安装RabbitMQ</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span><br>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.28/rabbitmq-server-generic-unix-3.7.28.tar.xz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>xz -d rabbitmq-server-generic-unix-3.7.28.tar.xz<br>tar -xf rabbitmq-server-generic-unix-3.7.28.tar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span><br>vim /etc/profile<br><span class="hljs-meta prompt_">#</span><span class="language-bash">RABBITMQ_HOME</span><br>export RABBITMQ_HOME=/usr/local/rabbitmq_server-3.7.28<br>export PATH=$PATH:$RABBITMQ_HOME/sbin<br>source /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动插件</span><br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><h2 id="四、操作"><a href="#四、操作" class="headerlink" title="四、操作"></a>四、操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-server           # 直接启动，如果关闭窗口或需要在该窗口使用其他命令时应用就会停止<br>rabbitmq-server -detached # 后台启动<br>rabbitmq-server start     # 启用服务<br>rabbitmq-server restart   # 重启服务<br>rabbitmqctl status        # 查看状态<br>rabbitmqctl stop          # 停止服务<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7环境搭建</title>
    <link href="/2023/03/31/0_centos7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/31/0_centos7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一-远程连接"><a href="#一-远程连接" class="headerlink" title="一 : 远程连接"></a>一 : 远程连接</h2><h3 id="一-密钥对"><a href="#一-密钥对" class="headerlink" title="(一) 密钥对"></a>(一) 密钥对</h3><p>生成密钥对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa -b 2048<br></code></pre></td></tr></table></figure><p>将公钥文件上传至服务器端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-copy-id [-p port] [user@]hostname<br></code></pre></td></tr></table></figure><p>客户端尝试登录服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh [-p port] [user@]hostname<br></code></pre></td></tr></table></figure><h3 id="二-设置新用户"><a href="#二-设置新用户" class="headerlink" title="(二) 设置新用户"></a>(二) 设置新用户</h3><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -m -s /bin/bash zhang<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd zhang<br></code></pre></td></tr></table></figure><p>sudo 授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">visudo<br>zhang ALL=(ALL) NOPASSWD: ALL<br></code></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel -r zhang<br></code></pre></td></tr></table></figure><h3 id="三-安全配置"><a href="#三-安全配置" class="headerlink" title="(三) 安全配置"></a>(三) 安全配置</h3><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>禁止root远程登录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#PermitRootLogin yes</span><br><span class="hljs-attr">PermitRootLogin</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>禁止密码登录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#PasswordAuthentication yes</span><br><span class="hljs-attr">PasswordAuthentication</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>空闲超时退出</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 间隔时间,单位:秒,建议:300~900</span><br><span class="hljs-attr">ClientAliveInterval</span> <span class="hljs-string">300</span><br><span class="hljs-comment"># 最大次数,建议:0~3</span><br><span class="hljs-attr">ClientAliveCountMax</span> <span class="hljs-string">3</span><br></code></pre></td></tr></table></figure><p>修改默认端口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许59527连接</span><br><span class="hljs-attr">Port</span> <span class="hljs-string">59527</span><br></code></pre></td></tr></table></figure><p>限制 ssh 监听 IP </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 只允许192.168.88.100连接</span><br><span class="hljs-attr">ListenAddress</span> <span class="hljs-string">192.168.88.100</span><br></code></pre></td></tr></table></figure><p>重启 sshd 生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart sshd<br></code></pre></td></tr></table></figure><h3 id="四-修改主机名"><a href="#四-修改主机名" class="headerlink" title="(四) 修改主机名"></a>(四) 修改主机名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostnamectl set-hostname app1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新登录即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查一下/etc/hosts, /etc/hostname, /etc/sysconfig/network</span><br></code></pre></td></tr></table></figure><h2 id="二-工具"><a href="#二-工具" class="headerlink" title="二 : 工具"></a>二 : 工具</h2><h3 id="一-运维工具"><a href="#一-运维工具" class="headerlink" title="(一) 运维工具"></a>(一) 运维工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install lrzsz expect mlocate unzip rsync net-tools<br></code></pre></td></tr></table></figure><h3 id="二-jdk"><a href="#二-jdk" class="headerlink" title="(二) jdk"></a>(二) jdk</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install java-1.8.0-openjdk-devel.x86_64<br>yum -y install java-11-openjdk-devel.x86_64<br></code></pre></td></tr></table></figure><h3 id="三-git"><a href="#三-git" class="headerlink" title="(三) git"></a>(三) git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.41.0.tar.gz<br>tar -xf <br>yum -y install gcc openssl openssl-devel curl curl-devel unzip perl perl-devel expat expat-devel zlib zlib-devel asciidoc xmlto gettext-devel openssh-clients<br>./configure --prefix=/usr/local/git<br>make<br>make install<br><br>vim /etc/profile<br>export PATH=/usr/local/git/bin:$PATH<br>source /etc/profile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">记住密码</span><br>git config --global credential.helper store<br></code></pre></td></tr></table></figure><h3 id="四-maven"><a href="#四-maven" class="headerlink" title="(四) maven"></a>(四) maven</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span><br>wget https://dlcdn.apache.org/maven/maven-3/3.9.1/binaries/apache-maven-3.9.1-bin.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -xf apache-maven-3.9.1-bin.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置环境变量</span><br>vim /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出maven</span><br>export MAVEN_HOME=/usr/local/maven/apache-maven-3.9.1<br>export PATH=$PATH:$MAVEN_HOME/bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新加载</span><br>source /etc/profile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vim /usr/local/maven/apache-maven-3.9.1/conf/settings.xml<br>&lt;mirror&gt;<br>    &lt;id&gt;aliyunmaven&lt;/id&gt;<br>    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;<br>    &lt;name&gt;阿里云公共仓库&lt;/name&gt;<br>    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;<br>&lt;/mirror&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新登录mvn指令会失效,</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解决方案1:在/etc/bashrc中执行重载/etc/profile</span><br>vim /etc/bashrc<br>source /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">方案2: 在/usr/bin中创建软连接</span><br>cd /usr/bin<br>ln -s /usr/local/maven/apache-maven-3.9.1/bin/mvn mvn<br></code></pre></td></tr></table></figure><h2 id="三-服务"><a href="#三-服务" class="headerlink" title="三 : 服务"></a>三 : 服务</h2><h3 id="一-MySQL8-0"><a href="#一-MySQL8-0" class="headerlink" title="(一) MySQL8.0"></a>(一) MySQL8.0</h3><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar<br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载mariadb</span><br>rpm -qa | grep mariadb<br>yum remove -y mariadb-libs-5.5.68-1.el7.x86_64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>rpm -ivh mysql-community-server-8.0.32-1.el7.x86_64.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">可能会缺个依赖, 用 yum 补一下就好</span><br>yum install -y libaio<br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认密码:启动后查看</span><br>cat /var/log/mysqld.log<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vim /etc/my.cnf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sql模式</span><br>sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大连接数</span><br>max_connections=2000<br></code></pre></td></tr></table></figure><p>初始化密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">忘记密码</span><br>vim /etc/my.cnf<br>skip-grant-tables<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启mysql</span><br>systemctl restart mysqld<br><span class="hljs-meta prompt_"># </span><span class="language-bash">置空密码</span><br>mysql<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">update mysql.user <span class="hljs-built_in">set</span> authentication_string=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消skip-grant-tables后重启</span><br>systemctl restart mysqld<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重置密码</span><br>alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;Qwer@123&#x27;;<br></code></pre></td></tr></table></figure><p>创建用户及授权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建用户</span><br>create user <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;Zhang@123&#x27;</span>;<br><span class="hljs-comment"># 授权(SELECT,INSERT,UPDATE,DELETE)</span><br>grant all on *.* to <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-comment"># 刷新权限</span><br>flush privileges;<br><span class="hljs-comment"># 校验</span><br>show grants <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span><br><span class="hljs-comment"># 移除</span><br>revoke all on *.* from <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-comment"># 修改密码,不需要重新授权</span><br>alter user <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;Zhang@123&#x27;</span>;<br><span class="hljs-comment"># 删除用户</span><br>drop user <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="二-phpmyadmin"><a href="#二-phpmyadmin" class="headerlink" title="(二) phpmyadmin"></a>(二) phpmyadmin</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://files.phpmyadmin.net/phpMyAdmin/5.2.1/phpMyAdmin-5.2.1-all-languages.zip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql_secure_installation<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置密码</span><br>Enter current password for root:# 有密码输入密码,没密码直接回车<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.默认密码过期,设置个新的</span><br>The existing password for the user account root has expired. Please set a new password.<br>New password: # 新密码<br>Re-enter new password:# 二次验证<br>The &#x27;validate_password&#x27; component is installed on the server.<br>The subsequent steps will run with the existing configuration<br>of the component.# 密码校验组件已装好,会在后续步骤中使用<br>Using existing password for root.# 使用现有密码<br>Estimated strength of the password: 100 # 预估强度<br>Change the password for root ? ((Press y|Y for Yes, any other key for No) :# 不改<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.如果密码为空,设置密码</span><br>Set root password? [Y/n] # Y<br>New password:# Qwer@123<br>Re-enter new password: # Qwer@123<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.删除匿名账户</span><br>Remove anonymous users? [Y/n] # Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.禁止root远程登录</span><br>Disallow root login remotely? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.删除<span class="hljs-built_in">test</span>测试数据库</span><br>Remove test database and access to it? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.重载权限表</span><br>Reload privilege tables now? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.然后就thx了</span><br>Thanks for using MySQL!<br></code></pre></td></tr></table></figure><h2 id="四-中间件"><a href="#四-中间件" class="headerlink" title="四 : 中间件"></a>四 : 中间件</h2><h3 id="一-Nginx"><a href="#一-Nginx" class="headerlink" title="(一) Nginx"></a>(一) Nginx</h3><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y nginx.x86_64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启stream使用tcp/udp</span><br>yum install -y nginx-mod-stream.x86_64<br></code></pre></td></tr></table></figure><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># http转https</span><br><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>xxx.xxx.xxx;<br><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><span class="hljs-comment"># https</span><br><span class="hljs-section">server</span> &#123;<br>    <br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> xxx.xxx.xxx;<br>    <br>    <span class="hljs-comment"># 关闭版本号</span><br>    <span class="hljs-attribute">server_tokens</span> <span class="hljs-literal">off</span>;<br>    <br>    <span class="hljs-comment"># ssl证书</span><br>    <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/xxx.xxx.xxx/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/xxx.xxx.xxx/privkey.pem;<br>    <br>    <span class="hljs-comment"># 定义ssl协议</span><br>    <span class="hljs-attribute">ssl_protocols</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span> TLS13-AES-<span class="hljs-number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="hljs-number">128</span>-GCM-SHA256:TLS13-AES-<span class="hljs-number">128</span>-CCM-<span class="hljs-number">8</span>-SHA256:TLS13-AES-<span class="hljs-number">128</span>-CCM-SHA256:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;<br><br><span class="hljs-comment"># 压缩配置</span><br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_min_length</span> <span class="hljs-number">1k</span>;<br>    <span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-attribute">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;<br>    <span class="hljs-attribute">gzip_vary</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_disable</span> <span class="hljs-string">&quot;MSIE [1-6]\.&quot;</span>;<br>    <br>    <span class="hljs-comment"># 最大上传10m</span><br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">10m</span>;<br>    <br>    <span class="hljs-comment"># 跟目录跳转管理端首页</span><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/$</span> /admin <span class="hljs-literal">permanent</span>;<br>    <br>    <span class="hljs-comment"># 前端静态文件</span><br>    <span class="hljs-section">location</span> /admin &#123;<br>        <span class="hljs-attribute">alias</span> /opt/web/dist;<br>    &#125;<br>    <br>    <span class="hljs-comment"># 后端接口</span><br>    <span class="hljs-section">location</span> /api/ &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:10003/;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment"># 开启stream使用tcp/udp, nacos配置为例</span><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> nacos-tcp &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.3:9858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:9858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:9868</span>;<br>    &#125;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">9848</span>;<br>        <span class="hljs-attribute">proxy_pass</span> nacos-tcp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-Redis"><a href="#二-Redis" class="headerlink" title="(二) Redis"></a>(二) Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装redis</span><br>yum install -y redis.x86_64<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vim /etc/redis.conf<br>bind 127.0.0.1 # 如果需要远程连接,注释掉这行<br>daemonize no# 如果需要后台运行,改成yes<br>requirepass 123456 # 如果需要密码认证,放开这行的注释,这里密码设为123456<br></code></pre></td></tr></table></figure><h3 id="三-RabbitMQ"><a href="#三-RabbitMQ" class="headerlink" title="(三) RabbitMQ"></a>(三) RabbitMQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载MQ</span><br>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.28/rabbitmq-server-3.7.28-1.el7.noarch.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载erlang</span><br>wget https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.8.21/erlang-21.3.8.21-1.el7.x86_64.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装erlang</span><br>rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装socat</span><br>yum install -y socat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装MQ</span><br>rpm -ivh rabbitmq-server-3.7.28-1.el7.noarch.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启web插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问 http://139.224.105.67:15672/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">账号密码: guest/guest</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载延迟插件</span><br>wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.8.0/rabbitmq_delayed_message_exchange-3.8.0.ez<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找插件位置</span><br>rpm -ql rabbitmq-server-3.7.28-1.el7.noarch | grep plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装延迟插件</span><br>cp ./rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.7.28/plugins/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">激活延迟插件</span><br>rabbitmq-plugins list<br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加用户,参数格式: username,password</span><br>rabbitmqctl add_user admin admin <br><span class="hljs-meta prompt_"># </span><span class="language-bash">为用户分配角色,参数格式: username tag</span><br>rabbitmqctl set_user_tags admin administrator <br><span class="hljs-meta prompt_"># </span><span class="language-bash">为用户分配资源权限,参数格式: -p vhost username conf wirte <span class="hljs-built_in">read</span></span><br>rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数格式: 用户名,新密码</span><br>rabbitmqctl change_password admin Admin@123<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx配置</span><br>location /rabbitmq/ &#123;<br>    port_in_redirect on;<br>    proxy_redirect off;<br>    proxy_pass http://127.0.0.1:15672/;<br>    proxy_set_header Host $http_host;<br>    proxy_set_header X-Real-IP $remote_addr;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_set_header User-Agent $http_user_agent;<br>    proxy_set_header X-Forwarded-Proto $scheme;<br>&#125;<br><br>location /rabbitmq/api/ &#123;<br>    rewrite ^ $request_uri;<br>    rewrite ^/rabbitmq/api/(.*) /api/$1 break;<br>    return 400;<br>    proxy_pass http://127.0.0.1:15672$uri;<br>    proxy_buffering off;<br>    proxy_set_header Host $http_host;<br>    proxy_set_header X-Real-IP $remote_addr;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_set_header X-Forwarded-Proto $scheme;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四-Nacos"><a href="#四-Nacos" class="headerlink" title="(四) Nacos"></a>(四) Nacos</h3><p>下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span><br>wget https://github.com/alibaba/nacos/releases/download/2.2.3/nacos-server-2.2.3.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -xf nacos-server-2.2.3.tar.gz<br></code></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim conf/application.properties<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8848</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 数据库类型</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment"># 数据库数量</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 数据库配置</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">zhang</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">Zhang@123</span><br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启鉴权</span><br><span class="hljs-attr">nacos.core.auth.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 认证白名单配置，请求头携带 key:value 即可忽略鉴权，相当于后门，应用场景少，其中 key和value不能为空</span><br><span class="hljs-attr">nacos.core.auth.server.identity.key</span>=<span class="hljs-string">nacos</span><br><span class="hljs-attr">nacos.core.auth.server.identity.value</span>=<span class="hljs-string">nacos</span><br><span class="hljs-comment">### The default token (Base64 String): Base64 在线编码解码： https://base64.us/</span><br><span class="hljs-attr">nacos.core.auth.plugin.nacos.token.secret.key</span>=<span class="hljs-string">VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=</span><br></code></pre></td></tr></table></figure><p>单机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash bin/startup.sh -m standalone<br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问 http://ip:8848/nacos</span><br></code></pre></td></tr></table></figure><p>集群配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim conf/cluster.conf<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.178.19.3:8858</span><br><span class="hljs-number">10.178.19.4:8858</span><br><span class="hljs-number">10.178.19.4:8868</span><br></code></pre></td></tr></table></figure><p>tcp配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> nacos-manager &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.3:8858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:8858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:8868</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8848</span>;<br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://nacos-manager;<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> nacos-tcp &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.3:9858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:9858</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">10.178.19.4:9868</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">9848</span>;<br>        <span class="hljs-attribute">proxy_pass</span> nacos-tcp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-Powerjob"><a href="#五-Powerjob" class="headerlink" title="(五) Powerjob"></a>(五) Powerjob</h3><p>下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载源码</span><br>wget https://github.com/PowerJob/PowerJob/archive/refs/tags/v4.0.1.zip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>unzip v4.0.1.zip<br></code></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE IF NOT EXISTS `powerjob` DEFAULT CHARSET utf8mb4;<br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">daily为默认配置文件,生产环境可以用product</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">PowerJob/powerjob-server/powerjob-server-starter/src/main/resources/application-daily.properties</span><br>vim application-daily.properties<br>spring.datasource.core.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.core.jdbc-url=jdbc:mysql://localhost:3306/powerjob?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai<br>spring.datasource.core.username=root<br>spring.datasource.core.password=root<br></code></pre></td></tr></table></figure><p>编译打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建调度服务器: powerjob-server.jar</span> <br>mvn clean package -U -Pdev -DskipTests<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jdk11需要补充几个包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">测试环境使用默认环境daily</span><br>nohup java -jar powerjob-server-starter-4.0.1.jar &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生产环境需要指定product</span><br>nohup java -jar powerjob-server-starter-4.0.1.jar --spring.profiles.active=product &amp;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以覆盖配置文件</span><br>nohup java -jar xxx.jar --spring.profiles.active=product --spring.config.location=./application-product.properties &amp;<br></code></pre></td></tr></table></figure><p>访问: <a href="http://127.0.0.1:7700/">http://127.0.0.1:7700/</a></p><h3 id="六-XXL-JOB"><a href="#六-XXL-JOB" class="headerlink" title="(六) XXL-JOB"></a>(六) XXL-JOB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载源码</span><br>wget https://github.com/xuxueli/xxl-job/archive/refs/tags/2.4.0.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>mv 2.4.0.tar.gz xxl-job-2.4.0.tar.gz<br>tar -xf xxl-job-2.4.0.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改xxl-job-admin配置文件</span><br>vim application.properties<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包</span><br>mvn clean package<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>nohup java -jar -Dserver.port=10010 -Dspring.config.location=./application.properties ./xxl-job-admin-2.4.0.jar &amp;&gt;/dev/null &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问 http://139.224.105.67:8080/xxl-job-admin/</span><br></code></pre></td></tr></table></figure><h3 id="七-Elasticsearch"><a href="#七-Elasticsearch" class="headerlink" title="(七) Elasticsearch"></a>(七) Elasticsearch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.10-x86_64.rpm<br>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.10-x86_64.rpm.sha512<br>rpm -ivh elasticsearch-7.17.10-x86_64.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载中文分词器analysis-ik</span><br>https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.17.7/elasticsearch-analysis-ik-7.17.7.zip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>unzip elasticsearch-analysis-ik-7.17.7.zip -d ik<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vi plugin-descriptor.properties<br>elasticsearch.version=7.17.10 (与安装的版本保持一致，不然无法启动)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动到es的插件中</span><br>mv ik /usr/share/elasticsearch/plugins/<br></code></pre></td></tr></table></figure><h2 id="五-未完"><a href="#五-未完" class="headerlink" title="五 : 未完"></a>五 : 未完</h2>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>centos7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch入门</title>
    <link href="/2023/03/24/elasticsearch/"/>
    <url>/2023/03/24/elasticsearch/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>官网：<a href="https://www.elastic.co/cn/elasticsearch/">https://www.elastic.co/cn/elasticsearch/</a></p><p>The Elastic Stack, 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。</p><p>Elaticsearch，简称为 ES，ES 是一个开源的高扩展的分布式全文搜索引擎，是整个 Elastic Stack 技术栈的核心。它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。</p><p>目前市面上流行的搜索引擎软件，主流的就两款：Elasticsearch 和 Solr。这两款都是基于 Lucene 搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作 修改、添加、保存、查询等等都十分类似。</p><p>选择 ES 的原因：</p><ol><li>易于使用：一个下载和一个命令就可以启动一切</li><li>分析查询：如果除了搜索文本之外还需要它来处理分析查询，ES 是更好的选择</li><li>分布式：如果需要分布式索引，则需要选择 ES 。对于需要良好可伸缩性和以及性能分布式环境，ES 是更好的选择</li><li>日志：ES 在开源日志管理用例中占据主导地位，许多组织在 ES 中索引它们的日志以使其可搜索</li><li>监控和指标：相对于 Solr，ES 暴露了更多的关键指标</li></ol><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.10-x86_64.rpm<br>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.10-x86_64.rpm.sha512<br>shasum -a 512 -c elasticsearch-7.17.12-x86_64.rpm.sha512 <br></code></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm --install elasticsearch-7.17.12-x86_64.rpm<br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable elasticsearch<br>systemctl start elasticsearch<br></code></pre></td></tr></table></figure><p>监听所有IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/elasticsearch/elasticsearch.yml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">监听地址</span><br>network.host: 0.0.0.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">单机需要加上这个</span><br>discovery.type: single-node<br></code></pre></td></tr></table></figure><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart elasticsearch<br></code></pre></td></tr></table></figure><h2 id="三、设置密码"><a href="#三、设置密码" class="headerlink" title="三、设置密码"></a>三、设置密码</h2><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/elasticsearch/elasticsearch.yml</span><br>xpack.security.enabled: true# 开启安全配置<br>discovery.type: single-node# 单机需要加上这个<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -ql elasticsearch-7.17.10-1.x86_64 | grep elasticsearch-setup-passwords<br>/usr/share/elasticsearch/bin/elasticsearch-setup-passwords interactive<br></code></pre></td></tr></table></figure><p>说明</p><table><thead><tr><th>用户</th><th>描述</th></tr></thead><tbody><tr><td>elastic</td><td>内置超级用户，权限最大</td></tr><tr><td>kibana_system</td><td>kibana连接ES,仅在kibana.yml中使用</td></tr><tr><td>apm_system</td><td>APM Server在ES中存储监控信息时使用apm_system，具有向集群中写入APM数据所需的最小权限</td></tr><tr><td>logstash_system</td><td>logstash在es中存储监控信息使用,仅在logstash配置文件中使用</td></tr><tr><td>beats_system</td><td>用户Beats在Elasticsearch中存储监控信息时使用</td></tr><tr><td>remote_monitoring_user</td><td>远程监控</td></tr></tbody></table><p>修改密码(这里用的是kibana中的开发工具窗口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">POST _security/user/elastic/_password<br>&#123;&quot;password&quot;:&quot;222222&quot;&#125;<br></code></pre></td></tr></table></figure><h2 id="四、ik分词器"><a href="#四、ik分词器" class="headerlink" title="四、ik分词器"></a>四、ik分词器</h2><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.17.7/elasticsearch-analysis-ik-7.17.7.zip<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip elasticsearch-analysis-ik-7.17.7.zip -d ik<br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi ik/plugin-descriptor.properties<br><span class="hljs-meta prompt_"># </span><span class="language-bash">与安装的版本保持一致，不然无法启动</span><br>elasticsearch.version=7.17.10<br></code></pre></td></tr></table></figure><p>移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv ik /usr/share/elasticsearch/plugins/<br></code></pre></td></tr></table></figure><h2 id="五、kibana"><a href="#五、kibana" class="headerlink" title="五、kibana"></a>五、kibana</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.17.12-x86_64.rpm<br>wget https://artifacts.elastic.co/downloads/kibana/kibana-7.17.12-x86_64.rpm.sha512<br>shasum -a 512 -c kibana-7.17.12-x86_64.rpm.sha512 <br>sudo rpm --install kibana-7.17.12-x86_64.rpm<br></code></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/kibana/kibana.yml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认端口</span><br>server.port: 5601<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ES 服务器的地址</span><br>elasticsearch.hosts: [&quot;http://localhost:9200&quot;]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">索引名</span><br>kibana.index: &quot;.kibana&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">支持中文</span><br>i18n.locale: &quot;zh-CN&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">账号/密码</span><br>elasticsearch.username: &quot;kibana_system&quot;<br>elasticsearch.password: &quot;Zhang@123&quot;<br></code></pre></td></tr></table></figure><p>明文密码不安全，可以采用 keystore 形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用keystore形式存储密码</span><br>bash kibana-keystore create<br>bash kibana-keystore add elasticsearch.password<br>systemctl restart kibana<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>全文检索</tag>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql8.0日志</title>
    <link href="/2023/03/17/mysql8.0%E6%97%A5%E5%BF%97/"/>
    <url>/2023/03/17/mysql8.0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="一-错误日志"><a href="#一-错误日志" class="headerlink" title="一 : 错误日志"></a>一 : 错误日志</h2><p>错误日志(log_error)是<strong>默认开启</strong>的, 当数据库出现任何故障导致无法正常使用时, 建议首先查看此日志 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_error%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name              <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br><span class="hljs-operator">|</span> binlog_error_action        <span class="hljs-operator">|</span> ABORT_SERVER                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error                  <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>error.log               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_services         <span class="hljs-operator">|</span> log_filter_internal; log_sink_internal <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_suppression_list <span class="hljs-operator">|</span>                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_error_verbosity        <span class="hljs-operator">|</span> <span class="hljs-number">2</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+----------------------------------------+</span><br></code></pre></td></tr></table></figure><p>该日志主要包含的信息有</p><ul><li>服务器启动和关闭过程中的信息</li><li>服务器运行过程中的错误信息</li><li>时间调度器运行一个时间时产生的信息</li><li>在从服务器上启动从服务器进程时产生的信息</li></ul><h2 id="二-普通日志"><a href="#二-普通日志" class="headerlink" title="二 : 普通日志"></a>二 : 普通日志</h2><p>普通日志(general_log)主要记录了用户的 DDL(create, drop, alter),  DQL(select) 和 DML(insert, update, delete) 语句, <strong>默认未开启</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%general_log%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+--------------------------------------------+</span><br><span class="hljs-operator">|</span> Variable_name    <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+--------------------------------------------+</span><br><span class="hljs-operator">|</span> general_log      <span class="hljs-operator">|</span> OFF                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> general_log_file <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>iv<span class="hljs-operator">-</span>ycco47wj7w7grb1bc17k.log <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------------+--------------------------------------------+</span><br><br><span class="hljs-comment">-- 输出方式: file(文件),table(表)</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_output%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> log_output    <span class="hljs-operator">|</span> FILE  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br></code></pre></td></tr></table></figure><h3 id="一-临时开启"><a href="#一-临时开启" class="headerlink" title="(一) 临时开启"></a>(一) 临时开启</h3><p>设置全局变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 日志记录功能: on(开启),off(关闭)</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br><span class="hljs-comment">-- 文件位置</span><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;/var/log/mysql/general.log&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="二-永久开启"><a href="#二-永久开启" class="headerlink" title="(二) 永久开启"></a>(二) 永久开启</h3><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/my.cnf</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启查询日志: 1(开启), 0(关闭)</span><br>general_log=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置日志文件名, 默认文件名问hostname.log</span><br>general_log_file=/var/log/mysql/general.log<br></code></pre></td></tr></table></figure><p>重启mysql服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart mysqld</span><br></code></pre></td></tr></table></figure><h2 id="三-慢查询日志"><a href="#三-慢查询日志" class="headerlink" title="三 : 慢查询日志"></a>三 : 慢查询日志</h2><p>慢查询日志(slow_query_log)记录所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志, <strong>默认未开启</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+----------------------------+</span><br><span class="hljs-operator">|</span> Variable_name       <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>                      <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+----------------------------+</span><br><span class="hljs-operator">|</span> slow_query_log      <span class="hljs-operator">|</span> OFF                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> slow_query_log_file <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>vm<span class="hljs-operator">-</span>slow.log <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+----------------------------+</span><br></code></pre></td></tr></table></figure><p>long_query_time 默认值为 10s, 最小值为 0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%long_query_time%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-----------+</span><br><span class="hljs-operator">|</span> Variable_name   <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-----------+</span><br><span class="hljs-operator">|</span> long_query_time <span class="hljs-operator">|</span> <span class="hljs-number">10.000000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-----------+</span><br></code></pre></td></tr></table></figure><h3 id="一-临时开启-1"><a href="#一-临时开启-1" class="headerlink" title="(一) 临时开启"></a>(一) 临时开启</h3><p>设置全局变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log_file<span class="hljs-operator">=</span><span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>slow.log;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="二-永久开启-1"><a href="#二-永久开启-1" class="headerlink" title="(二) 永久开启"></a>(二) 永久开启</h3><p>开启慢查询日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/my.cnf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启慢查询日志</span><br>slow_query_log=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询时长参数</span><br>long_query_time=2<br></code></pre></td></tr></table></figure><p>重启mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart mysql</span><br></code></pre></td></tr></table></figure><h2 id="四-二进制日志"><a href="#四-二进制日志" class="headerlink" title="四 : 二进制日志"></a>四 : 二进制日志</h2><p>二进制日志(log_bin)记录了所有 DDL 语句和 DML, 但是不包括数据查询(select, show), 默认<strong>开启</strong>; 可用于灾难时的数据恢复和主从复制</p><p>查看默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+-----------------------------+</span><br><span class="hljs-operator">|</span> Variable_name                   <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+-----------------------------+</span><br><span class="hljs-operator">|</span> log_bin                         <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span>                          <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> log_bin_basename                <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog       <span class="hljs-operator">|</span><span class="hljs-comment">-- 日志文件</span><br><span class="hljs-operator">|</span> log_bin_index                   <span class="hljs-operator">|</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>binlog.index <span class="hljs-operator">|</span><span class="hljs-comment">-- 日志索引</span><br><span class="hljs-operator">|</span> log_bin_trust_function_creators <span class="hljs-operator">|</span> OFF                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> log_bin_use_v1_row_events       <span class="hljs-operator">|</span> OFF                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> sql_log_bin                     <span class="hljs-operator">|</span> <span class="hljs-keyword">ON</span>                          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+-----------------------------+</span><br></code></pre></td></tr></table></figure><p>日志格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%binlog_format%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> binlog_format <span class="hljs-operator">|</span> <span class="hljs-type">ROW</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br></code></pre></td></tr></table></figure><h3 id="一-日志查看"><a href="#一-日志查看" class="headerlink" title="(一) 日志查看"></a>(一) 日志查看</h3><p>二进制文件不能直接读取, 需要通过 <code>mysqlbinlog</code> 命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [option] filename<br>option:<br>-d: 指定数据库名称, 只列出指定数据库相关操作<br>-o: 忽略掉日志中的前n行指令<br>-v: 将事件(数据变更)重构为SQL<br>-w: 将事件(数据变更)重构为SQL语句并输出注释<br></code></pre></td></tr></table></figure><h3 id="二-日志还原"><a href="#二-日志还原" class="headerlink" title="(二) 日志还原"></a>(二) 日志还原</h3><p>命令操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [option] filename | mysql -uroot -proot<br>option:<br>--start-datetime: 恢复数据的起始时间<br>--stop-datatime: 恢复数据的结束时间<br>--start-position: 恢复数据的开始位置<br>--stop-position: 恢复数据的结束位置<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JumpServer入门</title>
    <link href="/2023/03/10/JumpServer%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/10/JumpServer%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>JumpServer 是广受欢迎的开源堡垒机，是符合 4A 规范的专业运维安全审计系统。</p><p>JumpServer 的产品特色包括：</p><ul><li>开源：零门槛，线上快速获取和安装；</li><li>分布式：轻松支持大规模并发访问；</li><li>无插件：仅需浏览器，极致的 Web Terminal 使用体验；</li><li>多云支持：一套系统，同时管理不同云上面的资产；</li><li>云端存储：审计录像云端存储，永不丢失；</li><li>多租户：一套系统，多个子公司和部门同时使用；</li><li>多应用支持：数据库，Windows 远程应用，Kubernetes。</li></ul><h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二 : 安装"></a>二 : 安装</h2><p>在线安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入/opt</span><br>[root@localhost ~]# cd /opt/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载安装</span><br>[root@localhost opt]# curl -sSL https://resource.fit2cloud.com/jumpserver/jumpserver/releases/latest/download/quick_start.sh | bash<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; The Installation is Complete</span><br>For more commands, you can enter jmsctl --help to view help information.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同时可以看到以下文件</span><br>[root@localhost opt]# ll<br>total 0<br>drwx--x--x. 4 root root  28 Mar 20 15:22 containerd<br>drwx------. 3 root root  20 Mar 20 15:22 jumpserver<br>drwxr-xr-x. 8 root root 267 Mar 20 15:22 jumpserver-installer-v3.1.0<br></code></pre></td></tr></table></figure><p>控制命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/jumpserver-installer-v3.1.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>./jmsctl.sh start<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>./jmsctl.sh down<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>./jmsctl.sh uninstall<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助</span><br>./jmsctl.sh -h<br></code></pre></td></tr></table></figure><p>配置文件路径为 : <code>/opt/jumpserver/config/config.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mysql</span><br>DB_HOST=mysql<br>DB_PORT=3306<br>DB_USER=root<br>DB_PASSWORD=MzA1MTRkNTYtYWY3Mi1kMTQ1LT<br>DB_NAME=jumpserver<br><span class="hljs-meta prompt_"># </span><span class="language-bash">redis</span><br>REDIS_HOST=redis<br>REDIS_PORT=6379<br>REDIS_PASSWORD=MzA1MTRkNTYtYWY3Mi1kMTQ1LT<br></code></pre></td></tr></table></figure><p>环境访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">地址:</span> <span class="hljs-string">http://&lt;JumpServer服务器IP地址&gt;:&lt;服务运行端口&gt;</span><br><span class="hljs-string">用户名:</span> <span class="hljs-string">admin</span><br><span class="hljs-string">密码:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><h2 id="三-使用"><a href="#三-使用" class="headerlink" title="三 : 使用"></a>三 : 使用</h2><h3 id="一-用户管理"><a href="#一-用户管理" class="headerlink" title="(一) 用户管理"></a>(一) 用户管理</h3><p>创建用户 : 添加 dev(开发), star(运维), test(测试); 系统角色 &#x3D;&gt; 用户</p><p>创建用户组 : 这个就不多说了, 很简单</p><h3 id="二-资产管理"><a href="#二-资产管理" class="headerlink" title="(二) 资产管理"></a>(二) 资产管理</h3><ol><li>资产列表</li><li>在资产树下面创建节点</li><li>点击创建 </li><li>选择主机 : Linux </li><li>基本内容 : 名称命名规范 <code>$&#123;IP&#125;-$&#123;服务器名称&#125;</code> </li><li>账号 : 添加用于认证的账号密码(尽量不要使用特权账号)</li></ol><h3 id="三-权限管理"><a href="#三-权限管理" class="headerlink" title="(三) 权限管理"></a>(三) 权限管理</h3><ol><li>资产授权</li><li>创建</li><li>基本 : 授权名称(例如: 运维人员授权)</li><li>用户 : 可以选择某个用户或者是某个用户组</li><li>资产 : 可以选择某个资产或者某个节点</li><li>账号 : 尽量不要选择同名账号, 避免新手混淆</li><li>权限 : 按需求授权即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳板机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql8.0修改密码</title>
    <link href="/2023/03/03/mysql8.0%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <url>/2023/03/03/mysql8.0%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-使用命令-推荐"><a href="#一-使用命令-推荐" class="headerlink" title="一 : 使用命令(推荐)"></a>一 : 使用命令(推荐)</h2><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql_secure_installation<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置密码</span><br>Enter current password for root:# 有密码输入密码,没密码直接回车<br></code></pre></td></tr></table></figure><p>如果是新装的mysql，默认密码是过期的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.默认密码过期,设置个新的</span><br>The existing password for the user account root has expired. Please set a new password.<br>New password: # 新密码<br>Re-enter new password:# 二次验证<br>The &#x27;validate_password&#x27; component is installed on the server.<br>The subsequent steps will run with the existing configuration<br>of the component.# 密码校验组件已装好,会在后续步骤中使用<br>Using existing password for root.# 使用现有密码<br>Estimated strength of the password: 100 # 预估强度<br>Change the password for root ? ((Press y|Y for Yes, any other key for No) :# n,不改<br></code></pre></td></tr></table></figure><p>如果密码是空的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2.如果密码为空,设置密码</span><br>Set root password? [Y/n] # Y<br>New password:# Qwer@123<br>Re-enter new password: # Qwer@123<br></code></pre></td></tr></table></figure><p>安全设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">3.删除匿名账户</span><br>Remove anonymous users? [Y/n] # Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.禁止root远程登录</span><br>Disallow root login remotely? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.删除<span class="hljs-built_in">test</span>测试数据库</span><br>Remove test database and access to it? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.重载权限表</span><br>Reload privilege tables now? [Y/n]# Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.然后就thx了</span><br>Thanks for using MySQL!<br></code></pre></td></tr></table></figure><h2 id="二-暴力手段"><a href="#二-暴力手段" class="headerlink" title="二 : 暴力手段"></a>二 : 暴力手段</h2><p>跳过密码校验，编辑 <code>/etc/my.cnf</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 插入一行, 跳过授权表</span><br><span class="hljs-attr">skip-grant-tables</span><br></code></pre></td></tr></table></figure><p>重启后登录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 重启mysql</span><br>$ systemctl restart mysqld<br><span class="hljs-comment"># 登录</span><br>$ mysql -uroot -p<br></code></pre></td></tr></table></figure><p>置空密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> mysql.user <span class="hljs-keyword">set</span> authentication_string<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>取消跳过授权</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 其实也没啥必要删,注释掉即可</span><br><span class="hljs-comment"># skip-grant-tables</span><br></code></pre></td></tr></table></figure><p>重启后登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart mysqld</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -uroot -p</span><br></code></pre></td></tr></table></figure><p>重置密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 重置密码, mysql8.0开始需要符合密码安全规范</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;Qwer@123&#x27;</span>;<br><br><span class="hljs-comment">-- 如果需要设置简单的,修改一下密码校验规则即可</span><br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;validate_password%&#x27;</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password.check_user_name <span class="hljs-operator">=</span> OFF;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password.length <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password.policy <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- 然后再设置就成功了</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="三-普通账户"><a href="#三-普通账户" class="headerlink" title="三 : 普通账户"></a>三 : 普通账户</h2><p>创建普通账户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 指定加密规则,不然navicat会报错</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;Zhang@123&#x27;</span>;<br><span class="hljs-comment">-- 最好检查一下加密规则是否符合预期</span><br><span class="hljs-keyword">select</span> Host,<span class="hljs-keyword">user</span>,authentication_string,password_expired,plugin <span class="hljs-keyword">from</span> mysql.user;<br><span class="hljs-comment">-- 给普通账户授权</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-comment">-- 刷新权限</span><br>flush privileges;<br></code></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemctl的应用</title>
    <link href="/2023/02/24/systemctl%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/02/24/systemctl%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>systemctl 是 linux 系统继 init.d 之后的一个 systemd 工具, 主要负责控制 systemd 系统和管理系统服务。</p><p>systemd 即为 system daemon(系统守护进程), 是 linux 下的一种 init 软件。</p><p>Systemd 可以管理所有系统资源, 将<strong>系统资源</strong>划分为12类; 将每个系统资源称为一个 <strong>Unit</strong>; 12类包括 : Service、Target、Device等, 其中 <code>.service</code> 是最常见的单元文件。</p><p>以 nginx.service 文件为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=The nginx HTTP and reverse proxy server<br>After=network-online.target remote-fs.target nss-lookup.target<br>Wants=network-online.target<br><br>[Service]<br>Type=forking<br>PIDFile=/run/nginx.pid<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Nginx will fail to start <span class="hljs-keyword">if</span> /run/nginx.pid already exists but has the wrong</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">SELinux context. This might happen when running `nginx -t` from the cmdline.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">https://bugzilla.redhat.com/show_bug.cgi?<span class="hljs-built_in">id</span>=1268621</span><br>ExecStartPre=/usr/bin/rm -f /run/nginx.pid<br>ExecStartPre=/usr/sbin/nginx -t<br>ExecStart=/usr/sbin/nginx<br>ExecReload=/usr/sbin/nginx -s reload<br>KillSignal=SIGQUIT<br>TimeoutStopSec=5<br>KillMode=process<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>Unit 是 Systemd 管理系统资源的基本单位。使用一个 Unit File 作为 Unit 的单元文件, Systemd 通过单元文件控制 Unit 的启动。</p><h2 id="二-常用命令"><a href="#二-常用命令" class="headerlink" title="二 : 常用命令"></a>二 : 常用命令</h2><p>systemctl 可以管理服务, 也就是说可以启动服务, 查看服务状态, 停止服务, 重启服务等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示状态单元</span><br>systemctl status xxx.service  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动服务单元</span><br>systemctl start xxx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止服务单元</span><br>systemctl stop xxx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务单元</span><br>systemctl restart xxx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启</span><br>systemctl enable xxx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消开机自启</span><br>systemctl disable xxx.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Reload systemd manager configuration(重新载入systemd),扫描新的或有变动的单元</span><br>systemctl daemon-reload<br></code></pre></td></tr></table></figure><h2 id="三-service文件"><a href="#三-service文件" class="headerlink" title="三 : service文件"></a>三 : service文件</h2><p>有时我们将自定义程序注册为systemd service(服务进程管理), 交由系统管理, 可以方便启动停止, 也可以实现服务异常退出重启, 开机自启动, 减少自定义程序服务管理的时间消耗。</p><p>服务分为系统服务和用户服务, 系统服务开机不登陆就能运行, 常用于开机自启。</p><ul><li><strong>系统服务目录 :</strong> <code>/usr/lib/systemd/system/</code></li><li><strong>用户服务目录 :</strong> <code>/usr/lib/systemd/user/</code></li></ul><p>每一个服务以 .service 结尾, 一般会分为3部分: [Unit]、[Service] 和 [Install]</p><h3 id="一-Unit"><a href="#一-Unit" class="headerlink" title="(一) Unit"></a>(一) Unit</h3><p>所有 Unit 文件通用, 该部分主要是对这个服务的说明, 以及配置与其他服务的关系</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>Description</strong></td><td>一段描述这个Unit文件的文字, 通常只是简短的一句话</td></tr><tr><td>Documentation</td><td>指定服务单元的文档, 可以是一个或多个文档的URL路径</td></tr><tr><td>Requires</td><td>依赖的Unit列表,  该Unit会在目标服务单元启动的同时被启动, 如果有任意一个启动失败, 目标单元也会被终止</td></tr><tr><td><strong>After</strong></td><td>当列出的所有单元启动完成后, 才会启动目标服务单元</td></tr><tr><td>Before</td><td>在启动指定的每个单元之前, 都会首先确保目标服务单元已经运行, 与After相反</td></tr><tr><td>Wants</td><td>目标Unit启动的同时, 启动列出的每个Unit, 不会关注启动是否成功</td></tr><tr><td>Conflicts</td><td>与目标单元有冲突的单元, 如果列出单元中有已经在运行的, 那么目标单元就不能启动</td></tr><tr><td>OnFailure</td><td>当目标单元启动失败时, 就自动启动列出的每个单元</td></tr><tr><td>PartOf</td><td>该参数仅作用于单元的停止或重启; 当停止或重启这里列出的某个单元时,  也会同时停止或重启目标单元</td></tr><tr><td>@</td><td>动态启动方式配置, @之后加载具体配置文件的名字</td></tr></tbody></table><p>重要说明 : </p><ol><li><code>Before=</code>, <code>After=</code> 是配置服务间的启动顺序, 比如一个 a.service 包含了一行 <code>Before=b.service</code>, 那么当他们同时启动时, b.service 会等待 a.service 启动完成后才启动; 注意这个设置和 <code>Requires=</code> 的相互独立的, 同时包含 <code>After=</code> 和 <code>Requires=</code> 也是常见的; 此选项可以指定多次, 然后按顺序全部启动。</li><li><code>PartOf=</code>, 这个依赖是单向的,  该单元自身的停止或重启并不影响这里列出的单元; 如果 a.service 中包含了 <code>PartOf=b.service</code> , 那么这个依赖关系将在 b.service 的属性列表中显示为 <code>ConsistsOf=a.service</code>; 也就是说, 不能直接设置 <code>ConsistsOf=</code> 依赖。</li><li><code>@</code>, 这个参数不是写在配置文件内容中的, 而是写在配置文件名字上的, 例如我们启动openvpn服务会编写 <code>openvpn@.service</code> 文件, 客户端的配置文件为 <code>/etc/openvpn/client.conf</code>, 服务端配置文件为 <code>/etc/openvpn/server.conf</code>, 对应启动时则应该使用 <code>openvpn@client.service</code> 和 <code>openvpn@server.service</code>, 同时在内容中使用 <code>%i</code> 对 <code>@</code> 之后的内容进行接收。</li></ol><h3 id="二-Service"><a href="#二-Service" class="headerlink" title="(二) Service"></a>(二) Service</h3><p>Service 段是服务(Service)类型的 Unit 文件(后缀为 .service)特有的, 用于定义服务的具体管理和执行动作</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>Type</strong></td><td>设置进程的启动类型, 必须设为 simple, exec, forking, oneshot, dbus, notify, idle 之一, 默认的 simple 类型可以适应于绝大多数的场景, 因此一般可以忽略这个参数的配置; 而如果服务程序启动后会通过 fork 系统调用创建子进程, 然后关闭应用程序本身进程的情况, 则应该将 Type 的值设置为 forking, 否则 systemd 将不会跟踪子进程的行为, 而认为服务已经退出</td></tr><tr><td>Environment</td><td>为服务添加环境变量</td></tr><tr><td>EnvironmentFile</td><td>指定加载一个包含服务所需的环境参数的文件, 文件中的每一行都是一个环境变量的定义</td></tr><tr><td><strong>ExecStart</strong></td><td>这个参数是几乎每个 .service 文件都会有的, 指定服务启动的主要命令, 在每个配置文件中只能使用一次; <strong>需要使用绝对路径</strong></td></tr><tr><td>ExecStartPre</td><td>指定在启动执行 ExecStart 的命令前的准备工作, 可以有多个, 所有命令会按照文件中书写的顺序依次被执行</td></tr><tr><td>ExecStartPost</td><td>指定在启动执行 ExecStart 的命令后的收尾工作, 也可以有多个</td></tr><tr><td><strong>ExecStop</strong></td><td>停止服务所需要执行的主要命令; <strong>需要使用绝对路径</strong></td></tr><tr><td>ExecStopPost</td><td>指定在 ExecStop 命令执行后的收尾工作, 也可以有多个</td></tr><tr><td><strong>ExecReload</strong></td><td>重新加载服务文件所需执行的主要命令; <strong>需要使用绝对路径</strong></td></tr><tr><td><strong>Restart</strong></td><td>指定在什么情况下需要重启服务进程</td></tr><tr><td>RestartSec</td><td>如果服务需要被重启, 这个参数的值为服务被重启前的等待秒数。注意, 该重启等待时间只针对上面Restart的参数值起作用时的重启才有效, 比如说: 因Unit段配置的关系或者人为使用 <code>systemctl restart</code> 命令导致该服务重启时, 该参数无效, 会马上重启</td></tr><tr><td>Nice</td><td>服务的进程优先级, 值越小优先级越高, 默认为0; -20为最高优先级, 19为最低优先级。</td></tr><tr><td>WorkingDirectory</td><td>指定服务的工作目录。</td></tr><tr><td>RootDirectory</td><td>指定服务进程的根目录( &#x2F; 目录), 如果配置了这个参数后, 服务将无法访问指定目录以外的任何文件。</td></tr><tr><td><strong>User</strong></td><td>指定运行服务的用户, 会影响服务对本地文件系统的访问权限。可使用root</td></tr><tr><td>Group</td><td>指定运行服务的用户组, 会影响服务对本地文件系统的访问权限。</td></tr><tr><td>PrivateTmp</td><td>是否给服务分配独立的临时空间(true&#x2F;false)</td></tr></tbody></table><p><strong>Restart</strong> 的取值分别表示了在哪些情况下, 服务会被重新启动</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td><strong>默认值</strong>, 退出后不会重启</td></tr><tr><td><strong>always</strong></td><td>除了用 systemctl stop 或等价的服务停止操作命令, 其他情况都可以重启</td></tr><tr><td>on-success</td><td>只有正常退出时(退出状态码为0), 才会重启</td></tr><tr><td>on-failure</td><td>非正常退出时(退出状态码非0), 包括被信号终止和超时, 才会重启(守护进程, 推荐值)</td></tr><tr><td>on-abnormal</td><td>只有被信号终止和超时, 才会重启(对于允许发生错误退出的服务, 推荐值)</td></tr><tr><td>on-abort</td><td>只有在收到没有捕捉到的信号终止时, 才会重启</td></tr><tr><td>on-watchdog</td><td>超时退出, 才会重启</td></tr></tbody></table><p>具体情况如下</p><table><thead><tr><th>参数</th><th>正常退出</th><th>退出码不为0</th><th>进程被强制杀死</th><th>systemd 操作</th><th>看门狗超时</th></tr></thead><tbody><tr><td>no</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>always</td><td>重启</td><td>重启</td><td>重启</td><td>重启</td><td>重启</td></tr><tr><td>on-success</td><td>重启</td><td></td><td></td><td></td><td></td></tr><tr><td>on-failure</td><td></td><td>重启</td><td>重启</td><td>重启</td><td>重启</td></tr><tr><td>on-abnormal</td><td></td><td></td><td>重启</td><td>重启</td><td>重启</td></tr><tr><td>on-abort</td><td></td><td></td><td>重启</td><td></td><td></td></tr><tr><td>on-watchdog</td><td></td><td></td><td></td><td></td><td>重启</td></tr></tbody></table><h3 id="三-Install"><a href="#三-Install" class="headerlink" title="(三) Install"></a>(三) Install</h3><p>Install段是服务的安装信息, 它不在 systemd 的运行期间使用, 只在使用 <code>systemctl enable</code> 和 <code>systemctl disable</code> 命令启用&#x2F;禁用服务时有用, 所有 Unit 文件通用, 用来定义如何启动以及是否开机启动</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>WantedBy</strong></td><td>它的值是一个或多个target, 执行enable命令时, 符号链接会放入 <code>/etc/systemd/system</code> 目录下以 <code>target 名 + .wants</code> 后缀构成的子目录中。<code>WantedBy=multi-user.target</code> 表明当系统以多用户方式（默认的运行级别）启动时, 这个服务需要被自动运行。当然还需要 <strong>systemctl enable</strong> 激活这个服务以后自动运行才会生效</td></tr><tr><td>RequiredBy</td><td>依赖当前服务的模块。它的值是一个或多个 target, 执行enable命令时, 符号链接会放入&#x2F;etc&#x2F;systemd&#x2F;system目录下以 target 名 + .required后缀构成的子目录中</td></tr><tr><td>Alias</td><td>当前 Unit 可用于启动的别名</td></tr><tr><td>Also</td><td>当前 Unit 被 enable&#x2F;disable 时, 会被同时操作的其他 Unit</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu环境搭建</title>
    <link href="/2023/02/17/ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/02/17/ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一-远程连接"><a href="#一-远程连接" class="headerlink" title="一 : 远程连接"></a>一 : 远程连接</h2><h3 id="一-密钥对"><a href="#一-密钥对" class="headerlink" title="(一) 密钥对"></a>(一) 密钥对</h3><p>生成密钥对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ssh-keygen -t rsa -b 2048<br></code></pre></td></tr></table></figure><p>将公钥文件上传至服务器端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ssh-copy-id [-p port] [user@]hostname<br></code></pre></td></tr></table></figure><p>客户端尝试登录服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ssh [-p port] [user@]hostname<br></code></pre></td></tr></table></figure><h3 id="二-设置新用户"><a href="#二-设置新用户" class="headerlink" title="(二) 设置新用户"></a>(二) 设置新用户</h3><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">useradd -m -s /bin/bash zhang</span><br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">passwd zhang</span><br></code></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">userdel -r zhang</span><br></code></pre></td></tr></table></figure><p>sudo 授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">visudo</span><br>zhang ALL=(ALL) NOPASSWD:ALL<br></code></pre></td></tr></table></figure><h3 id="三-安全配置"><a href="#三-安全配置" class="headerlink" title="(三) 安全配置"></a>(三) 安全配置</h3><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>禁止root远程登录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#PermitRootLogin yes</span><br><span class="hljs-attr">PermitRootLogin</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>禁止密码登录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#PasswordAuthentication yes</span><br><span class="hljs-attr">PasswordAuthentication</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>空闲超时退出</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 间隔时间,单位:秒,建议:300~900</span><br><span class="hljs-attr">ClientAliveInterval</span> <span class="hljs-string">300</span><br><span class="hljs-comment"># 最大次数,建议:0~3</span><br><span class="hljs-attr">ClientAliveCountMax</span> <span class="hljs-string">3</span><br></code></pre></td></tr></table></figure><p>修改默认端口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Port 22</span><br><span class="hljs-attr">Port</span> <span class="hljs-string">59527</span><br></code></pre></td></tr></table></figure><p>限制 ssh 监听 IP </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#ListenAddress 0.0.0.0</span><br><span class="hljs-attr">ListenAddress</span> <span class="hljs-string">192.168.88.100</span><br><span class="hljs-comment"># 只能通过192.168.88.100连接这台服务器</span><br></code></pre></td></tr></table></figure><p>重启 sshd 生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart sshd<br></code></pre></td></tr></table></figure><h2 id="二-常用工具"><a href="#二-常用工具" class="headerlink" title="二 : 常用工具"></a>二 : 常用工具</h2><h3 id="一-管理工具"><a href="#一-管理工具" class="headerlink" title="(一) 管理工具"></a>(一) 管理工具</h3><p>lrzsz : 上传下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y lrzsz</span><br></code></pre></td></tr></table></figure><p>unzip : 解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y unzip</span><br></code></pre></td></tr></table></figure><p>rsync : 文件同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y rsync</span><br></code></pre></td></tr></table></figure><p>expect : 交互式脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y expect</span><br></code></pre></td></tr></table></figure><h3 id="二-开发工具"><a href="#二-开发工具" class="headerlink" title="(二) 开发工具"></a>(二) 开发工具</h3><p>openjdk</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo apt install -y openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y git</span><br></code></pre></td></tr></table></figure><p>maven : 项目管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y maven</span><br></code></pre></td></tr></table></figure><h2 id="三-中间件"><a href="#三-中间件" class="headerlink" title="三 : 中间件"></a>三 : 中间件</h2><h3 id="一-Nginx"><a href="#一-Nginx" class="headerlink" title="(一) Nginx"></a>(一) Nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y nginx</span><br></code></pre></td></tr></table></figure><h3 id="二-Redis"><a href="#二-Redis" class="headerlink" title="(二) Redis"></a>(二) Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装redis</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y redis-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vim /etc/redis/redis.conf<br>bind 127.0.0.1 # 如果需要远程连接,注释掉这行<br>daemonize no# 如果需要后台运行,改成yes<br>requirepass 123456 # 如果需要密码认证,放开这行的注释,这里密码设为123456<br></code></pre></td></tr></table></figure><h3 id="三-RabbitMQ"><a href="#三-RabbitMQ" class="headerlink" title="(三) RabbitMQ"></a>(三) RabbitMQ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装rabbit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install -y rabbitmq-server</span><br></code></pre></td></tr></table></figure><h2 id="四-数据库"><a href="#四-数据库" class="headerlink" title="四 : 数据库"></a>四 : 数据库</h2><h3 id="一-MySQL"><a href="#一-MySQL" class="headerlink" title="(一) MySQL"></a>(一) MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>$ sudo apt install -y mysql-server<br><br><span class="hljs-comment"># 修改密码</span><br>mysql&gt; alter user <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified with caching_sha2_password by <span class="hljs-string">&#x27;root&#x27;</span>;<br><br><span class="hljs-comment"># 新建账号,如果需要远程连接要用mysql_native_password,不然navicat会报错</span><br>mysql&gt; create user <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;Zhang@123&#x27;</span>;<br><br><span class="hljs-comment"># 授权</span><br>mysql&gt; grant all on *.* to <span class="hljs-string">&#x27;zhang&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="五-其他"><a href="#五-其他" class="headerlink" title="五 : 其他"></a>五 : 其他</h2><h3 id="一-phpmyadmin"><a href="#一-phpmyadmin" class="headerlink" title="(一) phpmyadmin"></a>(一) phpmyadmin</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo apt install -y phpmyadmin<br></code></pre></td></tr></table></figure><h3 id="二-certbot"><a href="#二-certbot" class="headerlink" title="(二) certbot"></a>(二) certbot</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>$ sudo apt install -y certbot<br><span class="hljs-comment"># 申请证书</span><br>$ certbot certonly<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Let&#39;s Encrypt</title>
    <link href="/2023/02/10/Let&#39;s%20Encrypt/"/>
    <url>/2023/02/10/Let&#39;s%20Encrypt/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p><code>certbot</code> 是Let’s Encrypt官方推荐的获取证书的客户端，可以帮我们获取免费的Let’s Encrypt 证书。</p><p><code>certbot</code> 支持所有  Unix 内核的操作系统。</p><h2 id="二-安装使用"><a href="#二-安装使用" class="headerlink" title="二 : 安装使用"></a>二 : 安装使用</h2><p>使用 yum 安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">yum install -y certbot</span><br></code></pre></td></tr></table></figure><h2 id="三-申请证书"><a href="#三-申请证书" class="headerlink" title="三 : 申请证书"></a>三 : 申请证书</h2><p>申请证书之前要确保 443 端口没有被占用, 记得关掉 nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">certbot certonly</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.standalone按1回车,webroot按2回车</span><br>Select the appropriate number [1-2] then [enter] (press &#x27;c&#x27; to cancel): 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.输入联系邮箱</span><br>Enter email address (used for urgent renewal and security notices)<br> (Enter &#x27;c&#x27; to cancel): xxx@xxx.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.读一下声明,是否同意</span><br>(Y)es/(N)o: Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.是否分享</span><br>(Y)es/(N)o: Y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.输入域名</span><br>Please enter the domain name(s) you would like on your certificate (comma and/or<br>space separated) (Enter &#x27;c&#x27; to cancel): www.info4z.com<br></code></pre></td></tr></table></figure><p>完毕后可以看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Successfully received certificate.<br>Certificate is saved at: /etc/letsencrypt/live/www.info4z.com/fullchain.pem<br>Key is saved at:         /etc/letsencrypt/live/www.info4z.com/privkey.pem<br></code></pre></td></tr></table></figure><h2 id="四-编辑nignx配置文件"><a href="#四-编辑nignx配置文件" class="headerlink" title="四 : 编辑nignx配置文件"></a>四 : 编辑nignx配置文件</h2><p>编辑对应的 nginx 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">vim /etc/nginx/conf.d/www.info4z.com.conf</span><br></code></pre></td></tr></table></figure><p>替换新的证书</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> www.<span class="hljs-literal">info</span>4z.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span>      /etc/letsencrypt/live/www.<span class="hljs-literal">info</span>4z.com/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>  /etc/letsencrypt/live/www.<span class="hljs-literal">info</span>4z.com/privkey.pem;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置http转换https</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>www.<span class="hljs-literal">info</span>4z.com;<br><span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$request_uri</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改完毕后重启 nginx 即可</p><h2 id="五-证书续签"><a href="#五-证书续签" class="headerlink" title="五 : 证书续签"></a>五 : 证书续签</h2><p>Let’s Encrypt 提供的证书只有90天的有效期，我们必须在证书到期之前，重新获取这些证书</p><p>certbot 给我们提供了一个很方便的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">certbot renew<br></code></pre></td></tr></table></figure><p>值得注意的是, 我们生成证书的时候使用的是 <code>standalone</code> 模式, 验证域名的时候, 需要启用443端口, 否则会报端口占用的错误</p><p>证书是90天才过期, 在过期之前执行更新操作就可以了; 这件事情可以交给定时任务完成, linux 系统上有 cron 可以来搞定这件事情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建 certbot-auto-renew-cron</span><br><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">vim certbot-auto-renew-cron</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--pre-hook: 表示执行更新操作之前要做的事情</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--post-hook: 表示执行更新操作完成后要做的事情</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cron表达式(分 时 日 月 周几): 每隔2个月的1日2点15分执行一次</span><br>15 2 1 */2 * certbot renew --pre-hook &quot;systemctl stop nginx&quot; --post-hook &quot;systemctl start nginx&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动定时任务</span><br><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">crontab certbot-auto-renew-cron</span><br></code></pre></td></tr></table></figure><h2 id="六-撤回证书"><a href="#六-撤回证书" class="headerlink" title="六 : 撤回证书"></a>六 : 撤回证书</h2><p>主要就是撤回证书, 然后删掉域名即可, 基本不用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">撤回证书</span><br><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">certbot revoke --cert-path /etc/letsencrypt/live/www.info4z.com/cert.pem</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移除域名</span><br><span class="hljs-meta prompt_">[root@localhost]# </span><span class="language-bash">certbot delete --cert-name www.info4z.com</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell编程</title>
    <link href="/2023/02/03/shell%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/03/shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-多命令执行符"><a href="#一-多命令执行符" class="headerlink" title="一 : 多命令执行符"></a>一 : 多命令执行符</h2><table><thead><tr><th>多命令执行符</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td><code>;</code></td><td>命令1<code>;</code>命令2</td><td>多个命令顺序执行, 命令之间没有任何逻辑联系</td></tr><tr><td><code>&amp;&amp;</code></td><td>命令1<code>&amp;&amp;</code>命令2</td><td>当命令1正确执行($?&#x3D;0), 则命令2才会执行; 当命令1执行不正确($? ≠ 0), 则命令2不会执行</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td></tr></tbody></table><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断命令是否正确执行</span><br>[root@localhost ~]# ls &amp;&amp; echo yes || echo no<br></code></pre></td></tr></table></figure><h2 id="二-数值运算的方法"><a href="#二-数值运算的方法" class="headerlink" title="二 : 数值运算的方法"></a>二 : 数值运算的方法</h2><p>在 linux 中, 所有变量的默认类型是字符串型, 如果我需要进行数值运算, 可以采用的方式有三种</p><p><strong>推荐使用 <code>$((运算式))</code> 的方式</strong></p><h3 id="一-运算式-或-运算式"><a href="#一-运算式-或-运算式" class="headerlink" title="(一) $((运算式))或$[运算式]"></a>(一) <code>$((运算式))</code>或<code>$[运算式]</code></h3><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">变量 ff 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br>[root@localhost ~]# ff=$(( $aa+$bb ))<br>[root@localhost ~]# echo $ff<br>33<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变量 gg 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# gg=$[ $aa+$bb ]<br>[root@localhost ~]# echo $gg<br>33<br></code></pre></td></tr></table></figure><h3 id="二-数值运算工具-expr-或-let"><a href="#二-数值运算工具-expr-或-let" class="headerlink" title="(二) 数值运算工具 expr 或 let"></a>(二) 数值运算工具 expr 或 let</h3><p><strong>expr</strong> 命令要求<strong>运算符左右两侧必须有空格</strong>, 否则运算不执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量aa和变量bb赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">dd</span>的值是aa和bb的和。注意<span class="hljs-string">&quot;+&quot;</span>号左右两侧必须有空格</span><br>[root@localhost ~]# dd=$(expr $aa + $bb)<br><br>[root@localhost ~]# echo $dd <br>33<br></code></pre></td></tr></table></figure><p><strong>let</strong> 命令对格式要求比较宽松, 所以<strong>推荐使用 let 命令进行数值运算</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">给变量 aa 和变量 bb 赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量 ee 的值是 aa 和 bb 的和</span><br>[root@localhost ~]# let ee=$aa+$bb<br>[root@localhost ~]# echo $ee<br>33<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">定义变量 n</span><br>[root@localhost ~]# n=20<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量 n 的值等于变量本身再加 1</span><br>[root@localhost ~]# let n+=1<br>[root@localhost ~]# echo $n<br>21<br></code></pre></td></tr></table></figure><h3 id="三-声明变量类型-declare"><a href="#三-声明变量类型-declare" class="headerlink" title="(三) 声明变量类型 declare"></a>(三) 声明变量类型 <code>declare</code></h3><p>既然所有变量的默认类型是字符串型, 那么只要把变量声明为整数型不就可以了吗? 使用 <code>declare</code> 命令就可以实现声明变量的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# declare [+/-][选项] 变量名<br>选项:<br>    -: 给变量设定类型属性<br>    +: 取消变量的类型属性<br>    <br>    -a: 将变量声明为数组型(array)<br>    -i: 将变量声明为整数型(integer) <br>    -r: 讲变量声明为只读变量(readonly)。<br>        注意, 一旦设置为只读变量, 既不能修改变量的值, 也不能删除变量, 甚至不能通过+r 取消只读属性<br>    -x: 将变量声明为环境变量<br>    -p: 显示指定变量的被声明的类型<br></code></pre></td></tr></table></figure><p>代码示例, 了解即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 aa 和 bb 赋值</span><br>[root@localhost ~]# aa=11<br>[root@localhost ~]# bb=22<br><span class="hljs-meta prompt_"># </span><span class="language-bash">声明变量 cc 的类型是整数型, 它的值是 aa 和 bb 的和</span><br>[root@localhost ~]# declare -i cc=$aa+$bb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这下终于可以相加了</span><br>[root@localhost ~]# echo $cc<br>33<br></code></pre></td></tr></table></figure><h2 id="二-条件判断-test"><a href="#二-条件判断-test" class="headerlink" title="二 : 条件判断 test"></a>二 : 条件判断 test</h2><h3 id="一-文件类型"><a href="#一-文件类型" class="headerlink" title="(一) 文件类型"></a>(一) 文件类型</h3><p>相关参数 </p><table><thead><tr><th>选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td><code>-b</code> 文件</td><td>block</td><td>判断该文件是否存在, 并且是否为块设备文件(是块设备文件为真)</td></tr><tr><td><code>-c</code> 文件</td><td>character</td><td>判断该文件是否存在, 并且是否为字符设备文件(是字符设备文件为真)</td></tr><tr><td><strong><code>-d</code> 文件</strong></td><td>directory</td><td>判断该文件是否存在, 并且是否为目录文件(<strong>是目录为真</strong>)</td></tr><tr><td><strong><code>-e</code> 文件</strong></td><td>exists</td><td>判断该文件是否存在(<strong>存在为真</strong>)</td></tr><tr><td><strong><code>-f</code> 文件</strong></td><td>file</td><td>判断该文件是否存在, 并且是否为普通文件(<strong>是普通文件为真</strong>)</td></tr><tr><td><strong><code>-L</code> 文件</strong></td><td>link</td><td>判断该文件是否存在, 并且是否为符号链接文件(<strong>是符号链接文件为真</strong>)</td></tr><tr><td><code>-p</code> 文件</td><td>pipe</td><td>判断该文件是否存在, 并且是否为管道文件(是管道文件为真)</td></tr><tr><td><strong><code>-s</code> 文件</strong></td><td>size &gt; 0</td><td>判断该文件是否存在, 并且是否为非空(<strong>非空为真</strong>)</td></tr><tr><td><code>-S</code> 文件</td><td>socket</td><td>判断该文件是否存在, 并且是否为套接字文件(是套接字文件为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令格式</span><br>[root@localhost ~]# test -e /root/sh/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通常我们喜欢使用另一种格式,而且更通用,如下</span><br>[root@localhost ~]# [ -e /root/sh/ ]<br>[root@localhost ~]# echo $?<br>0 #判断结果为 0,/root/sh/目录是存在的<br><br>[root@localhost ~]# [ -e /root/test ]<br>[root@localhost ~]# echo $? <br>1 #在/root/下并没有test文件或目录,所以&quot;$?&quot;的返回值为非零<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用&amp;&amp;和||</span><br>[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><h3 id="二-文件权限"><a href="#二-文件权限" class="headerlink" title="(二) 文件权限"></a>(二) 文件权限</h3><p>相关参数 </p><table><thead><tr><th>选项</th><th>作 用</th></tr></thead><tbody><tr><td><strong><code>-r</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有读权限(有读权限为真)</td></tr><tr><td><strong><code>-w</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有写权限(有写权限为真)</td></tr><tr><td><strong><code>-x</code> 文件</strong></td><td>判断该文件是否存在, 并且是否该文件拥有执行权限(有执行权限为真)</td></tr><tr><td><code>-u</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SUID 权限(有 SUID 权限为真)</td></tr><tr><td><code>-g</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SGID 权限(有 SGID 权限为真)</td></tr><tr><td><code>-k</code> 文件</td><td>判断该文件是否存在, 并且是否该文件拥有 SBit 权限(有 SBit 权限为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ll null.txt <br>-rw-r--r-- 1 root root 0 Nov 16 18:45 null.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断文件是拥有写权限的</span><br>[root@localhost ~]# [ -w null.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br></code></pre></td></tr></table></figure><h3 id="三-文件比较"><a href="#三-文件比较" class="headerlink" title="(三) 文件比较"></a>(三) 文件比较</h3><p>如何进行两个文件之间的比较</p><table><thead><tr><th>测试选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td>文件1 <code>-nt</code> 文件2</td><td>new</td><td>判断文件1的修改时间是否比文件2的新(如果新则为真)</td></tr><tr><td>文件1 <code>-ot</code> 文件2</td><td>old</td><td>判断文件1的修改时间是否比文件2的旧(如果旧则为真)</td></tr><tr><td><strong>文件1 <code>-ef</code> 文件2</strong></td><td>equal</td><td>判断文件1是否和文件2的Inode号一致,可以理解为两个文件是否为同一个文件(<strong>硬链接</strong>)</td></tr></tbody></table><p>代码示例 : 判断两个文件是否是硬链接呢</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建个硬链接吧</span><br>[root@localhost ~]# ln /root/student.txt /tmp/stu.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">用 <span class="hljs-built_in">test</span> 测试下,果然很有用</span><br>[root@localhost ~]# [ /root/student.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br></code></pre></td></tr></table></figure><h3 id="四-整数比较"><a href="#四-整数比较" class="headerlink" title="(四) 整数比较"></a>(四) 整数比较</h3><p>如何在两个整数之间进行比较</p><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 <code>-eq</code> 整数2</td><td>判断整数1是否和整数2相等(相等为真)</td></tr><tr><td>整数1 <code>-ne</code> 整数2</td><td>判断整数1是否和整数2不相等(不相等位置)</td></tr><tr><td>整数1 <code>-gt</code> 整数2</td><td>判断整数1是否大于整数2(大于为真)</td></tr><tr><td>整数1 <code>-lt</code> 整数2</td><td>判断整数1是否小于整数2(小于位置)</td></tr><tr><td>整数1 <code>-ge</code> 整数2</td><td>判断整数1是否大于等于整数2(大于等于为真)</td></tr><tr><td>整数1 <code>-le</code> 整数2</td><td>判断整数1是否小于等于整数2(小于等于为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 23 是否大于等于 22,当然是了</span><br>[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 23 是否小于等于 22,当然不是了</span><br>[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br>no<br></code></pre></td></tr></table></figure><h3 id="五-字符串判断"><a href="#五-字符串判断" class="headerlink" title="(五) 字符串判断"></a>(五) 字符串判断</h3><p>字符串的判断</p><table><thead><tr><th>测试选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td><code>-z</code> 字符串</td><td>length zero</td><td>判断字符串是否为空(空为真)</td></tr><tr><td><code>-n</code> 字符串</td><td>nonzero</td><td>判断字符串是否为非空(非空为真)</td></tr><tr><td>字串1 <code>==</code> 字串2</td><td></td><td>判断字符串1是否和字符串2相等(相等为真)</td></tr><tr><td>字串1 <code>!=</code> 字串2</td><td></td><td>判断字符串1是否和字符串2不相等(不等为真)</td></tr></tbody></table><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断name变量是否为空</span><br>[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 aa 和变量 bb 赋值</span><br>[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><h3 id="六-多重条件判断"><a href="#六-多重条件判断" class="headerlink" title="(六) 多重条件判断"></a>(六) 多重条件判断</h3><p>多重条件判断是什么样子的</p><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 <code>-a</code> 判断2</td><td>逻辑与, 判断1和判断2都成立, 最终的结果才为真</td></tr><tr><td>判断1 <code>-o</code> 判断2</td><td>逻辑或, 判断1和判断2有一个成立, 最终的结果就为真</td></tr><tr><td><code>!</code> 判断</td><td>逻辑非, 使原始的判断式取反</td></tr></tbody></table><p>代码示例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断变量aa是否为空且是否大于 23</span><br>[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本来<span class="hljs-string">&quot;-n&quot;</span>选项是变量aa不为空,加<span class="hljs-string">&quot;!&quot;</span>后相当于<span class="hljs-string">&quot;-z&quot;</span></span><br>[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; <br></code></pre></td></tr></table></figure><ul><li><strong>注意 : <code>!</code> 和 <code>-n</code> 之间必须加入空格,否则会报错的。</strong></li></ul><h2 id="三-条件判断"><a href="#三-条件判断" class="headerlink" title="三 : 条件判断"></a>三 : 条件判断</h2><h3 id="一-单分支-if"><a href="#一-单分支-if" class="headerlink" title="(一) 单分支 if"></a>(一) 单分支 if</h3><p>单分支条件语句最为简单, 就是只有一个判断条件, 如果符合条件则执行某个程序, 否则什么事情都不做; 语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ];then<br>程序<br>fi<br></code></pre></td></tr></table></figure><p>需要注意几个点 : </p><ul><li><p><strong><code>if</code> 语句使用 <code>fi</code> 结尾</strong>, 和一般语言使用大括号结尾不同</p></li><li><p><code>[ 条件判断式 ]</code> 就是使用 <code>test</code> 命令判断,所以<strong>中括号和条件判断式之间必须有空格</strong></p></li><li><p><code>then</code> 后面跟符合条件之后执行的程序, 可以放在 <code>[]</code> 之后用 <code>;</code> 分割。<strong>也可以换行写入, 就不需要 <code>;</code> 了</strong>, 比如单分支 if 语句还可以这样写 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>    then<br>  程序<br>fi<br></code></pre></td></tr></table></figure></li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/if1.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">统计根分区使用率</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">把根分区使用率作为变量值赋予变量 rate</span><br>rate=$(df -h | grep &quot;/dev/vda1&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 rate 的值如果大于等于 80,则执行 <span class="hljs-keyword">then</span> 程序</span><br>if [ $rate -ge 80 ]<br>    then <br>    echo &quot;Warning! /dev/sda3 is full!!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="二-双分支-if-条件语句"><a href="#二-双分支-if-条件语句" class="headerlink" title="(二) 双分支 if 条件语句"></a>(二) 双分支 if 条件语句</h3><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>    then<br>    条件成立时,执行的程序<br>    else<br>    条件不成立时,执行的另一个程序<br>fi<br></code></pre></td></tr></table></figure><p>代码示例 : 我们写一个数据备份的例子, 来看看双分支 if 条件语句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">备份 mysql 数据库</span><br>[root@localhost ~]# vi sh/bakmysql.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份 mysql 数据库</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">同步系统时间</span><br>ntpdate asia.pool.ntp.org &amp;&gt;/dev/null<br><span class="hljs-meta prompt_">#</span><span class="language-bash">把当前系统时间按照<span class="hljs-string">&quot;年月日&quot;</span>格式赋予变量 <span class="hljs-built_in">date</span></span><br>date=$(date +%y%m%d)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">统计 mysql 数据库的大小,并把大小赋予 size 变量</span><br>size=$(du -sh /var/lib/mysql)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断备份目录是否存在,是否为目录</span><br>if [ -d /tmp/dbbak ]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果判断为真,执行以下脚本</span><br>    then<br>    #把当前日期写入临时文件<br>        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt<br>        #把数据库大小写入临时文件<br>        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt<br>        #进入备份目录<br>        cd /tmp/dbbak<br>        #打包压缩数据库与临时文件,把所有输出丢入垃圾箱(不想看到任何输出)<br>        tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null<br>        #删除临时文件<br>        rm -rf /tmp/dbbak/dbinfo.txt<br>    else<br>    #如果判断为假,则建立备份目录<br>        mkdir /tmp/dbbak<br>        #把日期和数据库大小保存如临时文件<br>        echo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt<br>        echo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt<br>        #压缩备份数据库与临时文件<br>        cd /tmp/dbbak<br>        tar -zcf mysql-lib-$date.tar.gz dbinfo.txt /var/lib/mysql &amp;&gt;/dev/null<br>        #删除临时文件<br>        rm -rf /tmp/dbbak/dbinfo.txt<br>fi<br></code></pre></td></tr></table></figure><ul><li><strong>注意 :</strong> 解释一下 <strong><code>&amp;&gt;/dev/null</code></strong> 这个命令, <code>&amp;&gt;</code> 输出, <code>/dev/null</code> 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 <code>&amp;&gt;/dev/null</code>, <strong>用于屏蔽命令的提示信息</strong></li></ul><p>实例 : 在工作当中,服务器上的服务经常会宕机。如果我们对服务器监控不好,就会造成服务器中服务宕机了,而管理员却不知道的情况, 这时我们可以写一个脚本来监听本机的服务,如果服务停止或宕机了,可以自动重启这些服务。我们拿 apache 服务来举例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">判断 apache 是否启动,如果没有启动则自动启动</span><br>[root@localhost ~]# vi sh/autostart.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 apache 是否启动,如果没有启动则自动启动</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Author: Bob (E-mail: Bob@163.com)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用nmap命令扫描服务器公网ip,并截取 apache 服务的状态,赋予变量 port</span><br>port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果变量 port 的值是<span class="hljs-string">&quot;open&quot;</span></span><br>if [ &quot;$port&quot; == &quot;open&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">则证明 apache 正常启动,在正常日志中写入一句话即可</span><br>echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log<br>else<br><span class="hljs-meta prompt_">#</span><span class="language-bash">否则证明 apache 没有启动,自动启动 apache</span><br>/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null<br><span class="hljs-meta prompt_">#</span><span class="language-bash">并在错误日志中记录自动启动 apche 的时间</span><br>echo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.log<br>fi<br></code></pre></td></tr></table></figure><ul><li><p>我们使用 <code>nmap</code> 端口扫描命令, 它的原理是给指定服务器所有的端口发送请求, 看它是否回复, <code>nmap</code> 命令格式如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# nmap -sT 域名或IP(一般用公网IP)<br>选项 : <br>    -s 扫描<br>    -T 扫描所有开启的 TCP 端口<br></code></pre></td></tr></table></figure></li><li><p>这条命令的执行结果如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到这台服务器开启了如下的服务</span><br>[root@localhost ~]# nmap -sT 192.168.4.210<br>Starting Nmap 5.51 ( http://nmap.org ) at 2018-11-25 15:11 CST<br>Nmap scan report for 192.168.4.210<br>Host is up (0.0010s latency).<br>Not shown: 994 closed ports<br>PORT STATE SERVICE<br>22/tcp open ssh<br>80/tcp open http #apache 的状态是 open<br>111/tcp open rpcbind<br>139/tcp open netbios-ssn<br>445/tcp open microsoft-ds<br>3306/tcp open mysql<br>Nmap done: 1 IP address (1 host up) scanned in 0.49 seconds<br></code></pre></td></tr></table></figure></li><li><p>知道了 <code>nmap</code> 命令的用法,我们在脚本中使用的命令就是为了截取 <code>http</code> 的状态,只要状态是 <code>open</code> 就证明 apache 启动正常,否则证明 apache 启动错误。来看看脚本中命令的结果 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描指定计算机,提取包含 tcp 的行,在提取包含 httpd 的行,截取第二列</span><br>[root@localhost ~]# nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;<br>open<br><span class="hljs-meta prompt_"># </span><span class="language-bash">把截取的值赋予变量 port</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="三-多分支-if-条件语句"><a href="#三-多分支-if-条件语句" class="headerlink" title="(三) 多分支 if 条件语句"></a>(三) 多分支 if 条件语句</h3><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 1 ]<br>    then<br>    当条件判断式 1 成立时,执行程序 1<br>elif [ 条件判断式 2 ]<br>    then<br>        当条件判断式 2 成立时,执行程序 2 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">…省略更多条件…</span><br>else<br>当所有条件都不成立时,最后执行此程序<br>fi<br></code></pre></td></tr></table></figure><p>代码示例 : 判断用户输入的是什么文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/if-elif.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断用户输入的是什么文件</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接收键盘的输入,并赋予变量 file</span><br>read -p &quot;Please input a filename: &quot; file<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 变量是否为空</span><br>if [ -z &quot;$file&quot; ]<br>then<br>        #如果为空,执行程序 1,也就是输出报错信息<br>        echo &quot;Error,please input a filename&quot;<br>        #退出程序,并返回值为 1(把返回值赋予变量$?)<br>exit 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否存在</span><br>elif [ ! -e &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果不存在,则执行程序 2</span><br>echo &quot;Your input is not a file!&quot;<br>        #退出程序,把并定义返回值为 2<br>        exit 2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否为普通文件</span><br>elif [ -f &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是普通文件,则执行程序 3</span><br>        echo &quot;$file is a regulare file!&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断 file 的值是否为目录文件</span><br>elif [ -d &quot;$file&quot; ]<br>then<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是目录文件,则执行程序 4</span><br>echo &quot;$file is a directory!&quot;<br>else<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果以上判断都不是,则执行程序 5</span><br>echo &quot;$file is an other file!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="四-case-条件语句"><a href="#四-case-条件语句" class="headerlink" title="(四) case 条件语句"></a>(四) case 条件语句</h3><p><code>case</code> 语句和 <code>if…elif…else</code> 语句一样都是多分支条件语句, 不过和 <code>if</code> 多分支条件语句不同的是, <code>case</code> 语句只能判断一种条件关系, 而 <code>if</code> 语句可以判断多种条件关系。case 语句语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>    &quot;值1&quot;)<br>    如果变量的值等于值 1,则执行程序 1<br>    ;;<br>    &quot;值2&quot;)<br>    如果变量的值等于值 2,则执行程序 2<br>    ;;<br>    …省略其他分支…<br>     *)<br>    如果变量的值都不是以上的值,则执行此程序<br>    ;;<br>esac<br></code></pre></td></tr></table></figure><p><strong>注意</strong>以下内容 : </p><ul><li><code>case</code> 语句, 会取出变量中的值, 然后与语句体中的值逐一比较; 如果数值符合, 则执行对应的程序, 如果数值不符, 则依次比较下一个值。如果所有的值都不符合,则执行 <code>*)</code> 中的程序;  <code>*</code>  代表所有其他值</li><li><code>case</code> 语句以 <code>case</code> 开头, 以 <code>esac</code> 结尾; 每一个分支程序之后要通过 <code>;;</code> 双分号结尾, 代表该程序段结束(千万不要忘记)。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/case.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断用户输入</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在屏幕上输出<span class="hljs-string">&quot;请选择 yes/no&quot;</span>,然后把用户选择赋予变量 cho</span><br>read -p &quot;Please choose yes/no: &quot; -t 30 cho<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断变量 cho 的值</span><br>case $cho in<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是 <span class="hljs-built_in">yes</span></span><br>    &quot;yes&quot;)<br>    #执行程序 1<br>        echo &quot;Your choose is yes!&quot;<br>        ;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果是 no</span><br>    &quot;no&quot;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行程序 2</span><br>        echo &quot;Your choose is no!&quot;<br>        ;;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果既不是 <span class="hljs-built_in">yes</span>,也不是 no</span><br>    *)<br>    #则执行此程序<br>        echo &quot;Your choose is error!&quot;<br>        ;;<br>esac<br></code></pre></td></tr></table></figure><h2 id="四-循环"><a href="#四-循环" class="headerlink" title="四 : 循环"></a>四 : 循环</h2><h3 id="一-for-循环"><a href="#一-for-循环" class="headerlink" title="(一) for 循环"></a>(一) for 循环</h3><p><code>for</code> 循环是固定循环, 也就是在循环时已经知道需要进行几次的循环, 有时也把 <code>for</code> 循环称为<strong>计数循环</strong>。for 的语法有两种 : </p><p><strong>语法一</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3…<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><ul><li>这种语法中 for 循环的次数, 取决于 in 后面值的个数(空格分隔), 有几个值就循环几次, 并且每次循环都把值赋予变量。也就是说,假设 in 后面有三个值, 就会循环三次, 第一次循环会把值1赋予变量, 第二次循环会把值2赋予变量, 以此类推。</li></ul><p><strong>语法二</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( 初始值;循环控制条件;变量变化 ))<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><p>语法二中<strong>需要注意</strong> : </p><ul><li>初始值 : 在循环开始时, 需要给某个变量赋予初始值, 如 i&#x3D;1;  </li><li>循环控制条件 : 用于指定变量循环的次数,如 i&lt;&#x3D;100, 则只要 i 的值小于等于 100, 循环就会继续; </li><li>变量变化 : 每次循环之后, 变量该如何变化,如 i&#x3D;i+1; 代表每次循环之后, 变量 i 的值都加 1。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/for.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印时间</span><br>for time in morning noon afternoon evening<br>do<br>echo &quot;This time is $time!&quot;<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/auto-tar.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量解压缩脚本</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入压缩包目录</span><br>cd /lamp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出.tar.gz的值,有多少个文件,就会循环多少次,每次循环把文件名赋予变量i</span><br>for i in $(ls *.tar.gz)<br>do<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压缩,并把所有输出都丢弃</span><br>tar -zxf $i &amp;&gt;/dev/null<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从1加到100</span><br><br>s=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">定义循环 100 次</span><br>for (( i=1;i&lt;=100;i=i+1 ))<br>    do<br>    # 每次循环给变量 s 赋值<br>        s=$(( $s+$i ))<br>    done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出1加到100的和</span><br>echo &quot;The sum of 1+2+...+100 is : $s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi useradd.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量添加指定数量的用户</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入用户名,把输入保存入变量 name</span><br>read -p &quot;Please input user name: &quot; -t 30 name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量,把输入保存入变量 num</span><br>read -p &quot;Please input the number of users: &quot; -t 30 num <br><span class="hljs-meta prompt_"># </span><span class="language-bash">让用户输入初始密码,把输入保存如变量 pass</span><br>read -p &quot;Please input the password of users: &quot; -t 30 pass<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span><br>if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot; ]<br>    then<br>    # 定义变量的值为后续命令的结果<br>    # 后续命令作用是,把变量num的值替换为空。如果能替换为空,证明 num 的值为数字<br>    # 如果不能替换为空,证明 num 的值为非数字。我们使用这种方法判断变量 num 的值为数字<br>    y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)<br>        # 如果变量 y 的值为空,证明 num 变量是数字<br>        if [ -z &quot;$y&quot; ]<br>            then<br>                # 循环 num 变量指定的次数<br>                for (( i=1;i&lt;=$num;i=i+1 ))<br>                    do <br>                        # 添加用户,用户名为变量 name 的值加变量 i 的数字<br>                        /usr/sbin/useradd $name$i &amp;&gt;/dev/null<br>                        # 给用户设定初始密码为变量 pass 的值<br>                        echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null<br>                    done<br>        fi <br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/userdel.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">批量删除用户</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">读取用户信息文件,提取可以登录用户,排除root用户,截取第一列就是用户名</span><br>user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; |cut -d &quot;:&quot; -f 1)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环,有多少个普通用户,循环多少次</span><br>for i in $user<br>    do <br>    #每次循环,删除指定普通用户<br>        userdel -r $i<br>    done<br></code></pre></td></tr></table></figure><h3 id="二-while-循环"><a href="#二-while-循环" class="headerlink" title="(二) while 循环"></a>(二) while 循环</h3><p>对 <code>while</code> 循环来讲, 只要条件判断式成立, 循环就会一直继续, 直到条件判断式不成立, 循环才会停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]<br>    do<br>    程序<br>    done<br></code></pre></td></tr></table></figure><p>代码示例 : 1 加到 100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从 1 加到 100</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给变量 i 和变量 s 赋值</span><br>i=1<br>s=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果变量 i 的值小于等于 100,则执行循环</span><br>while [ $i -le 100 ]<br>    do<br>        s=$(( $s+$i ))<br>        i=$(( $i+1 ))<br>    done<br>echo &quot;The sum is: $s&quot; <br></code></pre></td></tr></table></figure><h3 id="三-until-循环"><a href="#三-until-循环" class="headerlink" title="(三) until 循环"></a>(三) until 循环</h3><p>和 <code>while</code> 循环相反, <code>until</code> 循环时<strong>只要条件判断式不成立则进行循环</strong>, 并执行循环程序; 一旦循环条件成立,则终止循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ 条件判断式 ]<br>    do<br>   程序<br>    done<br></code></pre></td></tr></table></figure><p>还是写从 1 加到 100 这个例子, 注意和 while 循环的区别 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 1 加到 100</span><br>[root@localhost ~]# vi sh/until.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从 1 加到 100</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给变量i和s赋值</span><br>i=1<br>s=0<br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环直到变量i的值大于100,就停止循环</span><br>until [ $i -gt 100 ]<br>    do<br>        s=$(( $s+$i ))<br>        i=$(( $i+1 ))<br>    done<br>echo &quot;The sum is: $s&quot;<br></code></pre></td></tr></table></figure><h2 id="五-退出"><a href="#五-退出" class="headerlink" title="五 : 退出"></a>五 : 退出</h2><h3 id="一-exit-语句"><a href="#一-exit-语句" class="headerlink" title="(一) exit 语句"></a>(一) exit 语句</h3><p>系统是有 <code>exit</code> 命令的,用于退出当前用户的登录状态。可是在 Shell 脚本中, <code>exit</code> 语句是用来退出当前脚本的。也就是说, 在 Shell 脚本中, 只要碰到了 <code>exit</code> 语句, 后续的程序就不再执行, 而直接退出脚本。</p><p>exit 的语法如下 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit [返回值]<br></code></pre></td></tr></table></figure><ul><li>如果 <code>exit</code> 命令之后定义了返回值, 那么这个脚本执行之后的返回值就是我们自己定义的返回值; 可以通过查询 <code>$?</code> 这个变量来查看返回值; 如果 exit 之后没有定义返回值, 脚本执行之后的返回值是执行 exit 语句之前, 最后执行的一条命令的返回值。</li></ul><p>代码示例 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/exit.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接收用户的输入,并把输入赋予num</span><br>read -p &quot;Please input a number: &quot; -t 30 num <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果变num的值是数字,则把num的值替换为空,否则不替换</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">把替换之后的值赋予变量 y</span><br>y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">判断变量 y 的值如果不为空,输出报错信息,退出脚本,退出返回值为 18</span><br>[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果没有退出脚本,则打印变量 num 中的数字</span><br>echo &quot;The number is: $num&quot;<br></code></pre></td></tr></table></figure><ul><li><strong>注意 : 这里的字符串变量要用 <code>&quot;&quot;</code> 引一下</strong></li></ul><h3 id="二-break-语句"><a href="#二-break-语句" class="headerlink" title="(二) break 语句"></a>(二) break 语句</h3><p>再来看看特殊流程控制语句 <code>break</code> 的作用, 当程序执行到 <code>break</code> 语句时, <strong>会结束整个当前循环</strong>; 而 <code>continue</code> 语句也是结束循环的语句, 不过 <code>continue</code> 语句单次当前循环, 而下次循环会继续。</p><p>代码示例 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/break.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">演示 <span class="hljs-built_in">break</span> 跳出循环</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">循环十次</span><br>for (( i=1;i&lt;=10;i=i+1 ))<br>    do <br>    #如果变量 i 的值等于 4<br>        if [ &quot;$i&quot; -eq 4 ]<br>            then<br>            #退出整个循环<br>                break<br>        fi <br>        echo $i<br>        #输出变量 i 的值<br>    done<br></code></pre></td></tr></table></figure><p>测试结果 : 输出1,2,3后停止脚本</p><h3 id="三-continue-语句"><a href="#三-continue-语句" class="headerlink" title="(三) continue 语句"></a>(三) continue 语句</h3><p>再来看看 continue 语句, continue 也是结束流程控制的语句; 如果在循环中, <code>continue</code> 语句只会<strong>结束单次当前循环</strong></p><p>还是用刚刚的脚本,不过退出语句换成 <code>continue</code> 语句,看看会发生什么情况 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi sh/continue.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">演示 <span class="hljs-built_in">continue</span> 语句</span><br><br>for (( i=1;i&lt;=10;i=i+1 ))<br>    do <br>        if [ &quot;$i&quot; -eq 4 ] <br>            then<br>            #退出语句换成 continue<br>                continue<br>        fi <br>        echo $i<br>    done<br></code></pre></td></tr></table></figure><p>测试结果 : 只有4不会被输出</p><h2 id="六-函数"><a href="#六-函数" class="headerlink" title="六 : 函数"></a>六 : 函数</h2><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function 函数名 () &#123;<br>程序<br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@localhost ~]<span class="hljs-comment"># vi sh/function.sh</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment">#接收用户输入的数字,然后从1加到这个数字</span><br><br><span class="hljs-comment">#定义函数 sum</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">sum</span></span> () &#123;<br>    s=0 <br>    <span class="hljs-comment">#循环直到i大于$1为止。$1是函数sum的第一个参数</span><br>    <span class="hljs-comment">#在函数中也可以使用位置参数变量,不过这里的$1指的是函数的第一个参数</span><br>    <span class="hljs-keyword">for</span> (( i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-variable">$1</span>;i=i+<span class="hljs-number">1</span> ))<br>        <span class="hljs-keyword">do</span> <br>        s=$(( <span class="hljs-variable">$i</span>+<span class="hljs-variable">$s</span> ))<br>        <span class="hljs-keyword">done</span><br><span class="hljs-comment">#输出1加到$1 的和</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The sum of 1+2+3...+<span class="hljs-variable">$1</span> is : <span class="hljs-variable">$s</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment">#接收用户输入的数字,并把值赋予变量num</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please input a number: &quot;</span> -t 30 num <br><span class="hljs-comment">#把变量num的值替换为空,并赋予变量y</span><br>y=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$num</span> | sed <span class="hljs-string">&#x27;s/[0-9]//g&#x27;</span>)<br><span class="hljs-comment">#判断变量y是否为空,以确定变量 num 中是否为数字</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$y</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">#调用sum函数,并把变量num的值作为第一个参数传递给 sum 函数</span><br>        <span class="hljs-built_in">sum</span> <span class="hljs-variable">$num</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">#如果变量 num 的值不是数字,则输出报错信息</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error!! Please input a number!&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="七-接收键盘输入"><a href="#七-接收键盘输入" class="headerlink" title="七 : 接收键盘输入"></a>七 : 接收键盘输入</h2><p>用来从标准输入读取单行数据; 这个命令可以用来读取键盘输入, 当使用重定向的时候, 可以读取文件中的一行数据; 命令格式 : </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# read [选项] [变量名]<br>选项:<br>    -p &quot;message&quot;: 在等待 read 输入时, 输出提示信息(message)<br>    -t second: read 命令会一直等待用户输入, 使用此选项可以指定等待时间(秒数)<br>    -n number: read 命令只接受指定的字符数(number), 就会执行<br>    -s : 隐藏输入的数据, 适用于机密信息的输入<br>变量名:<br>    变量名可以自定义, 如果不指定变量名, 会把输入保存入默认变量 REPLY<br>    如果只提供了一个变量名, 则整个输入行赋予该变量<br>    如果提供了一个以上的变量名, 则输入行分为若干字, 一个接一个地赋予各个变量, 而命令行上的最后一个变量取得剩余的所有字<br></code></pre></td></tr></table></figure><p>还是写个例子来解释下 <code>read</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost sh]# vi read.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Author: Bob (E-mail: Bob@163.com)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请输入姓名&quot;</span>并等待 30 秒, 把用户的输入保存入变量 name 中</span><br>read -t 30 -p &quot;Please input your name: &quot; name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">看看变量<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span>中是否保存了你的输入</span><br>echo &quot;Name is $name&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请输入年龄&quot;</span>并等待30秒, 把用户的输入保存入变量age中</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">年龄是隐私, 所以我们用<span class="hljs-string">&quot;-s&quot;</span>选项隐藏输入</span><br>read -s -t 30 -p &quot;Please enter your age: &quot; age<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调整输出格式,如果不输出换行,一会儿的年龄输出不会换行</span><br>echo -e &quot;\n&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提示<span class="hljs-string">&quot;请选择性别&quot;</span>并等待 30 秒, 把用户的输入保存入变量 gender</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-string">&quot;-n 1&quot;</span>选项只接收一个输入字符就会执行(都不用输入回车)</span><br>echo &quot;Age is $age&quot;<br>read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender<br><br>echo -e &quot;\n&quot;<br>echo &quot;Sex is $gender&quot;<br></code></pre></td></tr></table></figure><h2 id="八-输入输出重定向"><a href="#八-输入输出重定向" class="headerlink" title="八 : 输入输出重定向"></a>八 : 输入输出重定向</h2><h3 id="一-Bash-的标准输入输出"><a href="#一-Bash-的标准输入输出" class="headerlink" title="(一) Bash 的标准输入输出"></a>(一) Bash 的标准输入输出</h3><table><thead><tr><th>设备</th><th>设备文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>&#x2F;dev&#x2F;stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>&#x2F;dev&#x2F;stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>&#x2F;dev&#x2F;stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table><h3 id="二-输出重定向"><a href="#二-输出重定向" class="headerlink" title="(二) 输出重定向"></a>(二) 输出重定向</h3><p>标准输出重定向</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>以覆盖的方式, 把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>以追加的方式, 把命令的正确输出输出到指定的文件或设备当中</td></tr></tbody></table><p>标准错误输出重定向</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>错误命令 2&gt;文件</td><td>以覆盖的方式, 把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td>错误命令 2&gt;&gt;文件</td><td>以追加的方式, 把命令的错误输出输出到指定的文件或设备当中</td></tr></tbody></table><p>正确输出和错误输出同时保存</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件 2&gt;&amp;1</td><td>以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &gt;&gt; 文件 2&gt;&amp;1</strong></td><td>以追加的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td>命令 &amp;&gt;文件</td><td>以覆盖的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &amp;&gt;&gt;文件</strong></td><td>以追加的方式, 把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td><strong>命令 &gt;&gt;文件1  2&gt;&gt;文件2</strong></td><td>把正确的输出追加到文件 1 中, 把错误的输出追加到文件 2 中</td></tr></tbody></table><ul><li><strong>注意: 错误输出<code>2</code>和<code>&gt;</code>之间不能有空格, 至于<code>&gt;</code>之后有没有空格无所谓, 为了方便记忆, 错误输出前后都不要加空格了</strong></li></ul><h3 id="三-输入重定向"><a href="#三-输入重定向" class="headerlink" title="(三) 输入重定向"></a>(三) 输入重定向</h3><p>同时也支持输入重定向</p><p>代码示例 : 在文件 var.ini 中统一定义变量, 通过脚本读出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=1<br>b=2<br>c=3<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中心思想就是把a=1,b=2,c=3引入进来声明,这里用到<span class="hljs-built_in">read</span>命令做重定向,可以一次读取一行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">eval</span>命令用于重新运算求出参数的内容,还可读取一连串的参数，然后再依参数本身的特性来执行</span><br>while read line;do<br>eval $line<br>done &lt; var.ini<br>echo $a<br>echo $b<br>echo $c<br></code></pre></td></tr></table></figure><p>代码示例 : 统计 err.log 的行数,单词数和字节数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# wc &lt; err.log<br></code></pre></td></tr></table></figure><h3 id="四-垃圾桶"><a href="#四-垃圾桶" class="headerlink" title="(四) 垃圾桶"></a>(四) 垃圾桶</h3><p>解释一下比较常用的 <strong><code>&amp;&gt;/dev/null</code></strong> 这个命令  </p><p><code>&amp;&gt;</code> 输出, <code>/dev/null</code> 这个类似回收站, 任何东西丢到这里面都会消失, 所以通常写脚本的时候, 我们习惯加上 <code>&amp;&gt;/dev/null</code>, <strong>用于屏蔽命令的提示信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> java -jar xxx.jar &amp;&gt;/dev/null &amp;</span><br></code></pre></td></tr></table></figure><p>注意 : <code>&amp;</code> 放在启动参数后面表示设置此进程为后台进程，也即非阻塞性运行，如果不加&amp;，则会执行完该命令后才能执行后面的命令。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell入门</title>
    <link href="/2023/01/27/shell%E5%85%A5%E9%97%A8/"/>
    <url>/2023/01/27/shell%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><h3 id="一-什么是-Shell"><a href="#一-什么是-Shell" class="headerlink" title="(一) 什么是 Shell"></a>(一) 什么是 Shell</h3><p>Shell 是一个用 C 语言编写的程序, 它是用户使用 Linux 的桥梁。Shell 既是一种命令语言, 又是一种程序设计语言。</p><p>Shell 是指一种应用程序, 这个应用程序提供了一个界面, 用户通过这个界面访问操作系统内核的服务。</p><pre><code class=" mermaid">graph TBsubgraph 外层应用程序subgraph shell命令解释器subgraph 内核硬件endendend</code></pre><p>Ken Thompson 的 sh 是第一种 Unix Shell, Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="二-Shell-脚本"><a href="#二-Shell-脚本" class="headerlink" title="(二) Shell 脚本"></a>(二) Shell 脚本</h3><p>Shell 脚本(shell script), 是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本, 但读者朋友要知道, shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因, 简洁起见, 本文出现的 “shell编程” 都是指 shell 脚本编程, 不是指开发 shell 自身。</p><p>shell命令解释器 : 把命令翻译成机器语言, 再把结果翻译成命令</p><h3 id="三-shell-的分类"><a href="#三-shell-的分类" class="headerlink" title="(三) shell 的分类"></a>(三) shell 的分类</h3><table><thead><tr><th>Shell 类别</th><th>易学性</th><th>可移植性</th><th>编辑性</th><th>快捷性</th></tr></thead><tbody><tr><td>Bourne Shell (sh)</td><td>容易</td><td>好</td><td>较差</td><td>较差</td></tr><tr><td>Korn Shell (ksh)</td><td>较难</td><td>较好</td><td>好</td><td>较好</td></tr><tr><td><strong>Bourne Again (Bash)</strong></td><td><strong>难</strong></td><td><strong>较好</strong></td><td><strong>好</strong></td><td><strong>好</strong></td></tr><tr><td>POSIX Shell (psh)</td><td>较难</td><td>好</td><td>好</td><td>较好</td></tr><tr><td>C Shell (csh)</td><td>较难</td><td>差</td><td>较好</td><td>较好</td></tr><tr><td>TC Shell (tcsh)</td><td>难</td><td>差</td><td>好</td><td>好</td></tr></tbody></table><p>Shell 的两种主要语法类型有 Bourne 和 C, 这两种语法彼此不兼容。</p><ul><li>Bourne 家族主要包括 sh、ksh、Bash、psh、zsh；</li><li>C 家族主要包括:csh、tcsh (Bash 和 zsh 在不同程度上支持 csh 的语法)。</li></ul><p>我们可以通过 <code>/etc/shells</code> 文件来查询 Linux 支持的 Shell。命令如下 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vi /etc/shells<br><br>/bin/sh<br>/bin/Bash<br>/sbin/nologin<br>/bin/tcsh<br>/bin/csh<br></code></pre></td></tr></table></figure><h2 id="二-特殊符号"><a href="#二-特殊符号" class="headerlink" title="二 : 特殊符号"></a>二 : 特殊符号</h2><h3 id="一-引号"><a href="#一-引号" class="headerlink" title="(一) 引号"></a>(一) 引号</h3><table><thead><tr><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>‘</td><td>在单引号中所有的特殊符号都没有特殊含义</td></tr><tr><td>“</td><td>在双引号中可以使用”$”、”&#96;”和”\“，拥有”调用变量的值”、”引用命令”和”转义符”的功能</td></tr><tr><td>&#96;</td><td>反引号括起来的内容是系统命令，在 Bash 中会先执行它。和$()作用一样，推荐使用$()</td></tr></tbody></table><h3 id="二-引用"><a href="#二-引用" class="headerlink" title="(二) 引用"></a>(二) 引用</h3><table><thead><tr><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>$</td><td>用于调用变量的值, 如需要调用变量 name 的值时, 需要用 <code>$name</code> 的方式得到变量的值</td></tr><tr><td>${}</td><td>括号里面写变量, 相当于 <code>$name</code></td></tr><tr><td>$()</td><td>和反引号作用一样, 用来引用系统命令。例如: <code>$(df -h)</code></td></tr><tr><td>$[]</td><td>括号里面运算式, 也可以用 <code>$((...))</code>, 例如: <code>$[1+2]</code></td></tr><tr><td>$(())</td><td>括号里面写运算式, 和 <code>$[]</code> 作用一样, 例如: <code>$((1+2))</code></td></tr></tbody></table><h3 id="三-括号"><a href="#三-括号" class="headerlink" title="(三) 括号"></a>(三) 括号</h3><table><thead><tr><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>()</td><td>用于一串命令执行时, ()中的命令会在子 Shell 中运行</td></tr><tr><td>{}</td><td>用于一串命令执行时, {}中的命令会在当前 Shell 中执行。也可以用于变量变形与替换</td></tr><tr><td>[]</td><td>用于变量的测试</td></tr></tbody></table><h3 id="四-其他符号"><a href="#四-其他符号" class="headerlink" title="(四) 其他符号"></a>(四) 其他符号</h3><table><thead><tr><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td>#</td><td>在 Shell 脚本中, #开头的行代表注释</td></tr><tr><td>\</td><td>转义符, 跟在 \ 之后的特殊符号将失去特殊含义, 变为普通字符。如 <code>\$</code> 将输出”$”符号, 而不当做是变量引用</td></tr></tbody></table><h2 id="三-变量使用"><a href="#三-变量使用" class="headerlink" title="三 : 变量使用"></a>三 : 变量使用</h2><h3 id="一-自定义变量"><a href="#一-自定义变量" class="headerlink" title="(一) 自定义变量"></a>(一) 自定义变量</h3><p>这种变量是最常见的变量, 由用户自由定义变量名和变量的值。</p><p>注意变量定义的时候 : 变量名不能以数字开头, <code>=</code>两边不要写空格, 变量值必须是连续的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">变量名不能用数字开头</span><br>[root@localhost ~]# 2name=&quot;Bob Han&quot;<br>-bash: 2name=Bob: command not found<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">等号左右两侧不能有空格</span><br>[root@localhost ~]# name = &quot;Bob Han&quot;<br>-bash: name: command not found<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">变量的值如果有空格, 必须用引号包含</span><br>[root@localhost ~]# name=Bob Han<br>-bash: Han: command not found<br></code></pre></td></tr></table></figure><p>变量调用就直接使用 <code>$变量名</code> 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">输出变量 name 的值</span><br>[root@localhost ~]# echo $name<br>Bob<br></code></pre></td></tr></table></figure><p>变量查看 : 直接使用 <code>set</code> 命令, 会查询系统中所有的变量, 包含用户自定义变量和环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# set [选项]<br>选项:<br>-u: 如果设定此选项, 调用未声明变量时会报错(默认无任何提示)<br>-x: 如果设定此选项, 在命令执行之前, 会把命令先输出一次<br></code></pre></td></tr></table></figure><p>删除变量 : <code>unset</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意: 直接写变量名,不加$符号</span><br>[root@localhost ~]# unset name<br></code></pre></td></tr></table></figure><h3 id="二-环境变量"><a href="#二-环境变量" class="headerlink" title="(二) 环境变量"></a>(二) 环境变量</h3><p>这种变量中主要保存的是和系统操作环境相关的数据, 比如当前登录用户, 用户的家目录, 命令的提示符等</p><ul><li>环境变量的变量名可以自由定义, 但是一般对系统起作用的环境变量的变量名是系统预先设定好的</li><li>系统自带的环境变量 : <strong>命令是确定的, 作用是确定的, 但内容可以自定义</strong></li><li>用户自定义的环境变量 : <strong>命令, 作用和内容都可以自定义</strong></li><li><strong>环境变量名建议大写, 便于区分</strong></li></ul><p>环境变量设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">export</span> 声明的变量即是环境变量</span><br>[root@localhost ~]# export age=&quot;18&quot;<br></code></pre></td></tr></table></figure><p>环境变量查询和删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查询环境变量gender,<span class="hljs-built_in">env</span> 命令只能查看环境变量,而<span class="hljs-built_in">set</span>命令可以查看所有变量</span><br>[root@localhost ~]# env | grep gender<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除环境变量gender</span><br>[root@localhost ~]# unset gender<br></code></pre></td></tr></table></figure><p>系统默认环境变量 <code>PATH</code> : 系统查找命令的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">PATH变量的值是用<span class="hljs-string">&quot;:&quot;</span>分割的路径,这些路径就是系统查找命令的路径</span><br>[root@localhost ~]# echo $PATH<br>/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br></code></pre></td></tr></table></figure><ul><li>也就是说, 如果将test.sh放到 <code>/root/bin</code> (其中一个目录)下, 程序也可以直接执行; 或者定义 <code>PATH=$PATH:/root/sh</code> 将脚本所在目录追加进去</li></ul><p>系统默认环境变量 <code>PS1</code> : 命令提示符设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认的提示符是显示<span class="hljs-string">&quot;[用户名@简写主机名 最后所在目录]提示符&quot;</span></span><br>[root@localhost ~]# echo $PS1<br>[\u@\h \W]\$<br></code></pre></td></tr></table></figure><ul><li>如果需要永久修改, 可以写入配置文件 <code>/etc/bashrc</code></li></ul><p>系统默认环境变量 <code>LANG</code> : 语系变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost src]# echo $LANG<br>zh_CN.UTF-8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询支持的语系</span><br>[root@localhost src]# locale -a | more<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询当前系统的语系(当前系统使用的语系)</span><br>[root@localhost src]# locale<br>LANG=zh_CN.UTF-8<br>LC_CTYPE=&quot;zh_CN.UTF-8&quot;<br>LC_NUMERIC=&quot;zh_CN.UTF-8&quot;<br>LC_TIME=&quot;zh_CN.UTF-8&quot;<br>LC_COLLATE=&quot;zh_CN.UTF-8&quot;<br>LC_MONETARY=&quot;zh_CN.UTF-8&quot;<br>LC_MESSAGES=&quot;zh_CN.UTF-8&quot;<br>LC_PAPER=&quot;zh_CN.UTF-8&quot;<br>LC_NAME=&quot;zh_CN.UTF-8&quot;<br>LC_ADDRESS=&quot;zh_CN.UTF-8&quot;<br>LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;<br>LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;<br>LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;<br>LC_ALL=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询系统的默认语系(下次重启之后系统所使用的语系)</span><br>[root@localhost src]# cat /etc/sysconfig/i18n <br>LANG=&quot;zh_CN.UTF-8&quot;<br></code></pre></td></tr></table></figure><h3 id="三-位置参数变量"><a href="#三-位置参数变量" class="headerlink" title="(三) 位置参数变量"></a>(三) 位置参数变量</h3><p>这种变量主要是用来向脚本当中传递参数或数据的, 变量名不能自定义, 变量作用是固定的; <strong>只有内容可以自定义</strong></p><table><thead><tr><th>位置参数变量</th><th>作用</th></tr></thead><tbody><tr><td><code>$n</code></td><td>n 为数字, $0 代表命令本身, $1-$9 代表第一到第九个参数, <strong>十以上的参数需要用大括号包含, 如${10}</strong></td></tr><tr><td><code>$*</code></td><td>这个变量代表命令行中所有的参数, <strong><code>$*</code>把所有的参数看成一个整体</strong></td></tr><tr><td><code>$@</code></td><td>这个变量也代表命令行中所有的参数, 不过**<code>$@</code>把每个参数区分对待**</td></tr><tr><td><code>$#</code></td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table><h3 id="四-预定义变量"><a href="#四-预定义变量" class="headerlink" title="(四) 预定义变量"></a>(四) 预定义变量</h3><p>是 Bash 中已经定义好的变量, 变量名不能自定义, 变量作用也是固定的; <strong>只有内容可以自定义</strong></p><table><thead><tr><th>预定义变量</th><th>作 用</th></tr></thead><tbody><tr><td>$?</td><td>最后一次执行的命令的返回状态。<br />如果这个变量的值为 0, 证明上一个命令正确执行；<br />如果这个变量的值为非 0(具体是哪个数, 由命令<br/>自己来决定), 则证明上一个命令执行不正确了</td></tr><tr><td>$$</td><td>当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号(PID)</td></tr></tbody></table><h2 id="四-通配符和正则表达式"><a href="#四-通配符和正则表达式" class="headerlink" title="四 : 通配符和正则表达式"></a>四 : 通配符和正则表达式</h2><h3 id="一-通配符"><a href="#一-通配符" class="headerlink" title="(一) 通配符"></a>(一) 通配符</h3><table><thead><tr><th>通配符</th><th>作 用</th><th>示例</th></tr></thead><tbody><tr><td>?</td><td>匹配一个任意字符</td><td></td></tr><tr><td>*</td><td>匹配 0 个或任意多个任意字符, 也就是可以匹配任何内容</td><td></td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符</td><td><code>[abc]</code> 代表一定匹配一个字符, 或者是 a, 或者是 b, 或者是 c</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符, <code>-</code>代表一个范围</td><td><code>[a-z]</code>代表匹配一个小写字母。</td></tr><tr><td>[^]</td><td>逻辑非, 表示匹配不是中括号内的一个字符</td><td><code>[^0-9]</code>代表匹配一个不是数字的字符</td></tr></tbody></table><h3 id="二-正则表达式-regex"><a href="#二-正则表达式-regex" class="headerlink" title="(二) 正则表达式(regex)"></a>(二) 正则表达式(regex)</h3><table><thead><tr><th>元字符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>前一个字符匹配 <strong>0 次或任意多次</strong></td><td><code>aa*</code> 查询a出现1次及以上</td></tr><tr><td><code>.</code></td><td>匹配除了换行符外<strong>任意一个</strong>字符</td><td><code>s..d</code> 会匹配在s和d这两个字母之间一定有两个字符的单词</td></tr><tr><td><code>^</code></td><td>匹配<strong>行首</strong></td><td><code>^hello</code> 会匹配以 hello 开头的行</td></tr><tr><td>$</td><td>匹配<strong>行尾</strong></td><td><code>hello$</code> 会匹配以 hello 结尾的行</td></tr><tr><td><code>[]</code></td><td>匹配中括号中指定的<strong>任意一个</strong>字符, 只匹配一个字符</td><td><code>[aeiou]</code> 匹配任意一个元音字母, <code>[0-9]</code> 匹配任意一位数字, <code>[a-z][0-9]</code>匹配小写字和一位数字构成的两位字符</td></tr><tr><td><code>[^]</code></td><td>匹配除中括号的字符以外的任意一个字符。</td><td><code>[^0-9]</code> 匹配任意一位非数字字符, <code>[^a-z]</code>表示任意一位非小写字母</td></tr><tr><td><code>\</code></td><td>转义符。用于取消特殊符号的含义</td><td><code>\.$</code> 查找以字符 <code>.</code> 结尾的行</td></tr><tr><td><code>\&#123;n\&#125;</code></td><td>表示其前面的字符恰好出现 n 次</td><td><code>[0-9]\&#123;4\&#125;</code> 匹配 4 位数字, <code>[1][3-8][0-9]\&#123;9\&#125;</code> 匹配手机号码</td></tr><tr><td><code>\&#123;n,\&#125;</code></td><td>表示其前面的字符出现不小于 n 次</td><td><code>[0-9]\&#123;2,\&#125;</code> 表示两位及以上的数字</td></tr><tr><td><code>\&#123;n,m\&#125;</code></td><td>表示其前面的字符至少出现n次, 最多出现m次</td><td><code>[a-z]\&#123;6,8\&#125;</code> 匹配 6~8 位的小写字母</td></tr></tbody></table><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="(三) 总结"></a>(三) 总结</h3><p>通常 : 正则表达式和通配符使用的场景是不同的</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>正则表达式</td><td>用来在<strong>文件内容</strong>中匹配符合条件的字符串</td></tr><tr><td>通配符</td><td>用来匹配符合条件的<strong>文件名</strong></td></tr></tbody></table><p>其实这种区别只在 Shell 当中适用, 因为用来在文件当中搜索字符串的命令, 如 <code>grep</code>, <code>awk</code>, <code>sed</code> 等命令可以<strong>支持正则</strong>表达式; 而在系统当中搜索文件的命令, 如 <code>ls</code>, <code>find</code>, <code>cp</code> 这些命令<strong>不支持正则</strong>表达式, 所以只能使用 shell 自己的通配符来进行匹配了</p><h2 id="五-常用指令"><a href="#五-常用指令" class="headerlink" title="五 : 常用指令"></a>五 : 常用指令</h2><p><code>grep</code>, <code>awk</code>, <code>sed</code> 也被称为Linux三剑客, <strong>grep主打查找功能</strong>，<strong>sed主要是编辑</strong>，<strong>awk主要是分割处理</strong>; 基础中的基础, 重点中的重点</p><h3 id="一-行提取-grep"><a href="#一-行提取-grep" class="headerlink" title="(一) 行提取 grep"></a>(一) 行提取 grep</h3><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# grep [选项] &quot;搜索内容&quot; 文件名<br>选项:<br>    -A 数字: 列出符合条件的行,并列出后续的n行 <br>    -B 数字: 列出符合条件的行,并列出前面的n行 <br>    -c: 统计找到的符合条件的字符串的次数<br>    -i: 忽略大小写<br>    -n: 输出行号<br>    -v: 反向查找<br>    --color=auto 搜索出的关键字用颜色显示<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找用户信息文件/etc/passwd 中, 有多少可以登录的用户</span><br>[root@localhost ~]# grep &quot;/bin/bash&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找包含有<span class="hljs-string">&quot;root&quot;</span>的行, 并列出后续的3行</span><br>[root@localhost ~]# grep -A 3 &quot;root&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找可以登录的用户, 并显示行号</span><br>[root@localhost ~]# grep -n &quot;/bin/bash&quot; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找不含有<span class="hljs-string">&quot;/bin/bash&quot;</span>的行, 其实就是列出所有的伪用户</span><br>[root@localhost ~]# grep -v &quot;/bin/bash&quot; /etc/passwd <br></code></pre></td></tr></table></figure><h3 id="二-文本截取-awk"><a href="#二-文本截取-awk" class="headerlink" title="(二) 文本截取 awk"></a>(二) 文本截取 awk</h3><p><code>awk</code> 是一个强大的文本分析工具, 相对于 <code>grep</code> 的查找, <code>sed</code> 的编辑, <code>awk</code> 在其<strong>对数据分析并生成报告</strong>时, 显得尤为强大。</p><p>简单来说<code>awk</code> 就是把文件<strong>逐行的读入</strong>, <strong>以空格</strong>为默认分隔符<strong>将每行切片</strong>, 切开的部分再进行各种分析处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;…&#x27; 文件名<br>条件(Pattern) : <br>    x &gt; 10 : 判断变量 x 是否大于 10<br>    x == y : 判断变量 x 是否等于变量 y<br>    A ~ B : 判断字符串 A 中是否包含能匹配 B 表达式的子字符串<br>    A !~ B : 判断字符串 A 中是否不包含能匹配 B 表达式的子字符串<br>动作(Action) : <br>    格式化输出<br>    流程控制语句<br></code></pre></td></tr></table></figure><p>awk 提供了一些内置变量</p><table><thead><tr><th>awk 内置变量</th><th>作用</th></tr></thead><tbody><tr><td><strong>$0</strong></td><td>代表目前 awk 所读入的整行数据。我们已知 awk 是一行一行读入数据的, $0 就代表当前读入行的整行数据</td></tr><tr><td><strong>$n</strong></td><td>代表目前读入行的第 n 个字段</td></tr><tr><td><strong>NF</strong></td><td>当前行拥有的字段(列)总数</td></tr><tr><td><strong>NR</strong></td><td>当前 awk 所处理的行, 是总数据的第几行</td></tr><tr><td><strong>FS</strong></td><td>用户定义分隔符。awk 的默认分隔符是任何空格, 如果想要使用其他分隔符(如” : “), 就需要 <code>FS</code> 变量定义</td></tr><tr><td>ARGC</td><td>命令行参数个数</td></tr><tr><td>ARGV</td><td>命令行参数数组</td></tr><tr><td>FNR</td><td>当前文件中的当前记录数(对输入文件起始为 1)</td></tr><tr><td>OFMT</td><td>数值的输出格式(默认为%.6g)</td></tr><tr><td>OFS</td><td>输出字段的分隔符(默认为空格)</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认为换行符)</td></tr><tr><td>RS</td><td>输入记录分隔符(默认为换行符)</td></tr></tbody></table><p>简单代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出第1列和第3列</span><br>[root@localhost ~]# df -h | awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询可以登录的用户的用户名和 UID</span><br>[root@localhost ~]# awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3 &#125;&#x27; /etc/passwd<br></code></pre></td></tr></table></figure><p>awk 还提供了保留字, 保留字可以看作是<u>条件的一种</u>, 必须大写</p><table><thead><tr><th>保留字</th><th>说明</th></tr></thead><tbody><tr><td><code>BEGIN</code></td><td>在 awk 程序一开始时,尚未读取任何数据之前执行; BEGIN 后的动作只在程序开始时执行一次</td></tr><tr><td><code>END</code></td><td>在 awk 程序处理完所有数据,即将结束时执行; END 后的动作只在程序结束时执行一次</td></tr></tbody></table><p>保留字代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">BEGIN和END都只会执行一次</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;开始&quot;&#125; &#123;print $1 &quot;:&quot; $3&#125; END&#123;print &quot;完毕&quot;&#125;&#x27; <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行,所以这个命令的换行不用加入<span class="hljs-string">&quot;\&quot;,就是一行命令</span></span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;BEGIN&#123;print &quot;统计开始:&quot;&#125; <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-string">&#123;print &quot;</span>系统分区<span class="hljs-string">&quot; <span class="hljs-variable">$1</span> &quot;</span>已使用:<span class="hljs-string">&quot; <span class="hljs-variable">$3</span>&#125; END&#123;print &quot;</span>统计完毕<span class="hljs-string">&quot;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>awk 的条件 : 关系运算符</p><table><thead><tr><th>条件</th><th>说明</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于。用于判断两个值是否相等,如果是给变量赋值,请使用<code>=</code>号</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>A~B</td><td>判断字符串 A 中是否包含能匹配 B 表达式的子字符串, 比字符串要加 <code>//</code>, 例如 : <code>$2 ~ /shell/</code></td></tr><tr><td>A!~B</td><td>判断字符串 A 中是否不包含能匹配 B 表达式的子字符串</td></tr></tbody></table><p>条件示例代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出使用大于0的分区及使用情况</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;$3&gt;0&#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出vda的使用情况</span><br>[root@localhost ~]# df -h | grep -v Used | awk &#x27;$1 ~ /vda/ &#123;print &quot;系统分区&quot; $1 &quot;已使用:&quot; $3&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果在//中可以写入字符,也可以支持正则表达式,查询包含有vda的行,并打印第一字段和第五字段</span><br>[root@localhost ~]# df -h | awk &#x27;/vda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125; &#x27;<br></code></pre></td></tr></table></figure><p>awk 流程控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">统计 PHP 成绩的总分</span> <br>[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; <br>NR==3&#123;php2=$3&#125; <br>NR==4&#123;php3=$3;totle=php1+php2+php3;print &quot;totle php is &quot; totle&#125;&#x27; awk_test.txt<br></code></pre></td></tr></table></figure><p><code>awk</code> 编程也允许在编程时使用函数(不常用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义函数<span class="hljs-built_in">test</span>,包含两个参数,函数体的内容是输出这两个参数的值</span><br>[root@localhost ~]# awk &#x27;function test(a,b) &#123; printf a &quot;\t&quot; b &quot;\n&quot; &#125; <br><span class="hljs-meta prompt_">#</span><span class="language-bash">调用函数 <span class="hljs-built_in">test</span>,并向两个参数传递值</span><br>&#123; test($2,$6) &#125; &#x27; student.txt<br></code></pre></td></tr></table></figure><p>awk 调用脚本<code>(-f)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编写脚本</span><br>[root@localhost ~]# vi pass.awk<br>BEGIN &#123;FS=&quot;:&quot;&#125;<br>&#123; print $1 &quot;\t&quot; $3&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用脚本 -f</span><br>[root@localhost ~]# awk -f pass.awk /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>在 <code>awk</code> 编程中,因为命令语句非常长, 在输入格式时需要注意以下内容 :</strong> </p><ul><li>多个 <code>条件&#123;动作&#125;</code> 可以用空格分割, 也可以用回车分割</li><li>在一个动作中, 如果需要执行多个命令, 需要用 <code>;</code> 分割, 或用回车分割</li><li>在 <code>awk</code> 中, 变量的赋值与调用都不需要加入 <code>$</code> 符</li><li>条件中判断两个值是否相同, 请使用<code>==</code>, 以便和变量赋值进行区分</li></ul><h3 id="三-文本操作-sed"><a href="#三-文本操作-sed" class="headerlink" title="(三) 文本操作 sed"></a>(三) 文本操作 sed</h3><p><code>sed</code> 主要是用来将数据进行<strong>选取</strong>, <strong>替换</strong>, <strong>删除</strong>, <strong>新增</strong>的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...<br>选项 : <br>    -n : 把经过sed处理的结果输出到屏幕(只查看sed命令操作的数据,如果不加则把所有数据都输出到屏幕)。<br>    -e : 允许对输入数据应用多条sed命令编辑,中间用&quot;;&quot;隔开。<br>    -r :  在 sed 中支持扩展正则表达式。<br>    -i :  用 sed 的修改结果直接修改读取数据的文件,而不是由屏幕输出<br>    -f 脚本文件名 : 从 sed 脚本中读入 sed 操作。和 awk 命令的 -f 非常类似。<br>动作 : <br>    a \ : 追加(append),在当前行后添加一行或多行; 添加多行时,除最后一行外,每行末尾需要用&quot;\&quot;代表数据未完结。<br>    c \ : 行替换(replace),用 c 后面的字符串替换原数据行; 替换多行时,除最后一行外,每行末尾需用&quot;\&quot;代表数据未完结<br>    i \ : 插入(insert),在当期行前插入一行或多行; 插入多行时,除最后一行外每行末尾需要用&quot;\&quot;代表数据未完结<br>    d :  删除(delete),删除指定的行<br>    p :  打印(print),输出指定的行<br>    s :  字串替换,用一个字符串替换另外一个字符串;格式为&quot;行范围s/旧字串/新字串/&quot;(和vim中的替换格式类似)<br></code></pre></td></tr></table></figure><ul><li><strong>注意 :</strong> <code>sed</code> 所做的修改并<strong>不会直接改变文件的内容</strong>(如果是用管道符接收的命令的输出,这种情况连文件都没有), 而是把修改结果只显示到屏幕上, <strong>除非使用 <code>-i</code> 选项才会直接修改文件</strong>。</li></ul><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印第二行</span><br>[root@localhost ~]# sed -n &#x27;2p&#x27; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除第二行到第四行的数据,但是文件本身并不会发生改变</span><br>[root@localhost ~]# sed &#x27;2,4d&#x27; /etc/passwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在第二行后加入hello</span><br>[root@localhost ~]# sed &#x27;2a hello&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果需要多插几行,则需要用\换行</span><br>[root@localhost ~]# sed &#x27;2a hello \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">world<span class="hljs-string">&#x27; /etc/passwd</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">在第二行前插入hello,如果需要插入多行也需要\</span></span><br><span class="hljs-string"><span class="language-bash">[root@localhost ~]# sed &#x27;</span>2i hello<span class="hljs-string">&#x27; /etc/passwd</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行数据替换掉</span></span><br>[root@localhost ~]# sed &#x27;2c hello world&#x27; /etc/passwd <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行的bin替换成hello</span></span><br>[root@localhost ~]# sed &#x27;2s/bin/hello/&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行注释掉</span></span><br>[root@localhost ~]# sed &#x27;2s/^/#/&#x27; /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">将第二行和第四行注释掉,用;隔开</span></span><br>[root@localhost ~]# sed &#x27;2s/bin/hello/;3s/daemon/world/&#x27; /etc/passwd<br></code></pre></td></tr></table></figure><h3 id="四-列提取-cut"><a href="#四-列提取-cut" class="headerlink" title="(四) 列提取 cut"></a>(四) 列提取 cut</h3><p>cut 命令的默认分隔符是制表符, 也就是 <code>tab</code> 键, <strong>不支持空格</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cut OPTION... [FILE]...<br>选项 : <br>-f column_number : 提取第几列<br>-d separate : 按照指定分隔符分割列(默认分隔符是制表符)<br>-c number : 不依赖分隔符来区分列,而是通过字符范围(行首为0)来进行字段提取(了解)<br>&quot;n-&quot;表示从第n个字符到行尾; <br>&quot;n-m&quot;从第n个字符到第m个字符; <br>&quot;-m&quot;表示从第1个字符到第m个字符。<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">提取第二列内容</span><br>[root@localhost ~]# cut -f 2 test.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">那如果想要提取多列呢? 只要列号直接用<span class="hljs-string">&quot;,&quot;</span>分开</span><br>[root@localhost ~]# cut -f 2,3 cut_test.txt <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询普通用户的用户名和用户ID</span><br>[yuelu@localhost ~]$ grep &quot;/bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1,3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">按照字符进行提取,c表示character,后面跟表达式,8-代表的是提取所有行的第8个字符开始到行尾(10-20代表提取所有行的第10个字符到第20个字符,-8代表提取所有行从行首到第8个字符)</span> <br>[root@localhost ~]# cut -c 8- cut_test.txt <br></code></pre></td></tr></table></figure><h3 id="五-排序命令-sort"><a href="#五-排序命令-sort" class="headerlink" title="(五) 排序命令 sort"></a>(五) 排序命令 sort</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# sort [选项] 文件名<br>选项 : <br>-f :  忽略大小写<br>-b :  忽略每行前面的空白部分<br>-n :  以数值型进行排序,默认使用字符串型排序<br>-r :  反向排序<br>-u :  删除重复行。就是 uniq 命令<br>-t :  指定分隔符,默认是分隔符是制表符<br>-k n[,m] :  按照指定的字段范围排序。从第n字段开始,m字段结束(默认到行尾)<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">排序用户信息文件,默认是用每行开头第一个字符来进行排序</span><br>[root@localhost ~]# sort /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">反向排序-r</span><br>[root@localhost ~]# sort -r /etc/passwd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定分隔符是<span class="hljs-string">&quot;:&quot;</span>,排序范围是第三个(用第三字段开头,第三字段结尾排序)</span><br>[root@localhost ~]# sort -t &quot;:&quot; -k 3,3 /etc/passwd<br></code></pre></td></tr></table></figure><h3 id="六-去重命令-uniq"><a href="#六-去重命令-uniq" class="headerlink" title="(六) 去重命令 uniq"></a>(六) 去重命令 uniq</h3><p><code>uniq</code> 命令是用来取消重复行的命令, 其实和 <code>sort -u</code> 选项是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# uniq [选项] 文件名<br>选项 : <br>-i :  忽略大小写<br></code></pre></td></tr></table></figure><h3 id="七-统计命令-wc"><a href="#七-统计命令-wc" class="headerlink" title="(七) 统计命令 wc"></a>(七) 统计命令 wc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# wc [选项] 文件名<br>选项 : <br>    -l : 只统计行数(print the newline counts)<br>    -w : 只统计单词数(print the word counts)<br>    -m : 只统计字符数(print the character counts)<br>    -c : print the byte counts<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器内存占用过高</title>
    <link href="/2023/01/20/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"/>
    <url>/2023/01/20/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-故障现象"><a href="#一-故障现象" class="headerlink" title="一 : 故障现象"></a>一 : 故障现象</h2><ul><li>服务器内存占用过高, 导致死机</li><li>服务器硬重启 3-5 天再次占满</li></ul><h2 id="二-问题排查"><a href="#二-问题排查" class="headerlink" title="二 : 问题排查"></a>二 : 问题排查</h2><ol><li><code>cpu</code> 使用率 : <code>top</code></li><li>定时任务 <code>crontab -l</code></li><li>文件的读取和写入 : <code>ftp</code>, <code>log</code></li></ol><h2 id="三-解决方案"><a href="#三-解决方案" class="headerlink" title="三 : 解决方案"></a>三 : 解决方案</h2><h3 id="一-手动清理"><a href="#一-手动清理" class="headerlink" title="(一) 手动清理"></a>(一) 手动清理</h3><ul><li><p>可手动清理页文件缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free pagecache:</span><br>echo 1 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li><li><p>清理可回收 slab 对象(slab 分配算法采用 cache 存储内核对象, 当需要内核数据结构的对象时, 可以直接从cache 上直接获取, 并将对象初始化为使用) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free reclaimable slab objects (includes dentries and inodes):</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">reclaimable: 可回收</span><br>echo 2 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li><li><p>清理 slab 对象和 pagecache</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">To free slab objects and pagecache:</span><br>echo 3 &gt; /proc/sys/vm/drop_caches<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-设置最低剩余内存"><a href="#二-设置最低剩余内存" class="headerlink" title="(二) 设置最低剩余内存"></a>(二) 设置最低剩余内存</h3><ul><li><p>修改 sysctl.conf 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后加入一行</span><br>vm.min_free_kbytes = 2097152<br></code></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -p</span><br></code></pre></td></tr></table></figure></li><li><p>第一种方法直接清空缓存, 可能会造成数据丢失, 我们选用第二种</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arthas</title>
    <link href="/2023/01/13/arthas/"/>
    <url>/2023/01/13/arthas/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><h3 id="一-概述-1"><a href="#一-概述-1" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p><code>Arthas</code> 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p><h3 id="二-背景"><a href="#二-背景" class="headerlink" title="(二) 背景"></a>(二) 背景</h3><p>通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 <code>IDE</code> 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。</p><p>开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。</p><p>如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 <code>JVM</code> 重新启动，它可能无法复现，如上文所述。</p><p><code>Arthas</code> 旨在解决这些问题。开发人员可以在线解决生产问题。无需 <code>JVM</code> 重启，无需代码更改。 <code>Arthas</code> 作为观察者永远不会暂停正在运行的线程。</p><h3 id="三-用途"><a href="#三-用途" class="headerlink" title="(三) 用途"></a>(三) 用途</h3><p><code>Arthas</code> 是 Alibaba 开源的 Java 诊断工具。当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li><li>怎样直接从 JVM 内查找某个类的实例？</li></ol><h2 id="二-快速入门"><a href="#二-快速入门" class="headerlink" title="二 : 快速入门"></a>二 : 快速入门</h2><h3 id="一-下载启动"><a href="#一-下载启动" class="headerlink" title="(一) 下载启动"></a>(一) 下载启动</h3><ul><li><p>下载 jar 包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl -O https://arthas.aliyun.com/arthas-boot.jar<br></code></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行该程序的用户需要和目标进程具有相同的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以执行如下命令来查看帮助</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java -jar arthas-boot.jar -h</span><br></code></pre></td></tr></table></figure></li><li><p>选择应用 : 数据对应程序的编号, 然后回车即可</p></li><li><p>未进入指定程序退出 : <code>ctrl + c</code></p></li><li><p>进入指定程序后退出 : <code>ctrl + d</code></p></li></ul><h3 id="二-常用操作"><a href="#二-常用操作" class="headerlink" title="(二) 常用操作"></a>(二) 常用操作</h3><ul><li><p>dashboard : 选择指定程序后, 输入 <code>dashboard</code> 后回车, 即可进入看板, 按 <code>ctrl+c </code>可以中断执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ dashboard<br></code></pre></td></tr></table></figure><ul><li>主要涉及到当前执行的线程, 内存情况和运行环境</li></ul></li><li><p>thread : 查看当前线程, 命令 : <code>thread ID</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ thread 1 | grep <span class="hljs-string">&#x27;main(&#x27;</span><br>    at demo.MathGame.main(MathGame.java:17)<br></code></pre></td></tr></table></figure></li><li><p>jad : 反编译工具, 通过 jad 来反编译 Main Class</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ jad demo.MathGame<br></code></pre></td></tr></table></figure></li><li><p>watch : 查看具体函数的参数和返回值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ watch demo.MathGame primeFactors returnObj<br></code></pre></td></tr></table></figure></li></ul><h3 id="三-退出"><a href="#三-退出" class="headerlink" title="(三) 退出"></a>(三) 退出</h3><ul><li>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</li><li>如果想完全退出 arthas，可以执行<code>stop</code>命令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诊断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql数据统计</title>
    <link href="/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/01/06/mysql%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-库表结构"><a href="#一-库表结构" class="headerlink" title="一 : 库表结构"></a>一 : 库表结构</h2><ul><li><p>MySQL 的 information_schema 数据库, 保存着数据库的容量和使用信息, 可查询数据库中每个表占用的空间, 表记录的行数</p></li><li><p>TABLES 表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> `TABLES` (<br>  `TABLE_CATALOG` <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_SCHEMA` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_NAME` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `TABLE_TYPE` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `ENGINE` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `VERSION` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `ROW_FORMAT` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_ROWS` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `AVG_ROW_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `DATA_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `MAX_DATA_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `INDEX_LENGTH` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `DATA_FREE` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `AUTO_INCREMENT` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CREATE_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `UPDATE_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CHECK_TIME` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_COLLATION` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CHECKSUM` <span class="hljs-type">bigint</span>(<span class="hljs-number">21</span>) unsigned <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `CREATE_OPTIONS` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TABLE_COMMENT` <span class="hljs-type">varchar</span>(<span class="hljs-number">2048</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span><br>) ENGINE<span class="hljs-operator">=</span>MEMORY <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure></li><li><p>重点字段说明</p><table><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td>TABLE_SCHEMA</td><td>数据库名</td></tr><tr><td>TABLE_NAME</td><td>表名</td></tr><tr><td>ENGINE</td><td>存储引擎</td></tr><tr><td>TABLE_ROWS</td><td>记录数</td></tr><tr><td>DATA_LENGTH</td><td>数据大小(单位B)</td></tr><tr><td>INDEX_LENGTH</td><td>索引大小</td></tr></tbody></table></li></ul><h2 id="二-查询示例"><a href="#二-查询示例" class="headerlink" title="二 : 查询示例"></a>二 : 查询示例</h2><h3 id="一-数据总占用量"><a href="#一-数据总占用量" class="headerlink" title="(一) 数据总占用量"></a>(一) 数据总占用量</h3><ul><li><p>求和 &#x3D;&gt; 单位转换 &#x3D;&gt; 加单位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>concat(round(<span class="hljs-built_in">sum</span>(DATA_LENGTH<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>),<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;GB&#x27;</span>) <span class="hljs-keyword">as</span> data <br><span class="hljs-keyword">from</span> information_schema.TABLES<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-每个表占用量"><a href="#二-每个表占用量" class="headerlink" title="(二) 每个表占用量"></a>(二) 每个表占用量</h3><ul><li><p>table_name, table_rows, data_length</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>table_name, <br>concat(round(<span class="hljs-built_in">sum</span>(data_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>),<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;G&#x27;</span>) <span class="hljs-keyword">as</span> data <br><span class="hljs-keyword">from</span> information_schema.tables <br><span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbname&#x27;</span> <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> table_name <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> data <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/27/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/12/27/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title：docker基础概念excerpt：通过基础概念加深对其架构的理解date：2021-01-08categories：容器化技术tags：-docker，docker入门"><a href="#title：docker基础概念excerpt：通过基础概念加深对其架构的理解date：2021-01-08categories：容器化技术tags：-docker，docker入门" class="headerlink" title="title：docker基础概念excerpt：通过基础概念加深对其架构的理解date：2021-01-08categories：容器化技术tags：[docker，docker入门]"></a>title：docker基础概念<br>excerpt：通过基础概念加深对其架构的理解<br>date：2021-01-08<br>categories：容器化技术<br>tags：[docker，docker入门]</h2><h2 id="一：docker-是什么"><a href="#一：docker-是什么" class="headerlink" title="一：docker 是什么"></a>一：docker 是什么</h2><p>官网地址：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>官方文档：<a href="https://docs.docker.com、https//dockerdocs.cn/">https://docs.docker.com、https://dockerdocs.cn/</a></p><p>docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。</p><p>docker 项目后来还加入了 Linux 基金会，并成立推动 <strong>OCI</strong> (开放容器联盟)。</p><p>docker 使用 Google 公司退出的 <strong>Go 语言</strong> 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</p><p>由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为<strong>容器</strong>。</p><p>docker 在容器的基础上，进行了进一步的封装，从文件系统，网络互联到进程隔离等等，极大的简化了容器的创建和维护；使得 <strong>docker 技术比虚拟机技术更为轻便，快捷</strong>。</p><table><thead><tr><th>传统虚拟机</th><th>docker</th></tr></thead><tbody><tr><td>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</td><td>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟；因此容器要比虚拟机更为轻便</td></tr></tbody></table><h2 id="二：为什么要使用-docker"><a href="#二：为什么要使用-docker" class="headerlink" title="二：为什么要使用 docker"></a>二：为什么要使用 docker</h2><p>docker 的优势有：更高效的利用系统资源，更快速的启动时间，一致的运行环境，持续交付的部署，更轻松的迁移，更轻松的维护和扩展。</p><p>对比传统虚拟机</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>较弱</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="三：docker-架构"><a href="#三：docker-架构" class="headerlink" title="三：docker 架构"></a>三：docker 架构</h2><p>docker 使用客户端-服务器(C&#x2F;S)架构模式，使用远程API来管理和创建 docker 容器。</p><pre><code class=" mermaid">graph TBsubgraph A[Client]A1[docker run]A2[docker build]A3[docker pull]endsubgraph B[Docker Host]B1[Docker Daemon]B2[Images]B3[Containers]endsubgraph C[Registry]C1[Images]C2[Extensions]C3[Plugins]endA1 &amp; A2 &amp; A3 --&gt; B1 --&gt; B2 &amp; C1B2 --&gt; B3C1 --&gt; B2</code></pre><h2 id="四：docker-基本概念"><a href="#四：docker-基本概念" class="headerlink" title="四：docker 基本概念"></a>四：docker 基本概念</h2><p>docker 包括三个基本概念：镜像(image)、容器(container)、仓库(repository)；理解了这三个概念，就理解了 docker 的整个生命周期。</p><h3 id="一-docker-镜像"><a href="#一-docker-镜像" class="headerlink" title="(一) docker 镜像"></a>(一) docker 镜像</h3><p>我们都知道，操作系统分为内核和用户空间，对于 linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持；而 docker 镜像(image)，就相当于是一个 root 文件系统，比如官方镜像 centos:7.6 就包含了完整的一套 centos 7.6 最小系统的 root 文件系统。</p><p>docker image 是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)；镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>因为 image 包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此 docker 设计时将其设计为<strong>分层存储的架构</strong>；image 只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说<strong>由多重文件系统联合组成</strong>。</p><p>image 构建时，会一层层构建，前一层是后一层的基础；每一次构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层；在构建 image 的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p><strong>分层存储的特征还使得 image 的复用以及定制变的更为容易</strong>；甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="二-docker-容器"><a href="#二-docker-容器" class="headerlink" title="(二) docker 容器"></a>(二) docker 容器</h3><p>镜像(image)和容器(container)的关系，就像 java 中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>；container 可以被创建、启动、停止、删除、暂停等。</p><p>image 使用的是<strong>分层存储</strong>，容器也是如此；每一个 container 运行时，是以 image 为基础层，在其上创建一个当前 container 的存储层，我们可以称这个为 container 运行时读写而准备的存储层为<strong>容器存储层</strong>。容器存储层的生成周期和 container 一致，container 消亡时，容器存储层也随之消亡；因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 docker 最佳实践的要求，container 不应该向其存储层内写入任何数据，容器存储层要保持无状态化；<strong>所有的文件写入操作，都应该使用数据卷(Volume)或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。Volume 的生存周期独立于容器，容器消亡，数据卷不会消亡；因此，使用数据卷后，容器删除或者重新运行之后，数据不会丢失。</p><h3 id="三-docker-仓库"><a href="#三-docker-仓库" class="headerlink" title="(三) docker 仓库"></a>(三) docker 仓库</h3><p>image 构建完成后，可以很容易的在当前宿主机上运行。但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，docker registry 就是这样的服务。一个 docker registry 中可以包含多个仓库(repository)；每个仓库可以包含多个标签(tag)；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而<strong>标签就常用于对应软件的各个版本</strong>；我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像；如果不给出标签，将以 latest 作为默认标签；以 centos 镜像为例，centos 是仓库的名字，其内包含不同的版本标签，如：6.9、7.5；我们可以通过  centos:6.9 或者 centos:7.5 来具体指定所需哪个版本的镜像；如果忽略了标签，比如 centos，那将是为 centos:latest。</p><p><strong>仓库名经常以两段式路径形式出现，比如 study&#x2F;nginx</strong>，前者往往意味着 docker registry 多用户环境下的用户名，后者则往往是对应的软件名；但这并非绝对，取决于所使用的具体 docker registry 的软件或服务。</p><p><strong>1：公开仓库</strong></p><p>常用的 registry 是官方的 <a href="https://hub.docker.com/">docker hub</a>，这也是默认的 registry；除此之外，还有 CoreOS 的 Quay.io， CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。</p><p>国内的一些云服务商提供了针对 docker hub 的镜像服务，这些镜像服务被称为加速器；常见的有<strong>阿里云加速器</strong>，<strong>DaoCloud加速器</strong>等；使用加速器会直接从国内的地址下载 docker hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于 docker hub 的公开服务；比如<strong>网易云镜像服务</strong>，<strong>DaoCloud镜像市场</strong>，<strong>阿里云镜像库</strong>等。</p><p><strong>2：私有 docker registry</strong></p><p>除了使用公开服务外，用户还可以在本地搭建私有 docker registry；docker 官方提供了 docker registry 镜像，可以直接使用作为私有 registry 服务。</p><p>开源的 docker registry 镜像只提供了 docker registry API 的服务端实现，足以支持 docker 命令，不影响使用；但不包含图形界面以及镜像维护、用户管理、访问控制等高级功能；在官方的商业化版本 docker trusted registry 中，提供了这些高级功能。</p><p>除了官方的 docker registry 外，还有第三方软件实现了 docker registry API，甚至提供了用户界面以及一些高级功能；比如 VMWare Harbor 和 Sonatype Nexus 等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2021/04/30/3_kafka/"/>
    <url>/2021/04/30/3_kafka/</url>
    
    <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一 :"></a>一 :</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2021/04/23/2_kafka/"/>
    <url>/2021/04/23/2_kafka/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><h2 id="二-单机部署"><a href="#二-单机部署" class="headerlink" title="二 : 单机部署"></a>二 : 单机部署</h2><p>下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span><br>wget https://archive.apache.org/dist/kafka/2.8.0/kafka_2.12-2.8.0.tgz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -xf kafka_2.12-2.8.0.tgz<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim config/server.properties<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 集群部署broker的id不可重复,单机部署无所谓</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># 服务监听地址,如需对外提供访问需配置服务器IP</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://10.0.0.10:9092</span><br><span class="hljs-comment"># 日志位置,改不改都可以</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/tmp/kafka-logs</span><br><span class="hljs-comment"># 开启直接删除topic功能</span><br><span class="hljs-attr">delete.topic.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># zk地址,集群以&quot;,&quot;隔开,localhost:2181,localhost:2182,localhost:2183</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">localhost:2181</span><br></code></pre></td></tr></table></figure><p>启动停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动kafka,后台运行</span><br>bin/kafka-server-start.sh -daemon config/server.properties<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止kafka</span><br>bin/kafka-server-stop.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还有一个小型的zk</span><br>bin/zookeeper-server-start.sh -daemon config/zookeeper.properties<br></code></pre></td></tr></table></figure><h2 id="三-集群部署"><a href="#三-集群部署" class="headerlink" title="三 : 集群部署"></a>三 : 集群部署</h2><h2 id="四-配置选项"><a href="#四-配置选项" class="headerlink" title="四 : 配置选项"></a>四 : 配置选项</h2><h2 id="五-常用命令"><a href="#五-常用命令" class="headerlink" title="五 : 常用命令"></a>五 : 常用命令</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper简单尝试</title>
    <link href="/2021/04/16/1_zookeeper/"/>
    <url>/2021/04/16/1_zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>官网地址：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p>Zookeeper 是一个开源的分布式框架，提供了协调分布式应用的基本服务。它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度。</p><p>它是 Google 的 Chubby 一个开源的实现。它本身可以搭建成一个集群，这个 ZK 集群用来对应用程序集群进行管理，监视应用程序集群中各个节点的状态，并根据应用程序集群中各个节点提交的反馈信息决定下一步的合理操作。</p><pre><code class=" mermaid">graph BTsubgraph Zookeeper ServiceA2[Server] &amp; A3[Server] &amp; A4[Server] &amp; A5[Server] --&gt; A1[&quot;Server&lt;br&gt;(Leader)&quot;]endB1[Clinet] &amp; B2[Clinet] &amp; B3[Clinet] --&gt; A2B4[Clinet] --&gt; A3B5[Clinet] &amp; B6[Clinet] --&gt; A4B7[Clinet] &amp; B8[Clinet] --&gt; A5</code></pre><h2 id="二-单体部署"><a href="#二-单体部署" class="headerlink" title="二 : 单体部署"></a>二 : 单体部署</h2><p>下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -zxf apache-zookeeper-3.7.0-bin.tar.gz<br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span><br>cp conf/zoo_sample.cfg conf/zoo.cfg<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">心跳单位时间,最小会话超时是tickTime的2倍</span><br>tickTime=2000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">数据文件位置</span><br>dataDir=/var/lib/zookeeper<br><span class="hljs-meta prompt_"># </span><span class="language-bash">端口号,用于监听客户端连接</span><br>clientPort=2181<br></code></pre></td></tr></table></figure><p>启动停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/zkServer.sh &#123;start|stop|restart|status&#125;<br></code></pre></td></tr></table></figure><h2 id="三-集群部署"><a href="#三-集群部署" class="headerlink" title="三 : 集群部署"></a>三 : 集群部署</h2><p>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">tickTime=2000<br>dataDir=/var/lib/zookeeper<br>clientPort=2181<br>initLimit=5<br>syncLimit=2<br>server.1=zoo1:2888:3888<br>server.2=zoo2:2888:3888<br>server.3=zoo3:2888:3888<br></code></pre></td></tr></table></figure><h2 id="四-配置选项"><a href="#四-配置选项" class="headerlink" title="四 : 配置选项"></a>四 : 配置选项</h2><p><strong>tickTime :</strong> zookeeper 中使用的基本时间单位，毫秒值，比如可以设为1000，那么基本时间单位就是1000ms，也就是1s。</p><p><strong>initLimit :</strong> zookeeper 集群中的包含多台 server，其中一台为 leader，集群中其余的 server 为 follower，initLimit 参数配置初始化连接时，follower 和 leader 之间的最长心跳时间。如果该参数设置为 5，就说明时间限制为 5 倍 tickTime，即 5*1000&#x3D;5000ms&#x3D;5s。</p><p><strong>syncLimit :</strong> 该参数配置 leader 和 follower 之间发送消息，请求和应答的最大时间长度。如果该参数设置为2，说明时间限制为2倍tickTime，即2000ms。</p><p><strong>dataDir :</strong> 数据目录. 可以是任意目录，一般是节点安装目录下data目录。</p><p><strong>dataLogDir :</strong> log目录, 同样可以是任意目录，一般是节点安装目录下的logs目录。如果没有设置该参数，将使用和dataDir相同的设置。</p><p><strong>clientPort :</strong> 监听client连接的端口号。</p><p><strong>server.X&#x3D;A:B:C</strong> 其中 X 是一个数字, 表示这是第几号 server，它的值和 myid 文件中的值对应。A 是该 server 所在的 IP 地址。B 是配置该 server 和集群中的 leader 交换消息所使用的端口。C配置选举 leader 时所使用的端口。</p><h2 id="五-常用命令"><a href="#五-常用命令" class="headerlink" title="五 : 常用命令"></a>五 : 常用命令</h2><p>连接zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/zkCli.sh -server localhost:2181<br></code></pre></td></tr></table></figure><p>查看帮助命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help<br></code></pre></td></tr></table></figure><p>创建znode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create /zk_test hello<br></code></pre></td></tr></table></figure><p>查看znode内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">get /zk_test<br></code></pre></td></tr></table></figure><p>设置znode内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set /zk_test<br></code></pre></td></tr></table></figure><p>删除znode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">delete /zk_test<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>Kafka</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka理论基础</title>
    <link href="/2021/04/09/kafka%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/09/kafka%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>Kafka 是 Linkedin 使用 Scala 编写具有高水平扩展和高吞吐量的分布式消息系统。Scala 语言处理并发能力强。</p><p>官网地址 : <a href="https://kafka.apache.org/">https://kafka.apache.org/</a></p><p>Kafka 对消息保存时根据 Topic 进行归类，发送消息者成为 Producer，消息接受者成为 Consumer，此外 Kafka 集群有多个 Kafka 实例组成，每个实例(server)称为 broker。</p><p>无论是 Kafka 集群，还是 producer 和 consumer 都依赖于 zookeeper 来保证系统可用性，为集群保存一些 meta 信息。</p><p><strong>主流 MQ 对比</strong></p><table><thead><tr><th></th><th>AciveMQ</th><th>RabbitMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>所属社区&#x2F;公司</td><td>Apache</td><td>Mozilla Public License</td><td>Apache&#x2F;Linkedin</td></tr><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Scala</td></tr><tr><td>支持的协议</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>AMQP</td><td>仿AMQP</td></tr><tr><td>事务</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>集群</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>负载均衡</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>动态扩容</td><td>不支持</td><td>不支持</td><td>支持(zk)</td></tr></tbody></table><p><strong>主要功能</strong> : Apache Kafka是一个分布式流处理平台</p><p>流处理平台特性</p><ul><li>可以让你发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似。</li><li>可以储存流式的记录，并且有较好的容错性。</li><li>可以在流式记录产生时就进行处理。</li></ul><p>Kafka 适合什么样的场景?</p><ul><li><p>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。(相当于消息队列)</p></li><li><p>构建实时流式应用程序，对这些流数据进行转换或者影响。</p></li></ul><h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二 : 设计思路"></a>二 : 设计思路</h2><p>重要概念</p><ul><li>Kafka 作为一个集群运行在一个或多个服务器上</li><li>Kafka 通过 topic对存储的流数据进行分类</li><li>每条记录中包含一个 key，一个 value 和一个 timestamp (时间戳)</li></ul><p>核心API</p><ul><li>Producer API : 允许一个应用程序发布一串流式的数据到一个或者多个 Kafka topic。</li><li>Consumer API : 允许一个应用程序订阅一个或多个 topic，并且对发布给他们的流式数据进行处理。</li><li>Streams API : 允许一个应用程序作为一个流处理器，消费一个或者多个 topic 产生的输入流，然后生产一个输出流到一个或多个 topic 中去，在输入输出流中进行有效的转换。</li><li>Connector API : 允许构建并运行可重用的生产者或者消费者，将 Kafka topics 连接到已存在的应用程序或者数据系统。比如，连接到一个关系型数据库，捕捉表(table)的所有变更内容。</li></ul><p>在Kafka中，客户端和服务器之间的通信是通过简单，高性能，语言无关的 TCP 协议完成的。此协议已版本化并保持与旧版本的向后兼容性。Kafka提供多种语言客户端。</p><pre><code class=" mermaid">flowchart TDD1[DB] --&gt; A --&gt; D2[DB]B1[App] &amp; B2[App] &amp; B3[App]--&gt; A[Kafka Cluster] --&gt; C1[App] &amp; C2[App] &amp; C3[App]E1[App] &lt;--&gt; A &lt;--&gt; E2[App]subgraph B[Producers]B1 &amp; B2 &amp; B3endsubgraph C[Consumers]C1 &amp; C2 &amp; C3endsubgraph D[Connectors]D1 &amp; D2endsubgraph E[Stream Processors]E1 &amp; E2end</code></pre><h2 id="三-核心概念"><a href="#三-核心概念" class="headerlink" title="三 : 核心概念"></a>三 : 核心概念</h2><p><strong>AMQP 协议</strong></p><ul><li><p>消费者(Consumer) : 从消息队列中请求消息的客户端应用程序</p></li><li><p>生产者 (Producer) : 向 broker 发布消息的客户端应用程序</p></li><li><p>AMOP服务器端 (broker) : 用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p></li></ul><pre><code class=" mermaid">graph LRA[producer] --push---&gt; B[broker] --pull---&gt; C[consumer]</code></pre><p><strong>Topics</strong> </p><ul><li>Topic就是数据主题，是数据记录发布的地方，可以用来区分业务系统。Kafka 中的 Topics 总是多订阅者模式，一个 topic 可以拥有一个或者多个消费者来订阅它的数据。</li><li>对于每一个topic，Kafka集群都会维持一个分区(partition)日志，分区数据不一定是实时同步的。</li></ul><pre><code class=" mermaid">graph TBsubgraph A[Partition 0]A1[1] &amp; A2[2] &amp; A3[3] &amp; A4[4] &amp; A5[5]endsubgraph B[Partition 1]B1[1] &amp; B2[2] &amp; B3[3]endsubgraph C[Partition 2]C1[1] &amp; C2[2] &amp; C3[3] &amp; C4[4] &amp; C5[5]endD[Writes] --&gt; A5D[Writes] --&gt; B3D[Writes] --&gt; C5</code></pre><p><strong>Partition</strong></p><pre><code class=" mermaid">graph TBsubgraph A[Partition]012345endB[Producers] --writes--&gt; 52 --reads--&gt; C[&quot;Consumer A&lt;br&gt;(offset=2)&quot;]4 --reads--&gt; D[&quot;Consumer B&lt;br&gt;(offset=4)&quot;]</code></pre><p><strong>Distribution</strong></p><ul><li>Log 的分区被分布到集群中的多个服务器上，每个服务器处理它分到的分区，根据配置每个分区还可以复制到其它服务器作为备份容错。</li><li>每个分区有一个 leader，零或多个 follower。Leader 处理此分区的所有的读写请求，而 follower 被动的复制数据。如果 leader 宕机，其它的一个 follower 会被推举为新的 leader。一台服务器可能同时是一个分区的 leader，另一个分区的 follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</li></ul><p><strong>Producers</strong></p><ul><li>生产者往某个Topic上发布消息，生产者也负责选择发布到Topic上的哪一个分区。</li><li>最简单的方式从分区列表中轮流选择，也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</li></ul><p><strong>Consumers</strong></p><ul><li>消费者使用一个消费组名称来进行标识，发布到topic 中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。</li><li>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到每一个消费者实例。</li><li>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程</li></ul><pre><code class=" mermaid">flowchart TBsubgraph A[Kafka Cluster]    subgraph A1[Server 1]    P0 &amp; P1    end    subgraph A2[Server 2]    P2 &amp; P3    endendsubgraph C[Consumer Group B]C3 &amp; C4 &amp; C5 &amp; C6endsubgraph B[Consumer Group A]C1 &amp; C2endP0 --&gt; C1 &amp; C3P1 --&gt; C1 &amp; C4P2 --&gt; C2 &amp; C5P3 --&gt; C2 &amp; C6</code></pre><p><strong>Replication</strong> </p><ul><li>备份，为了保证分布式可靠性，kafka0.8开始对每个分区的数据进行备份 (不同Broker上) ，防止其中一个Broker宕机造成分区数据不可用</li></ul><pre><code class=" mermaid">flowchart LRsubgraph A[Producer]A1[&quot;Front End(前端程序)&quot;]A2[&quot;Front End(前端程序)&quot;]A3[Service]endsubgraph B[Kafka Cluster]subgraph B1[Broker-0]B11[Partition-0]B12[&quot;Partition-2&lt;br&gt;(replication)&quot;]endsubgraph B2[Broker-1]B21[Partition-1]B22[&quot;Partition-0&lt;br&gt;(replication)&quot;]endsubgraph B3[Broker-2]B31[Partition-2]B32[&quot;Partition-1&lt;br&gt;(replication)&quot;]endendsubgraph C[Consumer]C1[Hadoop Cluster]C2[Real-time&lt;br&gt;Monitor]C3[Other Service]C4[Data&lt;br&gt;Warehouse]endA1 --push--&gt; B1 --pull--&gt; C1A2 --push--&gt; B2 --pull--&gt; C2B2 --pull--&gt; C3A3 --push--&gt; B3 --pull--&gt; C4subgraph D[Zookeeper Cluster]D1[Zookeeper-0]D2[Zookeeper-1]D3[Zookeeper-2]endB1 &amp; B2 &amp; B3 -.- D -.- C1 &amp; C2 &amp; C3 &amp; C4</code></pre><h2 id="四-使用场景"><a href="#四-使用场景" class="headerlink" title="四 : 使用场景"></a>四 : 使用场景</h2><p><strong>消息</strong></p><ul><li>Kafka 更好的替换传统的消息系统，消息系统被用于各种场景 (如解耦数据生产者，缓存未处理的消息)，与大多数消息系统比较，Kafka 有更好的吞吐量、内置分区、副本和故障转移等功能，这有利于处理大规模的消息。</li><li>根据官方的经验，通常消息传递使用较低的吞吐量，但可能要求较低的端到端延迟，Kafka 提供强大的持久性来满足这一要求。</li><li>在这方面，Kafka可以与传统的消息传递系统 (ActiveMO和 RabbitMO) 相媲美。</li></ul><p><strong>跟踪网站活动</strong></p><ul><li>Kafka 的最初始作用就是是将用户活动跟踪管道重建为一组实时发布-订阅源。把网站活动(浏览网页、搜索或其他的用户操作)发布到中心topic，其中每个活动类型有一个 topic。这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。</li><li>每个用户浏览网页时都生成了许多活动信息，因此活动跟踪的数据量通常非常大。(Kafka实际应用)</li></ul><p><strong>日志聚合</strong></p><ul><li>许多人使用 Kafka 来替代日志聚合解决方案。<u>日志聚合系统</u>通常从服务器收集物理日志文件，并将其置于一个中心系统(可能是文件服务器或HDFS) 进行处理。</li><li>Kafka 从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗</li><li>与Scribe 或Flume 等以日志为中心的系统相比，<u>Kafka具备同样出色的性能、更强的耐用性(因为复制功能)和更低的端到端延迟</u>。</li></ul><p><strong>流处理</strong></p><ul><li>从0.10.0.0开始，Kafka 支持轻量，但功能强大的流处理。</li><li>Kafka 消息处理包含多个阶段。其中原始输入数据是从 kafka 主题消费的，然后汇总，丰富，或者以其他的方式处理转化为新主题以供进一步消费或后续处理。例如，一个推荐新闻文章，文章内容可能从“articles”主题获取，然后进一步处理内容，得到一个处理后的新内容，最后推荐给用户。这种处理是基于单个主题的实时数据流。</li><li>除了 Kafka Streams，还有 Apache Storm 和 Apache Samza 也是不错的流处理框架。</li></ul><p><strong>事件采集</strong></p><ul><li>Event sourcing 是一种应用程序设计风格，按时间来记录状态的更改。 </li><li>Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。</li></ul><p><strong>提交日志</strong></p><ul><li>Kafka 可以从外部为分布式系统提供日志提交功能。</li><li>日志有助于记录节点和行为间的数据,采用重新同步机制可以从失败节点恢复数据。 </li><li>Kafka 的日志压缩功能支持这一用法。这一点与 Apache BookKeeper 项目类似。</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java内存缓存</title>
    <link href="/2021/04/02/java%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/"/>
    <url>/2021/04/02/java%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-缓存介绍"><a href="#一-缓存介绍" class="headerlink" title="一 : 缓存介绍"></a>一 : 缓存介绍</h2><p>在计算中, 缓存是一个高速数据存储层, 其中存储了数据子集, 且通常是短暂性存储, 这样日后再次请求此数据时, 速度要比访问数据的主存储位置快。通过缓存, 您可以高效地重用之前检索或计算的数据。</p><p><strong>为什么要用缓存?</strong></p><ul><li>提升应用程序性能 : 内存比磁盘性能高很多</li><li>降低数据库成本 : 以8c16g为例, mysql 可以支持 2w&#x2F;s 的读取速度, 而使用缓存则可以支持 20w&#x2F;s 甚至是 200w&#x2F;s</li><li>减少后端负载 : 有效减少 Connection 的数量</li><li>可预测的性能</li><li>消除数据库热点 : 数据库中经常被访问的数据</li><li>提高读取吞吐量(IOPS) : 无论是数据库还是程序的吞吐量都会有明显提高</li></ul><h2 id="二-java自研缓存"><a href="#二-java自研缓存" class="headerlink" title="二 : java自研缓存"></a>二 : java自研缓存</h2><p>在Java应用中, 对于访问频率高, 更新少的数据, 通常的方案是将这类数据加入缓存中。相对从数据库中读取来说, 读缓存效率会有很大提升。</p><p>在集群环境下, 常用的分布式缓存有 Redis、Memcached 等。但在某些业务场景上, 可能不需要去搭建一套复杂的分布式缓存系统, 在单机环境下, 通常是会希望使用内部的缓存 (LocalCache) 。</p><p><strong>实现方案 :</strong></p><ul><li>基于 JSR107 规范自研</li><li>基于 ConcurrentHashMap 实现数据缓存</li></ul><p>代码示例 : 实现一个简单的缓存功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.使用ConcurrentHashMap满足线程安全的要求</span><br><span class="hljs-comment"> * 2.使用SoftReference&lt;Object&gt;作为映射值,软引用可以保证在抛出OutOfMemory之前,如果缺少内存,将删除引用的对象</span><br><span class="hljs-comment"> * 3.设置缓存清理机制:定时清理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheUtils</span> &#123;<br>    <span class="hljs-comment">// 定义缓存容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, SoftReference&lt;CacheObject&gt;&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 每5秒扫描一次并清理过期的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CLEAN_UP_PERIOD_IN_SEC</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">cleanerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(CLEAN_UP_PERIOD_IN_SEC * <span class="hljs-number">1000</span>);<br>                    cache.entrySet().removeIf(entry -&gt; Optional.ofNullable(entry.getValue())<br>                                              .map(SoftReference::get)<br>                                              .map(CacheObject::isExpired)<br>                                              .orElse(<span class="hljs-literal">false</span>)<br>                                             );<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        cleanerThread.setDaemon(<span class="hljs-literal">true</span>);<br>        cleanerThread.start();<br>    &#125;<br>    <span class="hljs-comment">// 定义缓存对象,设置过期时间</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheObject</span> &#123;<br>        <span class="hljs-keyword">private</span> Object value;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> expiryTime;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">CacheObject</span><span class="hljs-params">(Object value, <span class="hljs-type">long</span> expiryTime)</span> &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.expiryTime = expiryTime;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpired</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> System.currentTimeMillis() &gt; expiryTime;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String key, Object value, <span class="hljs-type">long</span> periodInMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            cache.remove(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">expiryTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + periodInMillis;<br>            cache.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheObject</span>(value, expiryTime)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> &#123;<br>        cache.remove(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(cache.get(key))<br>            .map(SoftReference::get)<br>            .filter(cacheObject -&gt; !cacheObject.isExpired())<br>            .map(CacheObject::getValue)<br>            .orElse(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        cache.clear();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.entrySet().stream()<br>            .filter(entry -&gt; Optional.ofNullable(entry.getValue())<br>                    .map(SoftReference::get)<br>                    .map(cacheObject -&gt; !cacheObject.isExpired())<br>                    .orElse(<span class="hljs-literal">false</span>)<br>                   )<br>            .count();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-guava缓存-推荐"><a href="#三-guava缓存-推荐" class="headerlink" title="三 : guava缓存(推荐)"></a>三 : guava缓存(推荐)</h2><p>Guava Cache 是 google guava 中的一个内存缓存模块, 用于将数据缓存到JVM内存中。</p><p>实际项目开发中经常将一些公共或者常用的数据缓存起来方便快速访问, 例如 : </p><ul><li>愿意消耗一些内存空间来提升速度</li><li>预料到某些键会被查询一次以上</li><li>缓存中存放的数据总量不会超出内存容量</li></ul><p>Guava Cache 是<strong>单个应用运行时的本地缓存</strong>; 不会把数据存放到文件或外部服务器, 分布式系统建议使用 Memcached、Redis 这类工具。</p><p>maven 引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaCacheUtils</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoadingCache&lt;String, Object&gt; <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//使用CacheBuilder构建即可</span><br>        <span class="hljs-keyword">return</span> CacheBuilder.newBuilder()<br>            <span class="hljs-comment">//设置并发级别为8,并发级别是指可以同时写缓存的线程数</span><br>            .concurrencyLevel(<span class="hljs-number">8</span>)<br>            <span class="hljs-comment">//设置写缓存后8秒钟过期</span><br>            .expireAfterAccess(<span class="hljs-number">8</span>, TimeUnit.SECONDS)<br>            <span class="hljs-comment">//设置写缓存后1秒钟刷新</span><br>            .refreshAfterWrite(<span class="hljs-number">1</span>, TimeUnit.SECONDS)<br>            <span class="hljs-comment">//设置缓存容器的初始容量为10</span><br>            .initialCapacity(<span class="hljs-number">10</span>)<br>            <span class="hljs-comment">//设置缓存最大容量为100,超过100之后就会按照LRU最近虽少使用算法来移除缓存项</span><br>            .maximumSize(<span class="hljs-number">100</span>)<br>            <span class="hljs-comment">//设置要统计缓存的命中率</span><br>            .recordStats()<br>            <span class="hljs-comment">//设置缓存的移除通知</span><br>            .removalListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RemovalListener</span>&lt;Object, Object&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRemoval</span><span class="hljs-params">(RemovalNotification&lt;Object, Object&gt; notification)</span> &#123;<br>                    System.out.println(notification.getKey() + <span class="hljs-string">&quot; 被移除了，原因： &quot;</span> + notification.getCause());<br>                &#125;<br>            &#125;)<br>            <span class="hljs-comment">//build方法中可以指定CacheLoader,在缓存不存在时通过CacheLoader的实现自动加载缓存</span><br>            .build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;String, Object&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">load</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    System.out.println(<span class="hljs-string">&quot;缓存没有时，从数据库加载&quot;</span> + key);<br>                    <span class="hljs-comment">//省略JDBC过程</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tom-&quot;</span> + key;<br>                &#125;<br>            &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaCacheTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <br>        LoadingCache&lt;String, Object&gt; cache = GuavaCacheUtils.getInstance();<br><br>        <span class="hljs-comment">// 第一次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(i + <span class="hljs-string">&quot;: &quot;</span> + cache.get(String.valueOf(i)));<br>        &#125;<br>        <span class="hljs-comment">// 第二次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(i + <span class="hljs-string">&quot;: &quot;</span> + cache.get(String.valueOf(i)));<br>        &#125;<br>        <span class="hljs-comment">// 打印缓存命中率</span><br>        System.out.println(<span class="hljs-string">&quot;cache stats: &quot;</span> + cache.stats().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存中间件</tag>
      
      <tag>java内存缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker集群服务</title>
    <link href="/2021/03/26/docker%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1/"/>
    <url>/2021/03/26/docker%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Swarm-概述"><a href="#一-Swarm-概述" class="headerlink" title="一 : Swarm 概述"></a>一 : Swarm 概述</h2><p>Docker Swarm 是 Docker 官方三剑客项目之一, 提供 Docker 容器集群服务, 是 Docker 官方对容器云生态进行支持的核心方案。</p><p>使用它, 用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机, 快速打造一套容器云平台。</p><p>注意 : Docker 1.12.0+ Swarm mode 已经内嵌入 Docker 引擎, 成为了 docker 子命令 docker swarm, 绝大多数用户已经开始使用 Swarm mode, Docker 引擎 API 已经删除 Docker Swarm。</p><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置(原生)的集群管理和编排工具, 使用 Swarm 集群之前需要了解以下几个概念</p><h3 id="一-节点"><a href="#一-节点" class="headerlink" title="(一) 节点"></a>(一) 节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群, 这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点(node)</p><p>节点分为管理(manager)节点和工作(worker)节点</p><ul><li><strong>管理节点 :</strong> 用于 Swarm 集群的管理, docker swarm 命令基本只能在管理节点执行</li><li><strong>工作节点 :</strong> 是任务执行节点, 管理节点将服务(service)下发至工作节点执行</li></ul><p>集群中管理节点与工作节点的关系</p><pre><code class=" mermaid">graph TBsubgraph x[内部分布式状态存储]a[Internal distributed state store]endsubgraph y[管理节点:共享数据]a[Internal distributed state store] --&gt; b1[Manager1] &amp; b2[Manager2] &amp; b3[Manager3]endsubgraph z[工作节点]    b1 --&gt; c1[Worker1] &amp; c2[Worker2]    b2 --&gt; c3[Worker3] &amp; c4[Worker4] &amp; c5[Worker5]    b3 --&gt; c6[Worker6] &amp; c7[Worker7]end</code></pre><h3 id="二-服务和任务"><a href="#二-服务和任务" class="headerlink" title="(二) 服务和任务"></a>(二) 服务和任务</h3><p><strong>任务(Task) :</strong> 是 Swarm 中的最小的调度单位, 目前来说就是一个单一的容器</p><p><strong>服务(Services) :</strong> 是指一组任务的集合, 服务定义了任务的属性; 服务有两种模式, 通过 docker service create 的 <code>--mode</code> 参数指定</p><ul><li>replicated services : 按照一定规则在各个工作节点上运行指定个数的任务</li><li>global services : 每个工作节点上运行一个任务</li></ul><p>容器, 任务, 服务的关系</p><pre><code class=" mermaid">flowchart LRsubgraph x[swarm manager]a[&quot;3 nginx replicas(服务)&quot;]endsubgraph y1[available node]subgraph b1[&quot;nginx.1(任务)&quot;]b11[&quot;nginx:latest(容器)&quot;]endsubgraph b2[&quot;nginx.2(任务)&quot;]b21[&quot;nginx:latest(容器)&quot;]endsubgraph b3[&quot;nginx.3(任务)&quot;]b31[&quot;nginx:latest(容器)&quot;]endenda --&gt; b1 &amp; b2 &amp; b3</code></pre><h2 id="二-Swarm-使用"><a href="#二-Swarm-使用" class="headerlink" title="二 : Swarm 使用"></a>二 : Swarm 使用</h2><h3 id="一-创建-swarm-集群"><a href="#一-创建-swarm-集群" class="headerlink" title="(一) 创建 swarm 集群"></a>(一) 创建 swarm 集群</h3><blockquote><p> 目标 : 创建一个最小 swarm 集群(包含1个管理节点和2个工作节点)</p></blockquote><p><strong>1: 集群初始化,</strong> 执行docker swarm init命令的节点自动成为<u>管理节点</u></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你的Docker主机有多个网卡,拥有多个IP,必须使用--advertise-addr指定 IP</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker swarm init --advertise-addr 10.0.0.20</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化完成后会输出加入工作节点的指令,也可以使用命令查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker swarm join-token worker</span><br></code></pre></td></tr></table></figure><p><strong>2: 增加工作节点,</strong> 在另外两条服务器上执行上一步创建管理节点时候的输出的加入 swarm 集群的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker swarm <span class="hljs-built_in">join</span> \</span><br><span class="language-bash">--token SWMTKN-1-28fc7j6gm3q6nyw8oepkjqszxd3kighqdqnn18e0gr260ejo1b-7xos9uw9zcrxg44wk5dmdg88d \</span><br><span class="language-bash">10.0.0.20:2377</span><br></code></pre></td></tr></table></figure><p><strong>3: 查看集群,</strong> 在管理节点使用 docker node ls 来查看集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker node <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><h3 id="二-部署服务"><a href="#二-部署服务" class="headerlink" title="(二) 部署服务"></a>(二) 部署服务</h3><blockquote><p> 使用 docker service 命令来管理 Swarm 集群中的服务, 该命令只能在管理节点运行</p></blockquote><p><strong>1: 新建服务,</strong> 在创建好的 Swarm 集群中运行一个名为 nginx 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service create --replicas 3 -p 8888:80 --name nginx nginx:latest</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">短格式可能不会监听ipv4的端口,用长格式[mode=host],published=&lt;externport&gt;,target=&lt;internport&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里说明一下mode的取值: mode=[ingress|host]</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># ingress把端口映射到整个swarm的网络,从而访问swarm网络的任何一台主机都可以,即使这台主机没有容器运行</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># host只把端口映射到service的container所在运行的主机，其他主机就不能访问</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service create -p mode=host,published=8888,target=80 --replicas 3 --name nginx nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问http://&#123;输入任意节点IP&#125;,即可看到 nginx 默认页面</span><br></code></pre></td></tr></table></figure><p><strong>2: 查看服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看当前Swarm集群运行的服务</span><br>$ docker service <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看某个服务的详情</span><br>$ docker servcie ps nginx<br><span class="hljs-comment"># 查看某个服务的日志</span><br>$ docker service logs nginx<br></code></pre></td></tr></table></figure><p><strong>3: 删除服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移除某个服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service <span class="hljs-built_in">rm</span> nginx</span><br></code></pre></td></tr></table></figure><h2 id="三-portainer"><a href="#三-portainer" class="headerlink" title="三 : portainer"></a>三 : portainer</h2><p>Swarm 可以快速搭建一个最小集群, 也可以在集群上部署服务, 但并没有提供统一入口查看节点的资源使用情况; portainer 提供了一个图形化管理工具来帮我们管理 swarm 集群。</p><p>Portainer 是 Docker 的<strong>图形化管理工具</strong>, 提供状态显示面板, 应用模块快速部署, 容器镜像网络数据卷的基本操作(包括上传下载镜像, 创建容器等操作), 事件日志显示, 容器控制台操作, swarm 集群和服务等集中管理和操作, 登录用户管理和控制等功能, 功能十分全面, 基本能满足中小型单位对容器管理的全部需求。</p><h3 id="一-portainer-集群运行"><a href="#一-portainer-集群运行" class="headerlink" title="(一) portainer 集群运行"></a>(一) portainer 集群运行</h3><p>在管理节点下载 portainer 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search portainer</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull portainer/portainer</span><br></code></pre></td></tr></table></figure><p>安装 portainer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 9000:9000 \</span><br><span class="language-bash">--name portainer \</span><br><span class="language-bash">--restart=always \</span><br><span class="language-bash">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="language-bash">portainer/portainer</span><br></code></pre></td></tr></table></figure><h3 id="二-portainer-配置"><a href="#二-portainer-配置" class="headerlink" title="(二) portainer 配置"></a>(二) portainer 配置</h3><p>访问地址: http:&#x2F;&#x2F;{ip}:9000</p><p>需要初始化账号密码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">账号:</span> <span class="hljs-string">admin</span><br><span class="hljs-string">密码:</span> <span class="hljs-string">Admin@123456</span><br></code></pre></td></tr></table></figure><p>点击菜单栏 Home 即可查看本机环境, 选择 Environments 中的 local 项, 在选择左侧菜单中的 Swarm 选项, 即可查看服务情况</p><h2 id="四-快速扩容"><a href="#四-快速扩容" class="headerlink" title="四 : 快速扩容"></a>四 : 快速扩容</h2><h3 id="一-命令方式"><a href="#一-命令方式" class="headerlink" title="(一) 命令方式"></a>(一) 命令方式</h3><p>在创建好的 Swarm 集群中运行一个名为 nginx 服务, 并使用 <code>--replicas</code> 参数指定启动的副本数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service create --replicas 3 -p 80:80 --name nginx nginx:latest</span><br></code></pre></td></tr></table></figure><p>其实还可以先创建服务, 然后再进行扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service create -p 80:80 --name nginx nginx:latest</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">扩容为3个</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker service scale nginx=3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看副本情况</span><br>docker service ls <br></code></pre></td></tr></table></figure><h3 id="二-portainer-方式"><a href="#二-portainer-方式" class="headerlink" title="(二) portainer 方式"></a>(二) portainer 方式</h3><p>在左侧菜单栏中的 Service 选项可以创建服务且更改副本数量, 只需要简单填写一下信息即可, 例如:</p><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>Name</td><td>nginx</td></tr><tr><td>Image</td><td>nginx:latest</td></tr><tr><td>Replicas</td><td>3</td></tr><tr><td>Port mapping</td><td>8888 &#x3D;&gt; 80 TCP HOST</td></tr></tbody></table><p>至于调整副本数量就更简单了在 Service 列表中的 Scheduling Mode 列点击 <code>Scale</code> 即可, 例如将副本数改成 1 个, 分别访问可以发现只有一个服务可以被访问到</p>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker日志监控</title>
    <link href="/2021/03/19/docker%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/03/19/docker%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Docker-日志"><a href="#一-Docker-日志" class="headerlink" title="一 : Docker 日志"></a>一 : Docker 日志</h2><h3 id="一-日志处理机制"><a href="#一-日志处理机制" class="headerlink" title="(一) 日志处理机制"></a>(一) 日志处理机制</h3><p>当启动一个容器的时候, 它其实是 docker daemon 的一个子进程, docker daemon 可以拿到你容器里面进程的标准输出, 拿到标准输出后, 它会通过自身的一个 LogDriver 模块来处理, LogDriver 支持的方式很多, 可以写到本地的文件(默认方式), 可以发送到 syslog 等。</p><pre><code class=" mermaid">graph TBA[Containers] --&gt; B[Docker Log Driver] B --&gt; C1[&quot;json-file&lt;br&gt;(default)&quot;]B --&gt; C2[syslog]B --&gt; C3[gelf]B --&gt; C4[fluentd]B --&gt; C5[...]</code></pre><p>Docker 会默认收集容器的标准输出存储到一个 json.log 文件中, 文件格式如下所示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;log&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Log line is here\n&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;stream&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stdout&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2019-01-01T11:11:11.111111111Z&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以一行一个作为一条 JSON 数据存储; Docker 的这种日志存储方式是可以配置的, 具体参数可以在执行 run 启动容器的时候通过 log-driver 进行配置, 具体配置请参考 <a href="https://docs.docker.com/config/containers/logging/configure/#supported-logging-drivers">log-driver</a>。</p><p>Docker 默认使用了 json-file 作为 log driver, 而 gelf 则是我们需要使用的 log driver。</p><h3 id="二-gelf-驱动"><a href="#二-gelf-驱动" class="headerlink" title="(二) gelf 驱动"></a>(二) gelf 驱动</h3><p>gelf 驱动是一个被许多工具理解的实用格式, 例如 Graylog, Logstash 和 Fluentd。许多工具都使用这种格式。</p><p>可以通过 daemon.json 进行配置使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gelf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;gelf-address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;udp://1.2.3.4:12201&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>也可以通过命令行进行配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run \<br>--log-driver gelf --log-opt gelf-address=udp://1.2.3.4:12201 \<br>alpine <span class="hljs-built_in">echo</span> hello world<br></code></pre></td></tr></table></figure><p><strong>注意 :</strong> gelf-address 为 gelf 服务的地址, <strong>必填</strong>; tcp 和 udp 是唯一支持的标识符; 同时必须指定端口号。</p><h2 id="二-Graylog"><a href="#二-Graylog" class="headerlink" title="二 : Graylog"></a>二 : Graylog</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p>当容器多了, 或者是采用类似 swarm 集群部署 Docker 的时候, 各种日志分散存在各个 json.log 文件中, 当查找问题或者进行相关统计的时候, 分散的日志对我们来说是非常不友好的; 我们需要一个能够集中管理 Docker 日志的工具。</p><p>相信大部分的人都用过或者听说过 ELK 这个强大的日志栈架构, 我们要用的 graylog 和 ELK 非常的相似, 算是后起之秀。</p><p><strong>为什么</strong>要选择 graylog 来作为 Docker 的日志收集平台呢 ? </p><ul><li>Docker 原生支持 graylog 协议, 直接将日志发送到 graylog (通过 gelf 协议)</li><li>graylog 官方提供了将本身部署在 Docker 的支持</li></ul><h3 id="二-安装部署"><a href="#二-安装部署" class="headerlink" title="(二) 安装部署"></a>(二) 安装部署</h3><p>在这个 Docker Hub 中, 搜索 graylog 即可看到 graylog&#x2F;graylog 的镜像, 也可以查看 graylog 的<a href="https://go2docs.graylog.org/5-0/downloading_and_installing_graylog/docker_installation.htm">官方文档</a>。</p><p>当然只有 graylog 是不够的, 还需要 MongoDB, Elasticsearch 配合使用, 官方提供了 docker-compose.yml 模板, 复制下来即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-comment"># MongoDB: https://hub.docker.com/_/mongo/</span><br>  <span class="hljs-attr">mongo:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mongo:5.0.13</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">graylog</span><br>  <span class="hljs-comment"># Elasticsearch: https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html</span><br>  <span class="hljs-attr">elasticsearch:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/elasticsearch/elasticsearch-oss:7.10.2</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http.host=0.0.0.0</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">transport.host=localhost</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">network.host=0.0.0.0</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Dlog4j2.formatMsgNoLookups=true -Xms512m -Xmx512m&quot;</span><br>    <span class="hljs-attr">ulimits:</span><br>      <span class="hljs-attr">memlock:</span><br>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span><br>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">1g</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">graylog</span><br>  <span class="hljs-comment"># Graylog: https://hub.docker.com/r/graylog/graylog/</span><br>  <span class="hljs-attr">graylog:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">graylog/graylog:5.0</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-comment"># CHANGE ME (must be at least 16 characters)!</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GRAYLOG_PASSWORD_SECRET=somepasswordpepper</span><br>      <span class="hljs-comment"># Password: admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GRAYLOG_ROOT_PASSWORD_SHA2=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GRAYLOG_HTTP_EXTERNAL_URI=http://127.0.0.1:9000/</span><br>      <span class="hljs-comment"># 默认UTC,需要修改时区Etc/GMT-8,不然时间对不上</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GRAYLOG_ROOT_TIMEZONE=Etc/GMT-8</span><br>    <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">/usr/bin/tini</span> <span class="hljs-string">--</span> <span class="hljs-string">wait-for-it</span> <span class="hljs-string">elasticsearch:9200</span> <span class="hljs-string">--</span> <span class="hljs-string">/docker-entrypoint.sh</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">graylog</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mongo</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">elasticsearch</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># Graylog web interface and REST API</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">9000</span><span class="hljs-string">:9000</span><br>      <span class="hljs-comment"># Syslog TCP</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">1514</span><span class="hljs-string">:1514</span><br>      <span class="hljs-comment"># Syslog UDP</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">1514</span><span class="hljs-string">:1514/udp</span><br>      <span class="hljs-comment"># GELF TCP</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">12201</span><span class="hljs-string">:12201</span><br>      <span class="hljs-comment"># GELF UDP</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">12201</span><span class="hljs-string">:12201/udp</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">graylog:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up<br></code></pre></td></tr></table></figure><p>访问 : http:&#x2F;&#x2F;{IP}:9000, 会看到 graylog 的 web 界面, 使用 admin&#x2F;admin 来登录后台, 至此部署完成</p><h3 id="三-自定义配置"><a href="#三-自定义配置" class="headerlink" title="(三) 自定义配置"></a>(三) 自定义配置</h3><p>有时候需要修改 graylog 的参数, 可以使用 配置环境变量或者是修改配置文件, 详情参考<a href="https://go2docs.graylog.org/5-0/downloading_and_installing_graylog/docker_installation.htm#Configuration">官方文档</a>。推荐挂载配置文件</p><p>下载配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建目录</span><br>$ <span class="hljs-built_in">mkdir</span> -p ./graylog/config<br><span class="hljs-comment"># 进入目录下载配置文件</span><br><span class="hljs-built_in">cd</span> ./graylog/config<br>wget https://raw.githubusercontent.com/Graylog2/graylog-docker/5.0/config/graylog.conf<br>wget https://raw.githubusercontent.com/Graylog2/graylog-docker/5.0/config/log4j2.xml<br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改root_timezone为GMT+0800中国时区</span><br>$ vim graylog.conf<br>root_timezone=Etc/GMT-8<br></code></pre></td></tr></table></figure><p>挂载配置文件所在文件夹</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">graylog:</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">graylog/graylog:5.0</span><br><span class="hljs-comment"># Other settings [...]</span><br>  <span class="hljs-attr">volumes:</span><br><span class="hljs-comment"># Mount local configuration directory into Docker container</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./graylog/config:/usr/share/graylog/data/config</span><br></code></pre></td></tr></table></figure><h3 id="四-数据持久化"><a href="#四-数据持久化" class="headerlink" title="(四) 数据持久化"></a>(四) 数据持久化</h3><p>为了把记录数据进行持久化, 可以通过外部数据卷来进行存储数据, 当容器重新启动后, 可以继续使用之前的数据, 详情参考<a href="https://go2docs.graylog.org/5-0/downloading_and_installing_graylog/docker_installation.htm#PersistingData">官方文档</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mongodb:</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mongo_data:/data/db</span><br><span class="hljs-attr">elasticsearch:</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">es_data:/usr/share/elasticsearch/data</span><br><span class="hljs-attr">graylog:</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">graylog_data:/usr/share/graylog/data</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mongo_data:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">es_data:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">graylog_data:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br></code></pre></td></tr></table></figure><h2 id="三-使用实例"><a href="#三-使用实例" class="headerlink" title="三 : 使用实例"></a>三 : 使用实例</h2><h3 id="一-graylog-配置"><a href="#一-graylog-配置" class="headerlink" title="(一) graylog 配置"></a>(一) graylog 配置</h3><ol><li>graylog 的日志收集通过定义 input 对象来完成, 在 graylog 的 web 管理界面进入 System &#x3D;&gt; inputs 对象配置</li><li>选择 GELF UDP 协议, Launch new input</li><li>随便起个名字填到 Title 里即可</li></ol><h3 id="二-docker-配置"><a href="#二-docker-配置" class="headerlink" title="(二) docker 配置"></a>(二) docker 配置</h3><p>如果 docker 通过命令行启动, 可以在 run 命令中加如下参数 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># docker run --log-driver=gelf \</span><br><span class="hljs-comment"># --log-opt gelf-address=udp://&#123;graylog服务器地址&#125;:12201 \</span><br><span class="hljs-comment"># --log-opt tag=&lt;当前容器服务标签,用来共graylog查询的时候进行分类&gt; &lt;image&gt; &lt;运行命令&gt;</span><br>$ docker run -d \<br>--log-driver=gelf \<br>--log-opt gelf-address=udp://localhost:12201 \<br>--log-opt tag=<span class="hljs-string">&quot;&#123;&#123;.ImageName&#125;&#125;/&#123;&#123;.Name&#125;&#125;/&#123;&#123;.ID&#125;&#125;&quot;</span> \<br>busybox \<br>sh -c <span class="hljs-string">&#x27;while true;do echo &quot;Hello World !&quot;;sleep 10; done;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果通过 docker-compose 命令, 则可以在 docker-compose.yml 中加入相关配置, 以下用 nginx 容器举例 :</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">logging:</span><br>      <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;gelf&quot;</span><br>      <span class="hljs-attr">options:</span><br>        <span class="hljs-attr">gelf-address:</span> <span class="hljs-string">&quot;udp://localhost:12201&quot;</span><br>        <span class="hljs-attr">tag:</span> <span class="hljs-string">front-nginx</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器监控</title>
    <link href="/2021/03/12/docker%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/03/12/docker%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一-容器监控方案选择"><a href="#一-容器监控方案选择" class="headerlink" title="一 : 容器监控方案选择"></a>一 : 容器监控方案选择</h2><p>对于容器的监控方案可谓多种多样, 本身自带命令 <code>docker stats</code> 命令, Scout, Data Dog, Sysdig Cloud, Sensu Monitoring Framework, CAdvisor 等</p><p>通过 <code>docker stats</code> 命令可以很方便的看到当前宿主机上所有容器的 CPU, 内存以及网络流量等数据; 但是 <code>docker stats</code> 命令的缺点就是统计的只是当前宿主机的所有容器, 而获取的监控数据是实时的, 没有地方存储, 也没有报警功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stats</span><br>CONTAINER IDNAMECPU %MEM USAGE / LIMITMEM %NET I/OBLOCK I/OPIDS<br>d0be455d1aedweb0.41%109.3MiB / 972.3MiB11.24%656B / 0B0B / 0B26<br>a5d8be7fc2e7redis0.27%2.004MiB / 972.3MiB0.21%656B / 0B0B / 0B5<br>1eb1fe100c4fregistry0.07%6.047MiB / 972.3MiB0.62%656B / 0B39.3MB / 0B3<br></code></pre></td></tr></table></figure><p>而 Scout, Sysdig Cloud, Data Dog 虽然都提供了较完善的服务, 但是它们都是托管的服务而且都收费; Sensu Monitoring Framework 集成度较高, 也免费, 但是部署过于复杂; 综合考虑, 我们选择了 CAdvisor 做容器监控工具</p><p>CAdvisor 谷歌出品, <strong>优点</strong>是开源产品, 监控指标齐全, 部署方便, 而且有官方的 docker 镜像; <strong>缺点</strong>是集成度不高, 默认只在本地保存 2 分钟数据, 不过可以加上 <strong>InfluxDB</strong> 存储数据, 对接 <strong>Grafana</strong> 展示图表, 比较便利地搭建好了容器监控系统, 数据收集和图标展示效果良好, 对系统性能也几乎没有什么影响</p><pre><code class=" mermaid">graph LRA1 &amp; A2 &amp; A3 --&gt; B1 --&gt; C1subgraph A[采集]A1[CAdvisor]A2[CAdvisor]A3[CAdvisor]endsubgraph B[存储]B1[InfluxDB]endsubgraph C[展示]C1[Grafana]end</code></pre><h3 id="一-cAdvisor"><a href="#一-cAdvisor" class="headerlink" title="(一) cAdvisor"></a>(一) cAdvisor</h3><p>CAdvisor 是一个<strong>容器资源监控</strong>工具, 包括容器的内存, CPU, 网络IO, 磁盘IO等监控, 同时提供了一个 WEB 页面用于查看容器的实时运行状态; CAdvisor 默认存储 2 分钟的数据, 而只是针对单物理机; 不过, CAdvisor 提供了很多数据集成接口, 支持 InfluxDB, Redis, Kafka, Elasticsearch 等集成, 可以加上对应配置将监控数据发往这些数据库存储起来</p><p>主要功能 :</p><ol><li>展示 Host 和 容器两个层次的监控数据</li><li>展示历史变化数据</li></ol><h3 id="二-InfluxDB"><a href="#二-InfluxDB" class="headerlink" title="(二) InfluxDB"></a>(二) InfluxDB</h3><p>InfluxDB 是用 Go 语言编写的一个开源分布式时序, 事件和指标数据库, 无需外部依赖; 由于 CAdvisor 默认只在本地保存最近 2 分钟的数据, 为了持久化存储数据和统一收集展示监控数据, 需要将数据存储到 InfluxDB 中; InfluxDB 是一个<strong>时序数据库</strong>, 专门用于存储时序相关数据, 很适合存储 CAdvisor 的数据; 而且, CAdvisor 本身已经提供了 InfluxDB 的集成方案, 在启动容器时指定配置即可</p><p>主要功能 : </p><ol><li>基于时间序列, 支持与事件有关的相关函数(如最大,最小,求和等)</li><li>可度量性 : 可以实时对大量数据进行计算</li><li>基于事件 : 它支持任意的事件数据</li></ol><p>主要特点 :</p><ol><li>无结构(无模式)</li><li>可以是任意数量的列</li><li>可拓展的</li><li>支持 min, max, sum, count, mean, median 等一系列函数, 方便统计</li><li>原生的 HTTP 支持, 内置 HTTP API</li><li>强大的类 SQL 语法</li><li>自带管理界面, 方便使用</li></ol><h3 id="三-Grafana"><a href="#三-Grafana" class="headerlink" title="(三) Grafana"></a>(三) Grafana</h3><p>grafana 是一个开源的数据监控分析可视化平台, 支持多种数据源配置(支持的数据源包括 InfluxDB, MySQL, Elasticsearch, OpenTSDB, Graphite等)和丰富的插件及摹本功能, 支持图表权限控制和报警</p><p>主要特性 : </p><ol><li>灵活丰富的图形化选项</li><li>可以混合多种风格</li><li>支持白天和夜间模式</li><li>多个数据源</li></ol><h2 id="二-安装部署"><a href="#二-安装部署" class="headerlink" title="二 : 安装部署"></a>二 : 安装部署</h2><h3 id="一-部署-InfluxDB"><a href="#一-部署-InfluxDB" class="headerlink" title="(一) 部署 InfluxDB"></a>(一) 部署 InfluxDB</h3><p>可以使用官方镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 8086:8086 \</span><br><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/data:/var/lib/influxdb2 \</span><br><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/config:/etc/influxdb2 \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_MODE=setup \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_USERNAME=my-user \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_PASSWORD=my-password \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_ORG=my-org \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_BUCKET=my-bucket \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_RETENTION=1w \</span><br><span class="language-bash">-e DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=my-super-secret-auth-token \</span><br><span class="language-bash">influxdb</span><br></code></pre></td></tr></table></figure><p>当然也可以使用 tutum 提供的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 8083:8083 -p 8086:8086 \</span><br><span class="language-bash">--volume=/var/influxdb:/data \</span><br><span class="language-bash">-e ADMIN_USER=<span class="hljs-string">&quot;root&quot;</span> -e INFLUXDB_INIT_PWD=<span class="hljs-string">&quot;somepassword&quot;</span> -e PRE_CREATE_DB=<span class="hljs-string">&quot;db1;db2;db3&quot;</span> \</span><br><span class="language-bash">tutum/influxdb</span><br></code></pre></td></tr></table></figure><h3 id="二-部署-cAdvisor"><a href="#二-部署-cAdvisor" class="headerlink" title="(二) 部署 cAdvisor"></a>(二) 部署 cAdvisor</h3><p>谷歌的 cadvisor 可以用于收集 Docker 容器的时序信息, 包括容器运行过程中的资源使用情况和性能数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -d<span class="hljs-comment"># 后台运行此容器</span><br>--volume=/:/rootfs:ro \<span class="hljs-comment"># 把宿主机的项目目录绑定到容器中, 这些目录都是cadvisor需要采集的目录文件和监控内容</span><br>--volume=/var/run:/var/run:ro \<br>--volume=/sys:/sys:ro \<br>--volume=/var/lib/docker/:/var/lib/docker:ro \<br>--volume=/dev/disk/:/dev/disk:ro \<br>--publish=8080:8080 <span class="hljs-comment"># 映射端口 8080</span><br>--detach=<span class="hljs-literal">true</span> \<br>--privileged=<span class="hljs-literal">true</span> \<br>--name=cadvisor \<span class="hljs-comment"># 启动容器分配名字cadvisor</span><br>google/cadvisor:latest \<br>-storage_driver=influxdb \<span class="hljs-comment"># 需要指定cadvisor的存储驱动,数据库主机,数据库名</span><br>-storage_driver_host=influxdb:8086 -storage_driver_db=<span class="hljs-built_in">test</span> \<br>-storage_driver_user=root -storage_driver_password=root<br></code></pre></td></tr></table></figure><p>这里说一下储存驱动的参数, <a href="https://github.com/google/cadvisor/blob/master/docs/runtime_options.md">参考文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">--storage_driver=&quot;&quot;:</span> <span class="hljs-string">Storage</span> <span class="hljs-string">driver</span> <span class="hljs-string">to</span> <span class="hljs-string">use.</span> <span class="hljs-string">Data</span> <span class="hljs-string">is</span> <span class="hljs-string">always</span> <span class="hljs-string">cached</span> <span class="hljs-string">shortly</span> <span class="hljs-string">in</span> <span class="hljs-string">memory,</span> <span class="hljs-attr">this controls where data is pushed besides the local cache. Empty means none. Options are:</span> <span class="hljs-string">&lt;empty&gt;,</span> <span class="hljs-string">bigquery,</span> <span class="hljs-string">elasticsearch,</span> <span class="hljs-string">influxdb,</span> <span class="hljs-string">kafka,</span> <span class="hljs-string">redis,</span> <span class="hljs-string">statsd,</span> <span class="hljs-string">stdout</span><br><span class="hljs-string">--storage_driver_buffer_duration=&quot;1m0s&quot;:</span> <span class="hljs-string">Writes</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">storage</span> <span class="hljs-string">driver</span> <span class="hljs-string">will</span> <span class="hljs-string">be</span> <span class="hljs-string">buffered</span> <span class="hljs-string">for</span> <span class="hljs-string">this</span> <span class="hljs-string">duration,</span> <span class="hljs-string">and</span> <span class="hljs-string">committed</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">non</span> <span class="hljs-string">memory</span> <span class="hljs-string">backends</span> <span class="hljs-string">as</span> <span class="hljs-string">a</span> <span class="hljs-string">single</span> <span class="hljs-string">transaction</span> <span class="hljs-string">(default</span> <span class="hljs-string">1m0s)</span><br><span class="hljs-string">--storage_driver_db=&quot;cadvisor&quot;:</span> <span class="hljs-string">database</span> <span class="hljs-string">name</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;cadvisor&quot;</span><span class="hljs-string">)</span><br><span class="hljs-string">--storage_driver_host=&quot;localhost:8086&quot;:</span> <span class="hljs-string">database</span> <span class="hljs-string">host:port</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;localhost:8086&quot;</span><span class="hljs-string">)</span><br><span class="hljs-string">--storage_driver_password=&quot;root&quot;:</span> <span class="hljs-string">database</span> <span class="hljs-string">password</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;root&quot;</span><span class="hljs-string">)</span><br><span class="hljs-string">--storage_driver_secure=false:</span> <span class="hljs-string">use</span> <span class="hljs-string">secure</span> <span class="hljs-string">connection</span> <span class="hljs-string">with</span> <span class="hljs-string">database</span><br><span class="hljs-string">--storage_driver_table=&quot;stats&quot;:</span> <span class="hljs-string">table</span> <span class="hljs-string">name</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;stats&quot;</span><span class="hljs-string">)</span><br><span class="hljs-string">--storage_driver_user=&quot;root&quot;:</span> <span class="hljs-string">database</span> <span class="hljs-string">username</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;root&quot;</span><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure><p>访问地址: <a href="http://ip:8080/">http://ip:8080</a>, 启动后稍等一会儿在访问, 需要初始化一些配置, 会有点慢</p><h3 id="三-部署-Grafana"><a href="#三-部署-Grafana" class="headerlink" title="(三) 部署 Grafana"></a>(三) 部署 Grafana</h3><p>grafana 一款开源的时序数据分析工具, 而且界面专业易用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=grafana -p 3000:3000 grafana/grafana<br></code></pre></td></tr></table></figure><p>通过 IP + 3000 端口来访问 grafana 的 web 服务, 第一次访问需要修改 admin 的用户密码, 默认用户名&#x2F;密码为 : admin&#x2F;admin</p><h2 id="三-docker-compose"><a href="#三-docker-compose" class="headerlink" title="三 : docker-compose"></a>三 : docker-compose</h2><h3 id="一-快速部署"><a href="#一-快速部署" class="headerlink" title="(一) 快速部署"></a>(一) 快速部署</h3><p>编写 docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">grafana_data:</span> &#123;&#125;<br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">overlay:</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">influxdb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">tutum/influxdb</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ADMIN_USER=root</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">INFLUXDB_INIT_PWD=root</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PRE_CREATE_DB=cadvisor</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8083</span><span class="hljs-string">:8083</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8086</span><span class="hljs-string">:8086</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/influxdb:/data</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">overlay</span><br>  <span class="hljs-attr">cadvisor:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">google/cadvisor</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">-storage_driver=influxdb</span> <span class="hljs-string">-storage_driver_db=cadvisor</span> <span class="hljs-string">-storage_driver_host=influxdb:8086</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/:/rootfs:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run:/var/run:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/sys:/sys:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/docker/:/var/lib/docker:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/disk/:/dev/disk:ro</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">overlay</span><br>  <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3000</span><span class="hljs-string">:3000</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">grafana_data:/var/lib/grafana</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">overlay</span><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up -d</span><br></code></pre></td></tr></table></figure><h3 id="二-使用示例"><a href="#二-使用示例" class="headerlink" title="(二) 使用示例"></a>(二) 使用示例</h3><p>登录 grafana</p><table><thead><tr><th>选项</th><th>内容</th></tr></thead><tbody><tr><td>地址</td><td>http:&#x2F;&#x2F;{IP}:3000</td></tr><tr><td>账号</td><td>admin</td></tr><tr><td>密码</td><td>admin</td></tr></tbody></table><p>配置 influxdb</p><table><thead><tr><th>选项</th><th>内容</th></tr></thead><tbody><tr><td>URL</td><td><a href="http://influxdb:8086/">http://influxdb:8086</a></td></tr><tr><td>Database</td><td>cadvisor</td></tr><tr><td>User</td><td>root</td></tr><tr><td>Password</td><td>root</td></tr></tbody></table><p>配置仪表盘</p><table><thead><tr><th>选项</th><th>内容</th></tr></thead><tbody><tr><td>Data Source</td><td>InfluxDB</td></tr><tr><td>FROM</td><td>memory_usage</td></tr><tr><td>WHERE</td><td>container_name&#x3D;monitor-cadvisor-1</td></tr><tr><td>ALIAS</td><td>cadvisor 内存使用情况</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器编排</title>
    <link href="/2021/03/05/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/"/>
    <url>/2021/03/05/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Compose-简介"><a href="#一-Compose-简介" class="headerlink" title="一 : Compose 简介"></a>一 : Compose 简介</h2><p>Compose 项目是 Docker 官方的开源项目, 负责实现对 Docker 容器集群的快速编排; 其代码目前在 <a href="https://github.com/docker/compose">github</a> 上开源。</p><p><strong>Compose 定位</strong> 是 <strong>定义和运行多个 Docker 容器的应用</strong>, 其前身是开源项目 Fig。</p><p>我们指定使用一个 Dockerfile 模板文件, 可以让用户很方便的定义一个单独的应用容器; 然而, 在日常工作中, 经常会碰到需要多个容器相互配合来完成某些任务的情况; 例如要实现一个 web 项目, 除了 <strong>web</strong> 服务容器本身, 往往还需要再加上后端的<strong>数据库</strong>服务容器, 甚至还包括<strong>负载均衡</strong>容器等; Compose 恰好满足了这样的需求; 它允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个项目(project)。</p><p>Compose 中有<strong>两个重要的概念</strong>。</p><ul><li>服务 (service) : 一个应用的容器, 实际上可以包括若干运行相同镜像的容器实例</li><li>项目 (project) : 由一组关联的应用容器组成的一个完整业务单元</li></ul><p>总结一下</p><ul><li><strong>Compose 的默认管理对象是项目</strong>, 通过子命令对项目中的一组容器进行便捷的生命周期管理</li><li><strong>Compose 项目</strong>由 Python 编写, 实现上调用了 Docker 服务提供的 API 来对容器进行管理</li></ul><h2 id="二-Compose-安装"><a href="#二-Compose-安装" class="headerlink" title="二 : Compose 安装"></a>二 : Compose 安装</h2><p>Compose 支持 Linux, MacOS, Windows 10 三大平台; Compose 可以通过 Python 的包管理工具 pip 进行安装, 也可以直接下载编译好的二进制文件使用, 甚至能够直接在 Docker 容器中运行。</p><p>Docker for Mac, Docker for Windows 自带 docker-compose 二进制文件, 安装 Docker 之后可以直接使用; Linux 系统需要单独使用二进制或者 pip 方式(ARM架构,如树莓派)进行安装。</p><p><strong>二进制包</strong>在 Linux 上的安装十分简单, 从官方 GitHub Release 处直接下载编译好的二进制文件即可; 例如 : 在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">赋予可执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></code></pre></td></tr></table></figure><p>校验是否安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose --version<br></code></pre></td></tr></table></figure><h2 id="三-Compose-使用"><a href="#三-Compose-使用" class="headerlink" title="三 : Compose 使用"></a>三 : Compose 使用</h2><p>一个项目可以由多个服务(容器)关联而成, Compose <strong>面向项目</strong>进行管理。</p><p><strong>场景 :</strong> 最常见的项目是 web 网站, 一般的 web 网站都会依赖第三方提供的服务(比如: DB 和 cache)。</p><h3 id="一-代码准备"><a href="#一-代码准备" class="headerlink" title="(一) 代码准备"></a>(一) 代码准备</h3><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">uat</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">uat</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure><p>代码 : 模拟访问量统计(使用 redis)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebApplication</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stats</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>        redisTemplate.opsForValue().increment(<span class="hljs-string">&quot;num&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;当前访问量: &quot;</span> + redisTemplate.opsForValue().get(<span class="hljs-string">&quot;num&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(WebApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 maven 进行编辑打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mvn clean package -Dmaven.test.skip=<span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure><h3 id="二-Dockerfile"><a href="#二-Dockerfile" class="headerlink" title="(二) Dockerfile"></a>(二) Dockerfile</h3><p>在 dubbo-admin 目录下编写 Dockerfile 文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 表示使用jdk8环境作为集成镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><span class="hljs-comment"># 作者</span><br><span class="hljs-keyword">MAINTAINER</span> zhang&lt;info4z@<span class="hljs-number">163</span>.com&gt;<br><span class="hljs-comment"># 匿名数据卷</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp/web</span><br><span class="hljs-comment"># 拷贝文件并重命名</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ./web-1.0.jar web.jar</span><br><span class="hljs-comment"># 为了缩短Tomcat的启动时间,添加java.security.egd的系统属性指向/dev/urandom作为ENTRYPOINT</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;web.jar&quot;</span>,<span class="hljs-string">&quot;--spring.profiles.active=pro&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t web:1.0 .</span><br></code></pre></td></tr></table></figure><h3 id="三-docker-compose-yml"><a href="#三-docker-compose-yml" class="headerlink" title="(三) docker-compose.yml"></a>(三) docker-compose.yml</h3><p>在项目根目录下编写 docker-compose.yml 文件, 这个是 Compose 使用的主模板文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">networks:</span><br><span class="hljs-attr">overlay:</span><br><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">web:</span><br><span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:8080</span><br><span class="hljs-attr">networks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">overlay</span><br><span class="hljs-attr">redis:</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span><br><span class="hljs-attr">networks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">overlay</span><br></code></pre></td></tr></table></figure><h3 id="四-运行-compose"><a href="#四-运行-compose" class="headerlink" title="(四) 运行 compose"></a>(四) 运行 compose</h3><p>在 docker-compose.yml 文件所在目录执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 正常启动</span><br>$ docker-compose up<br><span class="hljs-comment"># 后台启动</span><br>$ docker-compose up -d<br></code></pre></td></tr></table></figure><p>在浏览器中访问 <code>http://ip:80</code> 进行验证</p><h2 id="四-Compose-命令说明"><a href="#四-Compose-命令说明" class="headerlink" title="四 : Compose 命令说明"></a>四 : Compose 命令说明</h2><p>docker-compose 命令的基本的使用格式是</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker</span> <span class="hljs-string">compose</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">COMMAND</span><br><span class="hljs-attr">OPTIONS:</span> <br><span class="hljs-string">-f,</span> <span class="hljs-string">--file</span> <span class="hljs-attr">stringArray:</span> <span class="hljs-string">指定模板文件,默认为docker-compose.yml,可以多次指定</span><br><span class="hljs-string">-p,</span> <span class="hljs-string">--project-name</span> <span class="hljs-attr">string:</span> <span class="hljs-string">指定项目名称,</span> <span class="hljs-string">默认将使用所在目录名称作为项目名</span><br></code></pre></td></tr></table></figure><h3 id="一-镜像操作"><a href="#一-镜像操作" class="headerlink" title="(一) 镜像操作"></a>(一) 镜像操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>images</td><td>List images used by the created containers</td></tr><tr><td>pull</td><td>Pull service images</td></tr><tr><td>push</td><td>Push service images</td></tr></tbody></table><h3 id="二-容器操作"><a href="#二-容器操作" class="headerlink" title="(二) 容器操作"></a>(二) 容器操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ps</td><td>List containers</td></tr><tr><td>up</td><td>Create and start containers</td></tr><tr><td>restart</td><td>Restart service containers</td></tr><tr><td>down</td><td>Stop and remove containers, networks</td></tr><tr><td>kill</td><td>Force stop service containers</td></tr><tr><td>rm</td><td>Removes stopped service containers</td></tr><tr><td>exec</td><td>Execute a command in a running container</td></tr><tr><td>events</td><td>Receive real time events from containers</td></tr></tbody></table><h3 id="三-服务操作"><a href="#三-服务操作" class="headerlink" title="(三) 服务操作"></a>(三) 服务操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>Creates containers for a service</td></tr><tr><td>build</td><td>Build or rebuild services</td></tr><tr><td>start</td><td>Start services</td></tr><tr><td>stop</td><td>Stop services</td></tr><tr><td>pause</td><td>Pause services</td></tr><tr><td>unpause</td><td>Unpause services</td></tr><tr><td>run</td><td>Run a one-off command on a service</td></tr></tbody></table><h3 id="四-其他"><a href="#四-其他" class="headerlink" title="(四) 其他"></a>(四) 其他</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>config</td><td>Parse, resolve and render compose file in canonical format</td></tr><tr><td>cp</td><td>Copy files&#x2F;folders between a service container and the local filesystem</td></tr><tr><td>logs</td><td>View output from containers</td></tr><tr><td>ls</td><td>List running compose projects</td></tr><tr><td>port</td><td>Print the public port for a port binding</td></tr><tr><td>top</td><td>Display the running processes</td></tr><tr><td>version</td><td>Show the Docker Compose version information</td></tr></tbody></table><h2 id="五-Compose-模板文件"><a href="#五-Compose-模板文件" class="headerlink" title="五 : Compose 模板文件"></a>五 : Compose 模板文件</h2><p>Compose文件是一个 yaml 文件，用于定义<a href="https://dockerdocs.cn/compose/compose-file/compose-file-v3/index.html#service-configuration-reference">服务</a>, <a href="https://dockerdocs.cn/compose/compose-file/compose-file-v3/index.html#network-configuration-reference">网络</a>和<a href="https://dockerdocs.cn/compose/compose-file/compose-file-v3/index.html#volume-configuration-reference">卷</a>。撰写文件的默认路径为<code>./docker-compose.yml</code>。</p><table><thead><tr><th>顶层结构</th><th>作用</th></tr></thead><tbody><tr><td>version</td><td>声明版本</td></tr><tr><td>services</td><td>定义服务</td></tr><tr><td>networks</td><td>定义网络</td></tr><tr><td>volumes</td><td>定义数据卷</td></tr></tbody></table><p>指令关键字比较多, 但大部分指令跟 docker run 相关参数的含义都是类似的, 具体可以查询 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">官方文档</a> 或者 <a href="https://dockerdocs.cn/compose/compose-file/compose-file-v3/">中文文档</a>。</p><p>示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.9&quot;</span><span class="hljs-comment"># 声明版本</span><br><br><span class="hljs-attr">networks:</span><span class="hljs-comment"># 定义网络: 一个前端,一个后端</span><br>  <span class="hljs-attr">frontend:</span><br>  <span class="hljs-attr">backend:</span><br><br><span class="hljs-attr">volumes:</span><span class="hljs-comment"># 定义数据卷</span><br>  <span class="hljs-attr">db-data:</span><br><br><span class="hljs-attr">services:</span><span class="hljs-comment"># 定义服务</span><br>  <span class="hljs-attr">redis:</span><span class="hljs-comment"># 服务名:redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:alpine</span><span class="hljs-comment"># 镜像</span><br>    <span class="hljs-attr">ports:</span><span class="hljs-comment"># 端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379&quot;</span><br>    <span class="hljs-attr">networks:</span><span class="hljs-comment"># 连接网络</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">deploy:</span><span class="hljs-comment"># 部署</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">update_config:</span><br>        <span class="hljs-attr">parallelism:</span> <span class="hljs-number">2</span><br>        <span class="hljs-attr">delay:</span> <span class="hljs-string">10s</span><br>      <span class="hljs-attr">restart_policy:</span><br>        <span class="hljs-attr">condition:</span> <span class="hljs-string">on-failure</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:9.4</span><br>    <span class="hljs-attr">volumes:</span><span class="hljs-comment"># 数据卷</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db-data:/var/lib/postgresql/data</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">placement:</span><br>        <span class="hljs-attr">max_replicas_per_node:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">constraints:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;node.role==manager&quot;</span><br></code></pre></td></tr></table></figure><p>每个服务都必须通过 image 指令指定镜像或 build 指令(需要 Dockerfile)等来自动构建生成镜像; 如果使用 build 指令, 在 Dockerfile 中设置的选项(如: CMD, EXPOSE, VOLUME, ENV等)将会自动被获取, 无需在 docker-compose.yml 中再次设置</p>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker数据挂载</title>
    <link href="/2021/02/26/docker%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD/"/>
    <url>/2021/02/26/docker%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="一-数据管理"><a href="#一-数据管理" class="headerlink" title="一 : 数据管理"></a>一 : 数据管理</h2><p>在容器中管理数据主要有两种方式</p><ul><li>数据卷 (Volumes)</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="二-数据卷"><a href="#二-数据卷" class="headerlink" title="二 : 数据卷"></a>二 : 数据卷</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p><strong>数据卷</strong>是一个可供一个或多个容器使用的特殊目录, 它绕过 UFS(Unix文件系统), 可以提供很多有用的<strong>特性</strong></p><ol><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新, 不会影响镜像</li><li>数据卷默认会一直存在, 即使容器被删除</li></ol><p>Docker 中提供了<strong>两种挂载方式</strong>, <code>-v</code> 和 <code>--mount</code> , 这两种方式该如何选择呢 ?</p><ul><li>Docker 新手应该选择 <code>--mount</code> 参数</li><li>经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟了, 但是推荐使用 <code>--mount</code> 参数</li></ul><p><strong>注意 :</strong> 数据卷的使用, 类似于 Linux 下对目录或文件进行 mount, 镜像中的被指定为挂载点的目录中的文件会隐藏掉, 能显示看的是挂载的数据卷</p><h3 id="二-创建数据卷"><a href="#二-创建数据卷" class="headerlink" title="(二) 创建数据卷"></a>(二) 创建数据卷</h3><p>创建一个数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create my-volume</span><br></code></pre></td></tr></table></figure><p>查看所有的数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>查看指定数据卷的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume inspect my-volume</span><br></code></pre></td></tr></table></figure><p>删除数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">rm</span> my-volume</span><br></code></pre></td></tr></table></figure><h3 id="三-挂载数据卷"><a href="#三-挂载数据卷" class="headerlink" title="(三) 挂载数据卷"></a>(三) 挂载数据卷</h3><p>启动一个挂载数据卷的容器, 在用 <code>docker run</code> 命令的时候, 使用 <code>--mount</code> 将<strong>数据卷</strong>挂载到容器里; 在一次 <code>docker run</code> 中可以挂载<strong>多个</strong>数据卷</p><p>创建一个名为 session-web 的容器, 并加载一个数据卷到容器的 <code>/webapp</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name session-web -d -p 8888:8080 \</span><br><span class="language-bash"><span class="hljs-comment"># -v my-volume:/webapp \</span></span><br><span class="language-bash">--mount <span class="hljs-built_in">source</span>=my-volume,target=/webapp \</span><br><span class="language-bash">session-web:latest</span><br></code></pre></td></tr></table></figure><p>数据卷是被设计用来持久化数据的, 它的生命周期独立于容器, Docker 不会在容器被删除后自动删除数据卷, 并且也不存在垃圾回收这样的机制来处理没有任何引用的数据卷; 如果需要在删除容器的同时移除数据卷; 可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p><p>无主的数据卷可能会占据很多空间, 要清理可以使用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume prune</span><br></code></pre></td></tr></table></figure><h2 id="三-挂载主机目录"><a href="#三-挂载主机目录" class="headerlink" title="三 : 挂载主机目录"></a>三 : 挂载主机目录</h2><h3 id="一-本地到容器"><a href="#一-本地到容器" class="headerlink" title="(一) 本地到容器"></a>(一) 本地到容器</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name session-web -d -p 8888:8080 \</span><br><span class="language-bash"><span class="hljs-comment"># -v /src/webapp:/opt/webapp \</span></span><br><span class="language-bash">--mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/opt/webapp \</span><br><span class="language-bash">session-web.latest</span><br></code></pre></td></tr></table></figure><p>示例命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code> 目录; 这个功能在进行测试的时候十分方便, 比如用户可以放置一些程序到本地目录中, 来查看容器是否正常工作</p><p>注意 :</p><ul><li>本地目录的路径必须是绝对路径</li><li>以前 : 使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹</li><li>现在 : 使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会报错</li><li><strong>Docker 挂载主机目录的默认权限是读写, 用户也可以通过增加 readonly 指定为只读</strong></li></ul><h3 id="二-容器到本地"><a href="#二-容器到本地" class="headerlink" title="(二) 容器到本地"></a>(二) 容器到本地</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --<span class="hljs-built_in">rm</span> -it \</span><br><span class="language-bash"><span class="hljs-comment"># -v $HOME/.bash_history:/root/.bash_hisory \</span></span><br><span class="language-bash">--mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="language-bash">ubuntu:17.10 \</span><br><span class="language-bash">bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样就可以记录在容器输入过的命令了</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker私有仓库</title>
    <link href="/2021/02/19/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <url>/2021/02/19/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Docker-Hub"><a href="#一-Docker-Hub" class="headerlink" title="一 : Docker Hub"></a>一 : Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 Docker Hub , 其中已经包括了数量超过 15000 的镜像; 大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现</p><h3 id="一-注册登录"><a href="#一-注册登录" class="headerlink" title="(一) 注册登录"></a>(一) 注册登录</h3><p>可以在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号</p><p>在命令行执行 <code>docker login</code> 输入用户名及密码来完成在命令行界面登录 Docker Hub; 可以通过 <code>docker logout</code> 退出登录</p><h3 id="二-拉取镜像"><a href="#二-拉取镜像" class="headerlink" title="(二) 拉取镜像"></a>(二) 拉取镜像</h3><p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像, 并利用 docker pull 命令将它下载到本地</p><h3 id="三-推送镜像"><a href="#三-推送镜像" class="headerlink" title="(三) 推送镜像"></a>(三) 推送镜像</h3><p>用户也可以在登陆后通过 <code>docker push</code> 命令来将自己的镜像推送到 <code>Docker Hub</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE<br>hello-world   latest    feb5d9fea6a5   18 months ago   13.3kB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重命名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag feb5d9fea6a5 zhang/hello-world:latest</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY         TAG       IMAGE ID       CREATED         SIZE<br>hello-world        latest    feb5d9fea6a5   18 months ago   13.3kB<br>zhang/helloworld   latest    feb5d9fea6a5   18 months ago   13.3kB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push zhang/hello-world:latest</span><br></code></pre></td></tr></table></figure><h2 id="二-私有仓库"><a href="#二-私有仓库" class="headerlink" title="二 : 私有仓库"></a>二 : 私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便, 用户可以创建一个本地仓库供私人使用; 比如基于公司内部项目构建的镜像</p><p>docker-registry 是官方提供的工具, 可以用于构建私有的镜像仓库</p><h3 id="一-安装运行-docker-registry"><a href="#一-安装运行-docker-registry" class="headerlink" title="(一) 安装运行 docker-registry"></a>(一) 安装运行 docker-registry</h3><p>可以通过过去官方 registry 镜像来运行; 默认情况下, 仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下, 默认端口号 : 5000</p><p>可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name registry -d -p 5000:5000 --restart=always \</span><br><span class="language-bash">-v /opt/data/registry:/var/lib/registry registry</span><br></code></pre></td></tr></table></figure><h3 id="二-上传-搜索-下载镜像"><a href="#二-上传-搜索-下载镜像" class="headerlink" title="(二) 上传 | 搜索 | 下载镜像"></a>(二) 上传 | 搜索 | 下载镜像</h3><p>创建好私有仓库之后, 就可以使用 docker tag 来标记一个镜像, 然后推送它到仓库</p><p>先在本机查看已有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE<br>zhang/hello-world       latest              feb5d9fea6a5        8 months ago        13.3 kB<br></code></pre></td></tr></table></figure><p>标记镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]<br></code></pre></td></tr></table></figure><p>使用 docker tag 将 zhang&#x2F;hello-world:latest 这个镜像标记为 127.0.0.1:5000&#x2F;zhang&#x2F;hello-world:latest; </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag zhang/hello-world:latest 127.0.0.1:5000/zhang/hello-world:latest</span><br></code></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push 127.0.0.1:5000/zhang/hello-world:latest</span><br></code></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl 127.0.0.1:5000/v2/_catalog<br></code></pre></td></tr></table></figure><p>如果可以看到如下信息, 表示镜像已经被成功上传了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;repositories&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;zhang/hello-world&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>先删除已有镜像, 再尝试从私有仓库中下载这个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">rm</span> 127.0.0.1:5000/zhang/hello-world:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull 127.0.0.1:5000/zhang/hello-world:latest</span><br></code></pre></td></tr></table></figure><h3 id="三-私有仓库地址"><a href="#三-私有仓库地址" class="headerlink" title="(三) 私有仓库地址"></a>(三) 私有仓库地址</h3><p>如果不想使用 <code>127.0.0.1:5000</code> 作为仓库地址, 比如想让本网段的其他主机也能把镜像推送到私有仓库; 就得把例如 <code>10.0.0.20:5000</code> 这样的内网地址作为私有仓库地址, 这时会无法成功推送镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">改名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag hello-world:latest 10.0.0.20:5000/zhang/hello-world</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">校验结果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                         TAG       IMAGE ID       CREATED         SIZE<br>registry                           latest    8db46f9d7550   7 hours ago     24.2MB<br>10.0.0.20:5000/zhang/hello-world   latest    feb5d9fea6a5   18 months ago   13.3kB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">推到私有仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push 10.0.0.20:5000/zhang/hello-world</span><br>Using default tag: latest<br>The push refers to repository [10.0.0.20:5000/zhang/hello-world]<br>Get &quot;https://10.0.0.20:5000/v2/&quot;: http: server gave HTTP response to HTTPS client<br></code></pre></td></tr></table></figure><p>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像; 我们可以通过 Docker 的配置选项来取消这个限制</p><p>对于使用 <code>systemd</code> 的系统(如: ubuntu 16.04+, Debian 8+, centos 7), 请在 <code>/etc/docker/daemon.json</code> 中写入如下内容(如果文件不存在则需要新建该文件); 对于 Docker for Windows, Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirror&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;192.168.100.100:5000&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>重启docker之后再尝试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push 10.0.0.20:5000/zhang/hello-world</span><br>Using default tag: latest<br>The push refers to repository [10.0.0.20:5000/zhang/hello-world]<br>e07ee1baac5f: Pushed <br>latest: digest: sha256:f54a58bc1aac5ea1a25d796ae155dc228b3f0e11d046ae276b39c4bf2f13d8c4 size: 525<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker运行java程序</title>
    <link href="/2021/02/05/docker%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/02/05/docker%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-运行-war-程序"><a href="#一-运行-war-程序" class="headerlink" title="一 : 运行 war 程序"></a>一 : 运行 war 程序</h2><p><code>hello-1.0.war</code> 的需要依赖 tomcat 才能提供服务, 所以定制镜像的时候需要 tomcat 作为基础镜像</p><p>编写 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> tomcat:<span class="hljs-number">7.0</span>.<span class="hljs-number">88</span>-jre8<br><span class="hljs-comment"># 作者</span><br><span class="hljs-keyword">MAINTAINER</span> allen &lt;allen@<span class="hljs-number">163</span>.com&gt;<br><span class="hljs-comment"># 定义环境变量</span><br><span class="hljs-keyword">ENV</span> TOMCAT_BASE /usr/local/tomcat<br><span class="hljs-comment"># 复制war包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./hello.war <span class="hljs-variable">$TOMCAT_BASE</span>/webapps/</span><br></code></pre></td></tr></table></figure><p>开始构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t hello:1.0 .</span><br></code></pre></td></tr></table></figure><p>查看现有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORYTAGIMAGE IDCREATEDSIZE<br>hello1.0dff88057b55251 seconds ago469 MB<br></code></pre></td></tr></table></figure><p>运行 : 将宿主机的8888端口和容器的8080端口进行映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name hello -d -p 8888:8080 hello:1.0</span><br></code></pre></td></tr></table></figure><p>测试 : 查看服务器8888端口是否被监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[yuelu@localhost sell]$ sudo netstat -anpl | grep 8888<br>tcp6       0      0 :::8888                 :::*                    LISTEN      9321/docker-proxy-c<br></code></pre></td></tr></table></figure><p>浏览器中访问 : <a href="http://ip:8888/">http://ip:8888/</a></p><h2 id="二-运行-jar-程序"><a href="#二-运行-jar-程序" class="headerlink" title="二 : 运行 jar 程序"></a>二 : 运行 jar 程序</h2><p>编写 Dockerfile 文件, 内容如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<br><span class="hljs-comment"># 作者</span><br><span class="hljs-keyword">MAINTAINER</span> achelous&lt;info4z@<span class="hljs-number">163</span>.com&gt;<br><span class="hljs-comment"># 复制jar包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./hello-1.0.jar hello.jar</span><br><span class="hljs-comment"># 执行命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;hello.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>执行构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t hello:1.0 .<br></code></pre></td></tr></table></figure><p>查看现有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                         TAG       IMAGE ID       CREATED          SIZE<br>hello                              1.0       843aef1a3352   19 seconds ago   122MB<br></code></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p 8080:8080 --name hello hello:1.0</span><br></code></pre></td></tr></table></figure><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                                       NAMES<br>9bda35727c12   hello:1.0   &quot;java -jar hello.jar&quot;    4 seconds ago   Up 3 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   hello<br></code></pre></td></tr></table></figure><p>查看端口号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -tnpl | grep 8080</span><br>(No info could be read for &quot;-p&quot;: geteuid()=1000 but you should be root.)<br>tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      -                   <br>tcp6       0      0 :::8080                 :::*                    LISTEN      -<br></code></pre></td></tr></table></figure><p>访问 : <a href="http://ip:8080/">http://ip:8080/</a></p>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker私有镜像</title>
    <link href="/2021/01/29/docker%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F/"/>
    <url>/2021/01/29/docker%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Dockerfile入门"><a href="#一-Dockerfile入门" class="headerlink" title="一 : Dockerfile入门"></a>一 : Dockerfile入门</h2><p>镜像的定制实际上就是定制每一层所添加的配置, 文件; 我们可以把每一层修改, 安装, 构建, 操作的命令都写入一个脚本, 这个脚本就是 Dockerfile; <strong>Dockerfile 是一个文本文件, 其内包含了一条条的指令, 每一条指令构建一层, 因此每一条指令的内容, 就是描述该层应当如何构建</strong>。</p><p>入门案例 : 以官方 nginx 镜像为例, 使用 Dockerfile 来定制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在一个空白目录中, 建立一个文本文件, 并命名为 Dockerfile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> mynginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> mynginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> Dockerfile</span><br></code></pre></td></tr></table></figure><p>这个 Dockerfile 很简单, 一共就两行; 涉及到了两条指令, <strong>FROM</strong> 和 <strong>RUN</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><p>构建镜像, 不要忘记最后的 <code>.</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 Dockerfile 文件所在目录执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t nginx:v1.0 .</span><br></code></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE<br>nginx         v1.0      64e674311108   3 minutes ago   142MB<br></code></pre></td></tr></table></figure><h3 id="一-FROM-指定基础镜像"><a href="#一-FROM-指定基础镜像" class="headerlink" title="(一) FROM 指定基础镜像"></a>(一) FROM 指定基础镜像</h3><p>所谓定制镜像, 一定是以一个镜像为基础, 在其上进行定制; 基础镜像是必须指定的, 而 FROM 就是指定基础镜像, 因此一个 Dockerfile 中 FROM 是<strong>必备的指令</strong>, 并且<strong>必须是第一条</strong>指令。</p><p>在 Docker Hub 上有非常多的高质量的官方镜像, 有可以直接拿来使用的服务类的镜像, 如 nginx, redis, mysql, tomcat 等; 可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制; 如果没有找到对应服务的镜像, 官方镜像中还提供了一些更为基础的操作系统镜像, 如 ubuntu, debian, centos, alpine 等, 这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外, Docker 还存在一个特殊的镜像, 名为 scratch; 这个镜像是虚拟的概念, 并不实际存在, 它表示一个<strong>空白的镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<br>...<br></code></pre></td></tr></table></figure><p>如果你以 scratch 为基础镜像的话, 意味着你不以任何镜像为基础, 接下来缩写的指令将作为镜像的第一层开始存在。</p><p>对于 linux 下静态编译的程序来说, 并不需要有操作系统提供运行时支持, 所需的一切库都已经在可执行文件里了, 因此直接 FROM scratch 会让镜像体积更加小巧; 使用 Go 语言开发的应用很多会使用这种方式来制作镜像, 这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="二-RUN-执行命令"><a href="#二-RUN-执行命令" class="headerlink" title="(二) RUN 执行命令"></a>(二) RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的; 由于命令行的强大能力, RUN 指令在定制镜像时是<strong>最常用</strong>的指令之一; 其格式有两种 : </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 1.shell格式: RUN &lt;命令&gt;</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> `&lt;h1&gt;Hello,Docker!&lt;/h1&gt;` &gt; /usr/share/nginx/html/index.html</span><br><span class="hljs-comment"># 2.exec格式: RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>]<span class="hljs-comment"># 等价于 RUN ./test.php dev offline</span></span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层, 会造成镜像膨胀过大。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum install -y wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>以上执行会创建 3 层镜像。可简化为以下格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget \</span><br><span class="language-bash">&amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">&amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>如上, 以 <code>&amp;&amp;</code> 符号连接命令, 这样执行后, 只会创建 1 层镜像。</p><h2 id="二-构建镜像"><a href="#二-构建镜像" class="headerlink" title="二 : 构建镜像"></a>二 : 构建镜像</h2><p>语法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span><span class="hljs-string">docker</span> <span class="hljs-string">build</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">PATH</span> <span class="hljs-string">|</span> <span class="hljs-string">URL</span> <span class="hljs-string">|</span> <span class="hljs-bullet">-</span><br><span class="hljs-string">Build</span> <span class="hljs-string">an</span> <span class="hljs-string">image</span> <span class="hljs-string">from</span> <span class="hljs-string">a</span> <span class="hljs-string">Dockerfile</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t nginx:v1.0 .</span><br>Sending build context to Docker daemon 2.048 kB<br>Step 1/2 : FROM nginx<br>Trying to pull repository docker.io/library/nginx ... <br>latest: Pulling from docker.io/library/nginx<br>f1f26f570256: Pull complete <br>7f7f30930c6b: Pull complete <br>2836b727df80: Pull complete <br>e1eeb0f1c06b: Pull complete <br>86b2457cc2b0: Pull complete <br>9862f2ee2e8c: Pull complete <br>Digest: sha256:2ab30d6ac53580a6db8b657abf0f68d75360ff5cc1670a85acb5bd85ba1b19c0<br>Status: Downloaded newer image for docker.io/nginx:latest<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">080ed0ed8312</span><br>Step 2/2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> a541be57c6df</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">8d8b91b5def2</span><br>Removing intermediate container a541be57c6df<br>Successfully built 8d8b91b5def2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从命令的输出结果中, 我们可以清晰的看到镜像的构建过程;</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在Step2中,RUN指令启动了一个容器a541be57c6df,执行了指定命令,并提交了这一层8d8b91b5def2,随后删除了a541be57c6df容器</span><br></code></pre></td></tr></table></figure><p>注 : 指令最后的那个<code>.</code> 表示<strong>上下文路径</strong>, 是指 docker 在构建镜像, 有时候想要使用到本机的文件(比如复制), docker build 命令得知这个路径后, 会将路径下的所有内容打包。因此, 上下文路径下不要放无用的文件, 因为会一起打包发送给 docker 引擎, 如果文件过多会造成过程缓慢。</p><h2 id="三-Dockerfile-指令详解"><a href="#三-Dockerfile-指令详解" class="headerlink" title="三 : Dockerfile 指令详解"></a>三 : Dockerfile 指令详解</h2><h3 id="一-COPY"><a href="#一-COPY" class="headerlink" title="(一) COPY"></a>(一) COPY</h3><p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件或目录<strong>复制</strong>到新的一层的镜像内的 &lt;目标路径&gt; 位置; &lt;目标路径&gt; 是容器内的指定路径, 该路径不用事先建好, 路径不存在的话, 会自动创建。</p><p>语法格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br><span class="hljs-comment"># [--chown=&lt;user&gt;:&lt;group&gt;]: 可选参数,用户改变复制到容器内文件的拥有者和属组</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span><br></code></pre></td></tr></table></figure><p>&lt;源路径&gt; 可以是多个, 甚至可以是通配符, 如 : </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><h3 id="二-ADD"><a href="#二-ADD" class="headerlink" title="(二) ADD"></a>(二) ADD</h3><p><strong>更高级的复制文件</strong>, ADD 指令和 COPY 的格式和性质基本一致; 但是在 COPY 基础上增加了一下功能。</p><p>比如 &lt;源路径&gt; 可以是一个 URL, 这种情况下, docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。</p><p>在 docker 官方的 Dockerfile 最佳实践文档中要求, <strong>尽可能的使用 COPY</strong>, 因为 COPY 的语义很明确, 就是复制文件而已, 而 ADD 则包含了更复杂的功能, 其行为也不一定很清晰; 最适合使用 ADD 的场合, 就是所提及的需要自动解压缩的场合; 因此, 在 COPY 和 ADD 指令中选择的时候, 可以遵循这样的原则, <strong>所有的文件复制均使用 COPY 指令, 仅在需要自动解压缩的场合使用 ADD</strong></p><h3 id="三-CMD"><a href="#三-CMD" class="headerlink" title="(三) CMD"></a>(三) CMD</h3><p>为启动的容器<strong>指定默认要运行的程序和参数</strong>, 程序运行结束, 容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p>格式 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] <span class="hljs-comment"># 推荐,执行过程中第一种在会自动转换为这种,且默认可执行文件是sh</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为ENTRYPOINT指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>类似于 RUN 指令, 用于运行程序, 但二者运行的时间点不同</p><ul><li>CMD 在docker run 时运行</li><li>RUN 是在 docker build 时运行</li></ul><p><strong>注意 :</strong> 如果 Dockerfile 中如果存在多个 CMD 指令, 仅最后一个生效。</p><h3 id="四-ENTRYPOINT"><a href="#四-ENTRYPOINT" class="headerlink" title="(四) ENTRYPOINT"></a>(四) ENTRYPOINT</h3><p>和 CMD 一样, 都是在<strong>指定容器启动程序及参数</strong>, 但其不会被 docker run 的命令行参数指定的指令所覆盖, 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是, 如果 docker run 时使用了 <code>--entrypoint</code> 选项, 将覆盖 ENTRYPOINT 指令指定的程序。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p><strong>优点 :</strong> 在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意 :</strong> 如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令, 仅最后一个生效。</p><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD , 这里的 CMD 等于是在给 ENTRYPOINT 传参</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 构建镜像 nginx:test</span><br><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 不传参运行</span><br>$ docker run nginx:<span class="hljs-built_in">test</span><span class="hljs-comment"># 相当于容器启动进程 nginx -c /etc/nginx/nginx.conf</span><br><span class="hljs-comment"># 传参运行</span><br>$ docker run nginx:<span class="hljs-built_in">test</span> -c /etc/nginx/new.conf<span class="hljs-comment"># # 相当于容器启动进程 nginx -c /etc/nginx/new.conf</span><br></code></pre></td></tr></table></figure><h3 id="五-ENV"><a href="#五-ENV" class="headerlink" title="(五) ENV"></a>(五) ENV</h3><p><strong>设置环境变量</strong>, 定义了环境变量, 那么在后续的指令中, 就可以使用这个环境变量。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">&amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="六-ARG"><a href="#六-ARG" class="headerlink" title="(六) ARG"></a>(六) ARG</h3><p><strong>构建参数</strong>, 与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效, 也就是说只有 docker build 的过程中有效, 构建好的镜像内不存在此环境变量。但是不要因此就使用 ARG 保存密码之类的信息, 因为 docker history 还是可以看到所有值的</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]<br></code></pre></td></tr></table></figure><p><strong>注意 :</strong> 构建命令 docker build 中可以用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h3 id="七-VOLUME"><a href="#七-VOLUME" class="headerlink" title="(七) VOLUME"></a>(七) VOLUME</h3><p><strong>定义匿名数据卷</strong>。在启动容器时忘记挂载数据卷, 会自动挂载到匿名卷。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>避免重要的数据, 因容器重启而丢失, 这是非常致命的。</li><li>避免容器不断变大。</li></ul><p><strong>注意 :</strong> 在启动容器 docker run 的时候, 我们可以通过 -v 参数修改挂载点。</p><p>容器运行时应该尽量保存容器存储层不发生写操作, 对于数据库类需要保存动态数据看应用, 其数据库文件应该保存于卷(volume)中, 为了防止运行时用户忘记将动态文件所保存目录挂载为卷, Dockerfile 中, 我们可以实现指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载, 其应用也可以正常运行, 不会向容器存储层写入大量数据</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 这里的/data目录就会在运行时自动挂载为匿名卷,任何向/data中写入的信息都不会记录进容器存储层,从而保证了容器存储层的无状态化</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /data</span><br></code></pre></td></tr></table></figure><p>当然, 运行时可以覆盖这个挂载设置, 比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -v mydata:/data IMAGE<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在这行命令中,就是用了mydata这个命名卷挂载到了/data这个位置,替代了Dockerfile中定义的匿名卷的挂载配置</span><br></code></pre></td></tr></table></figure><h3 id="八-EXPOSE"><a href="#八-EXPOSE" class="headerlink" title="(八) EXPOSE"></a>(八) EXPOSE</h3><p>仅仅只是<strong>声明端口</strong>, 在运行时并不会因为这个声明应用就会开启这个端口的服务</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射。</li><li>在运行时使用随机端口映射时, 也就是 <code>docker run -P</code> 时, 会自动随机映射 EXPOSE 的端口。</li></ul><h3 id="九-WORKDIR"><a href="#九-WORKDIR" class="headerlink" title="(九) WORKDIR"></a>(九) WORKDIR</h3><p><strong>指定工作目录</strong>。用 WORKDIR 指定的工作目录, 会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录, 如该目录不存在, WORKDIR 会帮你建立目录。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> &lt;工作目录路径&gt;</span><br></code></pre></td></tr></table></figure><p>docker build 构建镜像过程中的, 每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>这里说一个重点: 不要把 Dockerfile 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br><span class="hljs-comment"># 如果将这个Dockerfile进行构建镜像运行后,会发现找不到/app/world.txt文件</span><br></code></pre></td></tr></table></figure><p>原因分析 : </p><ul><li>在 Shell 中, 连续两行是同一个进程执行环境, 因此前一个命令修改的内存状态, 会直接影响后一个命令</li><li>而在 Dockerfile 中, 这两行 RUN 命令的执行环境根本不同, 是两个完全不同的容器</li></ul><p>这就是对 Dockerfile 构建分层存储的概念不了解导致的错误</p><ul><li>每一个 RUN 都是启动一个容器, 执行命令, 然后提交存储层文件变更</li><li>第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更; 而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化</li><li>因此如果需要改变以后各层的工作目录的位置, 那么应该使用 <code>WORKDIR</code> 指令</li></ul><h3 id="十-USER"><a href="#十-USER" class="headerlink" title="(十) USER"></a>(十) USER</h3><p>用于指定<strong>执行后续命令的用户和用户组</strong>, 这边只是切换后续命令执行的用户(用户和用户组必须提前已经存在)。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> &lt;用户名&gt;[:&lt;用户组&gt;]<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="hljs-keyword">USER</span> redis<br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;redis-server&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="十一-HEALTHCHECK"><a href="#十一-HEALTHCHECK" class="headerlink" title="(十一) HEALTHCHECK"></a>(十一) HEALTHCHECK</h3><p><strong>健康检查</strong>, 用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;<span class="hljs-comment"># 设置检查容器健康状况的命令</span></span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE<span class="hljs-comment"># 如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令</span></span><br><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;<span class="hljs-comment"># 这边CMD后面跟随的命令使用,可以参考CMD的用法。</span></span><br></code></pre></td></tr></table></figure><p><strong>HEALTHCHECK</strong> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常, 这是 Docker 1.12 引入的新指令; 通过该指令指定一行命令, 用这个命令来判断容器主进程的服务状态是否还正常, 从而比较真是的反应容器实际状态</p><p>一个镜像制定了 HEALTHCHECK 指令之后, 用其启动容器, 初始状态会为 starting, 在执行健康检查成功后变为 healthy, 如果连续一定次数失败, 则会变为 unhealthy</p><p>HEALTHCHECK 支持下列选项</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>–interval&#x3D;&lt;间隔&gt;</td><td>两次健康检查的间隔, 默认为30秒</td></tr><tr><td>–timeout&#x3D;&lt;时长&gt;</td><td>健康检查命令运行超时时间, 如果超过这个时间, 本次健康检查就被视为失败, 默认 30 秒</td></tr><tr><td>–retries&#x3D;&lt;次数&gt;</td><td>当连续失败指定次数后, 则将容器状态是为 unhealthy, 默认 3 次</td></tr></tbody></table><p>为了帮助排障, 健康检查命令的输出(包括stdout以及stderr)都会被存储于健康状态里, 可以用 <code>docker inspect</code> 来查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Return low-level information on Docker objects</span><br>$ docker inspect<br></code></pre></td></tr></table></figure><h3 id="十二-ONBUILD"><a href="#十二-ONBUILD" class="headerlink" title="(十二) ONBUILD"></a>(十二) ONBUILD</h3><p>用于<strong>延迟构建</strong>命令的执行。简单的说, 就是 Dockerfile 里用 ONBUILD 指定的命令, 在本次构建镜像的过程中不会执行(假设镜像为  test-build)。当有新的 Dockerfile 使用了之前构建的镜像 <code>FROM test-build</code> , 这时执行新镜像的  Dockerfile 构建时候, 会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> &lt;其它指令&gt;<br></code></pre></td></tr></table></figure><p>Dockerfile 中的其他指令都是为了定制当前镜像而准备的, 唯有 ONBUILD 是为了帮着别人定制自己而准备的</p><h2 id="四-其他制作镜像方式"><a href="#四-其他制作镜像方式" class="headerlink" title="四 : 其他制作镜像方式"></a>四 : 其他制作镜像方式</h2><p>Docker 还提供了 docker load 和 docker save 命令, 用以将镜像保持为一个 tar 文件, 然后传输到另一个位置上, 再加载进来; </p><p>这是在没有 Docker Registry 时的做法, 现在已经不推荐, 镜像迁移应该直接使用 Docker Registry, 无论是直接使用 Docker Hub 还是是使用内网私有 Registry 都可以</p><p>例如 : 保存 nginx 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker save nginx | gzip &gt; nginx-latest.tar.gz</span><br></code></pre></td></tr></table></figure><p>然后我们将 nginx-latest.tar.gz 文件复制到了另一个机器上, 再次加载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load -i nginx-latest.tar.gz</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker常用命令</title>
    <link href="/2021/01/22/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/01/22/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一-docker-镜像操作"><a href="#一-docker-镜像操作" class="headerlink" title="一 : docker 镜像操作"></a>一 : docker 镜像操作</h2><p>docker 运行容器前需要本地存在对应的镜像; 如果本地不存在该镜像, docker 会从镜像仓库下载该镜像</p><h3 id="一-查找镜像"><a href="#一-查找镜像" class="headerlink" title="(一) 查找镜像"></a>(一) 查找镜像</h3><p>这个命令不常用, 通常习惯直接在<a href="https://hub.docker.com/">dockerhub</a>上搜索</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">search</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">TERM</span><br><span class="hljs-string">Search</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Hub</span> <span class="hljs-string">for</span> <span class="hljs-string">images</span><br></code></pre></td></tr></table></figure><p>命令示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search ubuntu</span><br></code></pre></td></tr></table></figure><h3 id="二-下载镜像"><a href="#二-下载镜像" class="headerlink" title="(二) 下载镜像"></a>(二) 下载镜像</h3><p>从 docker 镜像仓库获取镜像的命令是 <code>docker pull</code>; 其命令格式为 : </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">pull</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">NAME[:TAG|@DIGEST]</span><br><span class="hljs-string">Download</span> <span class="hljs-string">an</span> <span class="hljs-string">image</span> <span class="hljs-string">from</span> <span class="hljs-string">a</span> <span class="hljs-string">registry</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">pull,</span> <span class="hljs-string">docker</span> <span class="hljs-string">pull</span><br></code></pre></td></tr></table></figure><p>具体的选项可用通过 <code>docker pull --help</code> 命令看到, 这里我们说一下镜像名称的格式;</p><ol><li>docker 镜像仓库地址 : 地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> ; 默认地址是 Docker Hub</li><li>仓库名 : 这里的仓库名是两段式名称, 即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code> ; 对于 docker hub, 如果不给出用户名, 则默认为 library, 也就是官方镜像</li></ol><p>命令示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull ubuntu:16.04</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令中没有给出docker镜像仓库地址, 因此将会从docker hub获取镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">镜像名称是ubuntu:16.04,因此将会从官方镜像library/ubuntu仓库中标签为16.04的镜像</span><br></code></pre></td></tr></table></figure><h3 id="三-运行镜像"><a href="#三-运行镜像" class="headerlink" title="(三) 运行镜像"></a>(三) 运行镜像</h3><p>有了镜像后, 我们就能够以这个镜像为基础启动并运行一个容器; 语法 : </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">run</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">IMAGE</span> [<span class="hljs-string">COMMAND</span>] [<span class="hljs-string">ARG...</span>]<br><span class="hljs-string">Create</span> <span class="hljs-string">and</span> <span class="hljs-string">run</span> <span class="hljs-string">a</span> <span class="hljs-string">new</span> <span class="hljs-string">container</span> <span class="hljs-string">from</span> <span class="hljs-string">an</span> <span class="hljs-string">image</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">run,</span> <span class="hljs-string">docker</span> <span class="hljs-string">run</span><br><span class="hljs-comment"># 这个命令是容器操作命令,这里先简单提一下</span><br></code></pre></td></tr></table></figure><p>以上面的 ubuntu:16.04 为例, 如果我们打算启动里面的 bash 并且进行交互式操作的话, 可用执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="hljs-built_in">rm</span> ubuntu:16.04 bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-it: 这是两个参数,一个是-i,交互式操作,一个是`-t`终端</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--<span class="hljs-built_in">rm</span>: 这个参数是说容器退出后随之将其删除</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ubuntu:16.04: 这是指用ubuntu:16.04镜像为基础来启动容器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bash: 放在镜像名后的是命令,这里我们希望有个交互式 shell,因此用的是bash</span><br>root@28ad92b30c8f:/# exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过<span class="hljs-built_in">exit</span>退出这个容器</span><br></code></pre></td></tr></table></figure><h3 id="四-列出镜像"><a href="#四-列出镜像" class="headerlink" title="(四) 列出镜像"></a>(四) 列出镜像</h3><p>要想列出已经下载下来的镜像, 可以使用 <code>docker image ls</code> 命令; 列表包含了<strong>仓库名</strong>, <strong>标签</strong>, <strong>镜像ID</strong>, <strong>创建时间</strong>以及<strong>所占用的空间</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>查看镜像, 容器, 数据卷所占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker system <span class="hljs-built_in">df</span></span><br></code></pre></td></tr></table></figure><p>仓库名, 标签均为 <code>&lt;none&gt; </code> 的镜像称为虚悬镜像(dangling image), 显示这类镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> -f dangling=<span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure><p>一般来说, 虚悬镜像已经失去了存在的价值, 是可以随意删除的, 可以用下面的命令删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image prune</span><br></code></pre></td></tr></table></figure><h3 id="五-删除本地镜像"><a href="#五-删除本地镜像" class="headerlink" title="(五) 删除本地镜像"></a>(五) 删除本地镜像</h3><p>如果要删除本地的镜像, 可以使用 <code>docker image rm</code> 命令, 其格式为 : </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">rm</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">IMAGE</span> [<span class="hljs-string">IMAGE...</span>]<br><span class="hljs-string">Remove</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">images</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">rm,</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">remove,</span> <span class="hljs-string">docker</span> <span class="hljs-string">rmi</span><br></code></pre></td></tr></table></figure><p>使用 <code>docker image ls -q</code> 来配合 <code>docker image rm</code>, 这样可以批量删除希望删除的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有镜像名为 ubuntu 的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">rm</span> $(docker image <span class="hljs-built_in">ls</span> -q ubuntu)</span><br></code></pre></td></tr></table></figure><p>或者删除所有在 ubuntu:16.04 之前的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image <span class="hljs-built_in">rm</span> $(docker image <span class="hljs-built_in">ls</span> -q -f before=ubuntu:16.04)</span><br></code></pre></td></tr></table></figure><h3 id="六-导出与导入"><a href="#六-导出与导入" class="headerlink" title="(六) 导出与导入"></a>(六) 导出与导入</h3><p>导出语法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">save</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">IMAGE</span> [<span class="hljs-string">IMAGE...</span>]<br><span class="hljs-string">Save</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">images</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">tar</span> <span class="hljs-string">archive</span> <span class="hljs-string">(streamed</span> <span class="hljs-string">to</span> <span class="hljs-string">STDOUT</span> <span class="hljs-string">by</span> <span class="hljs-string">default)</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">save,</span> <span class="hljs-string">docker</span> <span class="hljs-string">save</span><br></code></pre></td></tr></table></figure><p>导入语法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">load</span> [<span class="hljs-string">OPTIONS</span>]<br><span class="hljs-string">Load</span> <span class="hljs-string">an</span> <span class="hljs-string">image</span> <span class="hljs-string">from</span> <span class="hljs-string">a</span> <span class="hljs-string">tar</span> <span class="hljs-string">archive</span> <span class="hljs-string">or</span> <span class="hljs-string">STDIN</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">load,</span> <span class="hljs-string">docker</span> <span class="hljs-string">load</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">导出镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker save imageID &gt; /目录/文件名.tar</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; 文件名.tar</span><br></code></pre></td></tr></table></figure><h2 id="二-docker-容器操作"><a href="#二-docker-容器操作" class="headerlink" title="二 : docker 容器操作"></a>二 : docker 容器操作</h2><p>容器是独立运行的一个或一组应用, 以及它们的运行态环境; 对应的, 虚拟机可以理解为模拟运行的一整套操作系统(提供了运行态环境和其他系统环境)和跑在上面的应用</p><h3 id="一-启动容器"><a href="#一-启动容器" class="headerlink" title="(一) 启动容器"></a>(一) 启动容器</h3><p>启动容器有两种方式, 一种是基于镜像新建一个容器并启动, 另外一个是将终止状态(stopped)的容器重新启动; 因为 docker 的容器实是轻量级的, 用户可以随时删除和新创建容器</p><p><strong>1: 新建并启动</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">run</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">IMAGE</span> [<span class="hljs-string">COMMAND</span>] [<span class="hljs-string">ARG...</span>]<br><span class="hljs-string">Create</span> <span class="hljs-string">and</span> <span class="hljs-string">run</span> <span class="hljs-string">a</span> <span class="hljs-string">new</span> <span class="hljs-string">container</span> <span class="hljs-string">from</span> <span class="hljs-string">an</span> <span class="hljs-string">image</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">run,</span> <span class="hljs-string">docker</span> <span class="hljs-string">run</span><br></code></pre></td></tr></table></figure><p>输出一个 “hello world”, 之后终止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run ubuntu:16.04 /bin/echo <span class="hljs-string">&#x27;Hello World&#x27;</span></span><br></code></pre></td></tr></table></figure><p><strong>2: 启动已终止容器</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">start</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">CONTAINER</span> [<span class="hljs-string">CONTAINER...</span>]<br><span class="hljs-string">Start</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">stopped</span> <span class="hljs-string">containers</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">start,</span> <span class="hljs-string">docker</span> <span class="hljs-string">start</span><br></code></pre></td></tr></table></figure><p>启动一个 bash 终端, 允许用户进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -t -i ubuntu:16.04 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t: 让docker分配一个伪终端并绑定到容器的标准输入上</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-i: 让容器的标准输入保持打开</span><br></code></pre></td></tr></table></figure><p><strong>3: 创建容器时在后台运行的标准操作</strong></p><table><thead><tr><th>步骤</th><th>操作内容</th></tr></thead><tbody><tr><td>1</td><td>检查本地是否存在指定的镜像, 不存在就从公有仓库下载</td></tr><tr><td>2</td><td>利用镜像创建并启动一个容器</td></tr><tr><td>3</td><td>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层</td></tr><tr><td>4</td><td>从宿主机配置的网桥接一个虚拟接口到容器中去</td></tr><tr><td>5</td><td>从地址池配置一个 ip 地址给容器</td></tr><tr><td>6</td><td>执行用户指定的应用程序</td></tr><tr><td>7</td><td>执行完毕后容器被终止</td></tr></tbody></table><h3 id="二-后台运行"><a href="#二-后台运行" class="headerlink" title="(二) 后台运行"></a>(二) 后台运行</h3><p>很多时候, 需要让 docker 在后台运行儿不是直接把执行命令的结果输出在当前宿主机下</p><p>此时, 可以通过添加 <code>-d</code> 参数来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d hello-world</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不使用-d参数运行容器,会把日志打印在控制台</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果使用了-d参数运行容器,不会输出日志,只会打印容器<span class="hljs-built_in">id</span>(输出结果可以用docker logs查看)</span><br></code></pre></td></tr></table></figure><p><strong>注意 :</strong> 后台运行不是长久运行, 容器是否会长久运行, 是和 docker run 指定的命令有关, 和 <code>-d</code> 参数无关</p><h3 id="三-查看容器"><a href="#三-查看容器" class="headerlink" title="(三) 查看容器"></a>(三) 查看容器</h3><p>查看运行中容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker container <span class="hljs-built_in">ls</span></span><br></code></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker container <span class="hljs-built_in">ls</span> -a</span><br></code></pre></td></tr></table></figure><h3 id="四-停止运行的容器"><a href="#四-停止运行的容器" class="headerlink" title="(四) 停止运行的容器"></a>(四) 停止运行的容器</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">stop</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">CONTAINER</span> [<span class="hljs-string">CONTAINER...</span>]<br><span class="hljs-string">Stop</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">running</span> <span class="hljs-string">containers</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">stop,</span> <span class="hljs-string">docker</span> <span class="hljs-string">stop</span><br></code></pre></td></tr></table></figure><p>处于终止状态的容器, 可以通过 <code>docker container start</code> 命令来重新启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage:  docker container start [OPTIONS] CONTAINER [CONTAINER...]<br>Start one or more stopped containers<br>Aliases:<br>  docker container start, docker start<br></code></pre></td></tr></table></figure><p>此外, <code>docker container restart</code> 命令会将一个运行态的容器终止, 然后再重新启动它</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">restart</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">CONTAINER</span> [<span class="hljs-string">CONTAINER...</span>]<br><span class="hljs-string">Restart</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">containers</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">restart,</span> <span class="hljs-string">docker</span> <span class="hljs-string">restart</span><br></code></pre></td></tr></table></figure><h3 id="五-进入容器"><a href="#五-进入容器" class="headerlink" title="(五) 进入容器"></a>(五) 进入容器</h3><p>在使用 <code>-d</code> 参数时, 容器启动后会进入后台, 某些时候需要进入容器进行操作, 使用 <code>docker exec</code> 命令可以进入到运行中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">exec</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">CONTAINER</span> <span class="hljs-string">COMMAND</span> [<span class="hljs-string">ARG...</span>]<br><span class="hljs-string">Execute</span> <span class="hljs-string">a</span> <span class="hljs-string">command</span> <span class="hljs-string">in</span> <span class="hljs-string">a</span> <span class="hljs-string">running</span> <span class="hljs-string">container</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">exec,</span> <span class="hljs-string">docker</span> <span class="hljs-string">exec</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器ID /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span>后边可以跟多个参数,这里主要说明-i和-t参数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">只用-i参数时,由于没有分配伪终端,界面没有我们熟悉的linux命令提示符,但命令执行结果仍然可以返回</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当-i和-t参数一起使用时,则可以看到我们熟悉的 linux 命令提示符</span><br></code></pre></td></tr></table></figure><h3 id="六-导出和导入容器"><a href="#六-导出和导入容器" class="headerlink" title="(六) 导出和导入容器"></a>(六) 导出和导入容器</h3><p><strong>1: 导出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要导出本地某个容器,可以使用docker <span class="hljs-built_in">export</span>命令</span><br>docker export 容器ID &gt; 导出文件名.tar<br></code></pre></td></tr></table></figure><p><strong>2: 导入容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 docker import从容器快照文件中再导入为镜像</span><br>docker import [选项] file|URL|- [REPOSITORY[:TAG]]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>cat 导出文件名.tar | docker import - 镜像用户/镜像名:镜像版本<br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以通过指定 URL 或者某个目录来导入</span><br>docker import http://xxx.xxx.com/image.tgz- example/imagerepo<br></code></pre></td></tr></table></figure><h3 id="七-删除容器"><a href="#七-删除容器" class="headerlink" title="(七) 删除容器"></a>(七) 删除容器</h3><p><strong>1: 删除容器</strong></p><p>语法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">rm</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">CONTAINER</span> [<span class="hljs-string">CONTAINER...</span>]<br><span class="hljs-string">Remove</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">containers</span><br><span class="hljs-attr">Aliases:</span><br>  <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">rm,</span> <span class="hljs-string">docker</span> <span class="hljs-string">container</span> <span class="hljs-string">remove,</span> <span class="hljs-string">docker</span> <span class="hljs-string">rm</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用docker container <span class="hljs-built_in">rm</span>来删除一个处于终止状态的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker container <span class="hljs-built_in">rm</span> ubuntu:16.04</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要删除一个运行中的容器,可以添加-f参数; docker会发送SIGKILL信号给容器</span><br></code></pre></td></tr></table></figure><p><strong>2: 清理所有处于终止状态的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker container prune</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装</title>
    <link href="/2021/01/15/docker%E5%AE%89%E8%A3%85/"/>
    <url>/2021/01/15/docker%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="一-docker-版本命名"><a href="#一-docker-版本命名" class="headerlink" title="一 : docker 版本命名"></a>一 : docker 版本命名</h2><p>docker 在 1.13 版本之后, 从2017年的3月1日开始, 版本命名规则变为如下</p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>版本格式</td><td>YY.MM</td></tr><tr><td>Stable 版本</td><td>每个季度发行</td></tr><tr><td>Edge版本</td><td>每个月发行</td></tr></tbody></table><p>同时 docker 划分为 CE 和 EE</p><ul><li>CE : 即社区版, 免费, 支持周期三个月</li><li>EE : 即企业版, 强调安全, 付费使用</li></ul><h2 id="二-docker-安装"><a href="#二-docker-安装" class="headerlink" title="二 : docker 安装"></a>二 : docker 安装</h2><p>官方网站上有各种环境下的安装指南, 这里主要介绍 docker CE 在 linux 上的安装</p><p>官方安装指南地址: <a href="https://docs.docker.com/engine/installation">https://docs.docker.com/engine/installation</a></p><p>系统要求 : docker CE 支持 64 位版本 Centos 7, 并且要求内核版本不低于 3.10</p><h3 id="一-安装"><a href="#一-安装" class="headerlink" title="(一) 安装"></a>(一) 安装</h3><p>旧版本的 Docker 称为 docker 或者 docker-engine, 使用以下命令卸载旧版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker docker-common docker-selinux docker-engine</span><br></code></pre></td></tr></table></figure><p>使用yum安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install docker-ce</span><br></code></pre></td></tr></table></figure><p>注意 : 如果安装的是centos 7 minimal 版本, 执行安装提示没有可用软件包, 需要安装必要的软件依赖及更新增加 docker-ce yum 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo wget https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure><p>在测试或开发环境中 docker 官方为了简化安装流程, 提供了一套便捷的安装脚本, CentOS 系统上可用使用这套脚本安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行这个命令后,脚本就会自动的将一切准备工作做好,并且把 docker CE 的 Edge 版本安装在系统中</span><br></code></pre></td></tr></table></figure><h3 id="二-启动测试"><a href="#二-启动测试" class="headerlink" title="(二) 启动测试"></a>(二) 启动测试</h3><p>启动 docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker<span class="hljs-comment"># 启动docker服务</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<span class="hljs-comment"># 设置开机启动</span></span><br></code></pre></td></tr></table></figure><p>默认情况下, docker 命令会使用 unix socket 与 docker 引擎通讯; 而只有 root 用户和 docker 组的用户才可用访问 docker 引擎的 unix socket; 一般 linux 系统上不会直接使用 root 用户进行操作; 因此, 需要将使用 docker 的用户加入 docker 用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/group | grep docker<span class="hljs-comment"># 通常会自动创建docker组</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker <span class="hljs-comment"># 如果没有就自己建立</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span> <span class="hljs-comment"># 将当前用户加入docker组</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">id</span> <span class="hljs-variable">$USER</span><span class="hljs-comment"># 查看是否添加</span></span><br></code></pre></td></tr></table></figure><p>测试 docker 是否安装正确, 若能正常输出信息, 则说明安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world <span class="hljs-comment"># 启动一个基于hello-world镜像的容器</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">newgrp docker<span class="hljs-comment"># 如果仍然报权限不足,切换有效组(好像再切回原来的组还照样可以使用)</span></span><br></code></pre></td></tr></table></figure><h2 id="三-卸载-docker"><a href="#三-卸载-docker" class="headerlink" title="三 : 卸载 docker"></a>三 : 卸载 docker</h2><p>删除 docker 安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker-ce</span><br></code></pre></td></tr></table></figure><p>删除 docker 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/docker</span><br></code></pre></td></tr></table></figure><h2 id="四-镜像加速器"><a href="#四-镜像加速器" class="headerlink" title="四 : 镜像加速器"></a>四 : 镜像加速器</h2><p>国内从 docker hub 拉取镜像有时会遇到困难, 此时可用配置镜像加速器; </p><p>docker 官方和国内很多云服务商都提供了国内加速器服务, 例如 : </p><ul><li>docker 官方提供的中国 registry mirror : <a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li><li>阿里云加速器</li><li>DaoCloud加速器 : <a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></li><li>163加速器 : <a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li></ul><h3 id="一-配置镜像加速器"><a href="#一-配置镜像加速器" class="headerlink" title="(一) 配置镜像加速器"></a>(一) 配置镜像加速器</h3><p>对于使用 systemd 的系统, 请在 <code>/etc/docker/daemon.json</code> 中写入如下内容(如果文件不存在需要新建该文件)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>重新启动服务生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h3 id="二-检查加速器是否生效"><a href="#二-检查加速器是否生效" class="headerlink" title="(二) 检查加速器是否生效"></a>(二) 检查加速器是否生效</h3><p>配置加速器之后, 如果拉取镜像仍然十分缓慢, 请手动检查加速器配置是否生效, 在命令行执行 <code>docker info</code>, 如果从结果中看到了如下内容, 说明配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br>Registry Mirrors:<br>  http://hub-mirror.c.163.com/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容器化技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx高性能应用</title>
    <link href="/2020/12/25/Nginx%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%94%E7%94%A8/"/>
    <url>/2020/12/25/Nginx%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Ngnix监听端口"><a href="#一-Ngnix监听端口" class="headerlink" title="一 : Ngnix监听端口"></a>一 : Ngnix监听端口</h2><p>基本语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span> address:port<br><span class="hljs-comment"># 默认 listen 80;</span><br></code></pre></td></tr></table></figure><p><strong>作用 :</strong> listen 参数决定 Nginx 服务器如何监听端口。在listen后可以加IP地址, 端口和主机名, 非常灵活。</p><p>示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:8000</span>;<br><span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1</span>; <span class="hljs-comment"># 默认80端口</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">8000</span>;<br><span class="hljs-attribute">listen</span> *:<span class="hljs-number">8000</span>;<br><span class="hljs-attribute">listen</span> localhost:<span class="hljs-number">8000</span>;<br></code></pre></td></tr></table></figure><p>扩展语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span> address:port [default(deprecated in in <span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">21</span>)|default_server|[backlog=num|rcvbuf=size|sndbuf=size|accept_filter=filter|deferred|bind|ipv6only=[<span class="hljs-literal">on</span>|<span class="hljs-literal">off</span>]ssl]];<br></code></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>default</td><td>将所在得server设为整个web服务的默认server块。如果没有这个设置, 那么会以在nginx.conf中找到的第一个server作为默认server。 (default_server:同上)</td></tr><tr><td>backlog&#x3D;num</td><td>表示 TCP 中 backlog 队列的大小</td></tr><tr><td>rcvbuf&#x3D;size</td><td>设置监听句柄的SO_RECVBUF参数</td></tr><tr><td>sndbuf&#x3D;size</td><td>设置监听句柄的SOSNDBUF参数</td></tr><tr><td>accept_filter</td><td>设置accept过滤器, 支队FreeBSD有用</td></tr><tr><td>deferred</td><td>在设置参数后, 若用户发起建立请求, 并且完成了TCP的三次握手, 内核也不会为这次连接调度worker进程来处理, 只有用户真的发送数据时(内核已经在网卡中收到请求包), 内核才会唤醒worker进程处理这个请求</td></tr><tr><td>bind</td><td>绑定当前端口、地址对。只有同时对一个端口监听多个地址时才会生效</td></tr><tr><td>ssl</td><td>在当前监听的端口上建立的连接必须基于SSL协议</td></tr></tbody></table><h2 id="二-Nginx虚拟主机"><a href="#二-Nginx虚拟主机" class="headerlink" title="二 : Nginx虚拟主机"></a>二 : Nginx虚拟主机</h2><table><thead><tr><th>类别</th><th>主机名</th><th>server_names_hash_bucket_size</th></tr></thead><tbody><tr><td>语法</td><td>server_name name […]</td><td>server_names_hash_bucket_size size;</td></tr><tr><td>默认</td><td>server name “”;</td><td>server_names_hash_bucket_size 32|64|128;</td></tr><tr><td>配置块</td><td>server;</td><td>http,server,location</td></tr><tr><td>作用</td><td>实现虚拟主机的关键</td><td>为了快速找到相应的server name的能力, Nginx使用散列表来存储server name<br>这个<strong>设置了桶的大小</strong></td></tr></tbody></table><h2 id="三-Nginx配置location"><a href="#三-Nginx配置location" class="headerlink" title="三 : Nginx配置location"></a>三 : Nginx配置location</h2><p>location会尝试根据用户请求中的uri来匹配上面的uri表达式, 如果可以匹配, 就选择Icoation块中的配置来处理用户请求。</p><p>语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> [=|~*|^~|@]/uri/[...]<br></code></pre></td></tr></table></figure><p>配置块 : server</p><p>匹配方式</p><table><thead><tr><th>匹配方式</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D; &#x2F;uri</td><td>表示完全匹配</td></tr><tr><td>^~ &#x2F;uri</td><td>表示匹配URI时只需要其前半部分匹配即可</td></tr><tr><td>~ &#x2F;uri</td><td>表示匹配URI时时大小写敏感的</td></tr><tr><td>~* &#x2F;uri</td><td>表示匹配URI时忽略大小写</td></tr><tr><td>&#x2F;uri</td><td>不带任何修饰符, 也表示前缀匹配, 但是在正则匹配之后</td></tr><tr><td>&#x2F;</td><td>通用匹配, 任何未匹配到其它location的请求都会匹配到, 相当于switch中的default</td></tr></tbody></table><ul><li>匹配优先级从高到低 : <code>=</code>, <code>^~</code>, <code>~/~*</code>, <code>不带符号</code></li></ul><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 前端页面</span><br><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">root</span> /opt/web;<br>&#125;<br><span class="hljs-comment"># 后端接口</span><br><span class="hljs-section">location</span> /api &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:5000;<br>    <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>&#125;<br><span class="hljs-comment"># socket接口</span><br><span class="hljs-section">location</span> /socket.io/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:5000;<br>    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>    <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-Nginx常规配置"><a href="#四-Nginx常规配置" class="headerlink" title="四 : Nginx常规配置"></a>四 : Nginx常规配置</h2><table><thead><tr><th>配置项(语法)</th><th>作用</th></tr></thead><tbody><tr><td>evn VAR|VAR&#x3D;VALUE</td><td>用户可以直接设置操作系统上的环境变量,例如 <code>evn TESTPATH=/tmp;</code></td></tr><tr><td>include &#x2F;path&#x2F;file;</td><td>可以把其他配置文件引入进来, 路径可以使绝对路径也可以是相对路径, 还可以含有通配符<code>*</code></td></tr><tr><td>pid path&#x2F;file;</td><td>保存master进程ID的pid文件存放路径, 默认<code>pid logs/nginx.pid;</code></td></tr><tr><td>user username[groupname];</td><td>master进程fork出的进程在哪个用户和用户组下,默认<code>user nobody nobody;</code></td></tr><tr><td>worker_rlimit_nofile limit;</td><td>设置一个worker可以打开的最大句柄数</td></tr><tr><td>worker_rlimit_sigpending limit;</td><td>设置每个用户发往Nginx的信号队列的大小。<br>也就是说, 当某个用户的信号队列满了, 这个用户再发送的信号量就会被丢掉。</td></tr></tbody></table><h2 id="五-Nginx高性能配置"><a href="#五-Nginx高性能配置" class="headerlink" title="五 : Nginx高性能配置"></a>五 : Nginx高性能配置</h2><p>Nginx worker 进程个数</p><table><thead><tr><th>配置项(语法)</th><th>描述</th></tr></thead><tbody><tr><td>worker_processes number;</td><td>在master worker运行方式下, 定义worker进程的个数; worker进程的数量会直接影响性能; 每个worker都是单线程的进程, 他会调用各个模块来实现各种功能; 如果确定这些模块不会出现堵塞式调用, 那么进程数可以和CPU核心数一样, 反之, 则稍少一些; 默认: <code>worker_processes 1;</code></td></tr></tbody></table><p>绑定Nginx worker进程到指定的CPU内核</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>worker_cpu_affinity cpumask [cpumask···]</td><td>假设每个worker都是很繁忙的, 如果多个进程都在抢同一个CPU, 那么就会出现同步问题。反之, 如果每个worker进程独享一个CPU, 就实现了完全的并发。举例:<code>worker_processes 4;worker_cpu_affinity 1000 0100 0010 0001:</code></td></tr></tbody></table><p>SSL硬件加速</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>ssl_engine device;</td><td>如果服务器上有SSL硬件加速设备, 那么就可以进行配置以加快SSL协议的处理速度。用户可以用OpenSSL提供的命令来查看是否有SSL硬件加速设备: <code>openssl engine-t</code></td></tr></tbody></table><p>Nginx worker进程优先级设置</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>worker_priority nice;</td><td>在Linux和Unix中, 当许多进程都处于可执行状态时, 按照优先级来决定本次内核选择哪一个进程执行。进程分配的CPU时间片大小也与优先级有关, 优先级越高, 时间片越长(例如, 在默认情况下, 最小时间片是5ms, 最大则有800ms)。优先级由静态优先级和内核根据进程的执行情况所做的动态调整(目前只有+-5的调整)共同决定。nice是进程的优先级, 他的取值范围是-20~+19, -20是最高优先级, +19是最低优先级。不建议把nice的值设为比内核进程(t通常为-5) 还要小。默认: <code>worker_priority 0;</code></td></tr></tbody></table><h2 id="六-Nginx事件配置"><a href="#六-Nginx事件配置" class="headerlink" title="六 : Nginx事件配置"></a>六 : Nginx事件配置</h2><p>是否打开accept锁</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>accept_mutex [on of];</td><td>accept_mutex是Nginx的负载均衡锁。这把锁可以让多个worker进程轮流的, 序列化的与新的客户端建立TCP连接。accept锁默认是打开的, 如果关闭它, 那么建立TCP连接的耗时会更短, 但不利于负载均衡, 因此不建议关闭。默认: <code>accept_mutex on;</code></td></tr></tbody></table><p>使用accept锁后到真正建立连接之间的延迟时间</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>accept_mutex_delay Nms;</td><td>在使用accept锁后, 同一时间只有一个worker进程能够取到accept锁。这个accept锁不是堵案锁, 如果取不到会立刻返回。如果只有一个worker进程试图取锁而没有取到, 他至少要等待accept mutex delav定义的时间才能再次试图取锁。默认: <code>accept_mutex_delay 500ms;</code></td></tr></tbody></table><p>批量建立新连接</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>multi_accept[on off];</td><td>当事件模型有新连接时, 尽可能的对本次调度中客户端发起的所有TCP请求都建立连接。默认: <code>multi_acceptoff;</code></td></tr></tbody></table><p>选择事件模型</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>use [kqueue rtsig epoll &#x2F;dev&#x2F;poll select pollleventport];</td><td>对于Linux系统, 可供选择的事件驱动模型有: poll,select,epoll三种, 一般来说, epoll是性能最高的。默认: Nginx会选出最合适的事件模型</td></tr></tbody></table><p>每个worker的最大连接数</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>worker_connections number;</td><td>定义每个worker进程可以同时处理的最大连接数</td></tr></tbody></table><h2 id="七-Nginx事件模型"><a href="#七-Nginx事件模型" class="headerlink" title="七 : Nginx事件模型"></a>七 : Nginx事件模型</h2><p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select&#x2F;poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p><pre><code class=" mermaid">graph LRA1[用户] --&gt; B[&quot;数据处理线程池&lt;br&gt;-------------------------------------------&lt;br&gt;Epoll_ct1()等待epol事件&lt;br&gt;如果某个连接的secket上有可读可写&lt;br&gt;事件则通知接收线程和发送线程处理&quot;]A2[用户] --&gt; BA3[用户] --&gt; BA4[用户] --&gt; BB --&gt; C1[&quot;Epol接收线程池&lt;br&gt;-----------------------------------&lt;br&gt;将数据放入接收链表等待处理&quot;]B --&gt; C2[&quot;发送数据线程池&lt;br&gt;------------------------------&lt;br&gt;开启一定量的线程从发送&lt;br&gt;链表中读出数据并发送&quot;]C1 --&gt; D1[接收数据链表]D2[发送数据链表] --&gt; C2D1 --&gt; E[&quot;数据处理线程池&lt;br&gt;----------------------------------&lt;br&gt;从接收数据链表中取出数据,&lt;br&gt;经过逻辑处理后,将回馈的数&lt;br&gt;据放入发送数据链表中&quot;] --&gt; D2</code></pre><p>优点</p><ul><li>支持一个进程打开大数目的socket描述符。</li><li>IO效率不随FD数目增加而线性下降。</li><li>使用mmap加速内核与用户空间的消息传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载均衡中间件</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx之Lua拓展</title>
    <link href="/2020/12/18/Nginx%E4%B9%8BLua%E6%8B%93%E5%B1%95/"/>
    <url>/2020/12/18/Nginx%E4%B9%8BLua%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ngx-lua-模块"><a href="#一-ngx-lua-模块" class="headerlink" title="一 : ngx_lua 模块"></a>一 : ngx_lua 模块</h2><p><strong>Nginx 模块</strong>需要用 C 开发，而且必须符合一系列复杂的规则，最重要的用C开发模块必须要熟悉 Nginx 的源代码，使得开发者对其望而生畏。<br><strong>ngx_lua 模块</strong>通过将 lua 解释器集成进 Nginx，可以采用 lua 脚本实现业务逻辑。</p><p>该模块具备以下<strong>特性</strong> :</p><ol><li>高并发、非阻塞的处理各种请求。</li><li>Lua内建协程，这样就可以很好的将异步回调转换成顺序调用的形式</li><li>每个协程都有一个独立的全局环境 (变量空间)，继承于全局共享的、只读的”comman data”</li></ol><p>得益于 Lua 协程的支持，ngx_lua 在处理 10000 个并发请求时只需要很少的内存。根据测试 ngx_lua 处理每个请求只需要 2KB 的内存，如果使用 LuaJIT 则会更少。<strong>ngx_lua 非常适合用于实现可扩展的、高并发的服务</strong></p><h2 id="二-协程-Coroutine"><a href="#二-协程-Coroutine" class="headerlink" title="二 : 协程(Coroutine)"></a>二 : 协程(Coroutine)</h2><p><strong>协程类似一种多线程，与多线程的区别有 :</strong></p><ol><li>协程并非os线程，所以创建、切换开销比线程相对要小。</li><li>协程与线程一样有自己的栈、局部变量等，但是协程的栈是在用户进程空间模拟的，所以创建、切换开销很小。</li><li>多线程程序是多个线程并发执行，也就是说在一瞬间有多个控制流在执行。而协程强调的是一种多个协程间协作的关系，只有当一个协程主动放弃执行权，另一个协程才能获得执行权，所以在某一瞬间，多个协程间只有一个在运行。</li><li>由于多个协程时只有一个在运行，所以对于临界区的访问不需要加锁，而多线程的情况则必须加锁。</li><li>多线程程序由于有多个控制流，所以程序的行为不可控，而多个协程的执行是由开发者定义的, 所以是可控的。</li></ol><p>Nginx 的每个 Worker 进程都是在 epoll 或 kqueue 这样的事件模型之上，封装成协程，每个请求都有一个协程进行处理。这正好与 Lua 内建协程的模型是一致的，所以即使 ngx_lua 需要执行 Lua，相对 C 有一定的开销，但依然能<strong>保证高并发能力</strong>。</p><h2 id="三-Nginx进程模型"><a href="#三-Nginx进程模型" class="headerlink" title="三 : Nginx进程模型"></a>三 : Nginx进程模型</h2><p><strong>Nginx 采用多进程模型</strong>，单Master多Worker，Master进程主要用来管理Worker进程。</p><p><strong>Worker进程</strong>采用单线程、非阻塞的事件模型(Event Lop，事件循环)来实现端口的监听及客户端请求的处理和响应同时Worker还要处理来自Master的信号。Worker进程个数一般设置为机器CPU核数。</p><p>Master进程具体包括如下4个主要功能:</p><ol><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态</li><li>当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ol><p>架构图</p><pre><code class=" mermaid">graph TBA[管理员] --信号--&gt; B1subgraph B[Nginx]B1[master进程] --信号--&gt; B2[worker进程] B1[master进程] --信号--&gt; B3[worker进程] B1[master进程] --信号--&gt; B4[worker进程] endB2 --- C1[Client]B2 --- C2[Client]B3 --- C3[Client]B3 --- C4[Client]B4 --- C5[Client]B4 --- C6[Client]</code></pre><h2 id="四-HTTP请求处理"><a href="#四-HTTP请求处理" class="headerlink" title="四 : HTTP请求处理"></a>四 : HTTP请求处理</h2><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>post-read</td><td>读取请求内容阶段，nginx读取并解析完请求头之后就立即开始运行</td></tr><tr><td>server-rewrite</td><td>server请求地址重写阶段</td></tr><tr><td>find-config</td><td>配置查找阶段，用来完成当前请求与location配重块之间的配对工作</td></tr><tr><td>rewrite</td><td>location请求地址重写阶段，当ngx_rewrite指令用于location中，就是在这个阶段运行的</td></tr><tr><td>post-rewrite</td><td>请求地址重写提交阶段，当nginx完成rewrite阶段所要求的内部跳转动作, 如果rewrite阶段有这个要求的话</td></tr><tr><td>preaccess</td><td>访问权限检查准备阶段，ngx_limit_req和ngx_limit_zone在这个阶段运行ngx_limit_req可以控制请求的访问频率，ngx_limit_zone可以控制访问的并发度</td></tr><tr><td>access</td><td>权限检查阶段，ngx_access在这个阶段运行，配置指令多是执行访问控制相关的任务，如检查用户的访问权限，检查用户的来源IP是否合法</td></tr><tr><td>post-access</td><td>访问权限检查提交阶段</td></tr><tr><td>try-files</td><td>配置项try_files处理阶段</td></tr><tr><td>content</td><td>内容产生阶段，是所有请求处理阶段中最为重要的阶段，因为这个阶段的指令通常是用来生成HTTP响应内容的</td></tr><tr><td>log</td><td>日志模块处理阶段</td></tr></tbody></table><h2 id="五-ngx-lua指令"><a href="#五-ngx-lua指令" class="headerlink" title="五 : ngx_lua指令"></a>五 : ngx_lua指令</h2><p>ngx_lua属于nginx的一部分，它的执行指令都包含在nginx的11个步骤之中了，相应的处理阶段可以做插入式处理即可插拔式架构，不过ngx_lua并不是所有阶段都会运行的;另外指令可以在http、server、server if、location、locationif几个范围进行配置:</p><table><thead><tr><th>指令</th><th>所处处理阶段</th><th>使用范围</th><th>解释</th></tr></thead><tbody><tr><td>init_by_lua<br/>init_by_lua_file</td><td>loading-config</td><td>http</td><td>nginx Master进程加载配置时执行;<br/>通常用于初始化全局配置&#x2F;预加载Lua模块</td></tr><tr><td>init_worker_by_lua<br/>init_worker_by_lua file</td><td>starting-worker</td><td>http</td><td>每个NginxWorker进程启动时调用的计时器，如果Master进程不允许则只会在init_by_lua之后调用;通常用于定时拉取配置&#x2F;数据、或者后端服务的健康检查</td></tr><tr><td>set_by_lua<br/>set_by_lua_file</td><td>rewrite</td><td>server,server if,location,location if</td><td>设置nginx变量，可以实现复杂的赋值逻辑;此处是阻塞的，Lua代码要做到非常快;</td></tr><tr><td>rewrite_by_lua<br/>rewrite_by_lua_file</td><td>rewrite tail</td><td>http,server,location,location if</td><td>rrewrite阶段处理，可以实现复杂的转发&#x2F;重定向逻辑;</td></tr><tr><td>access_by_lua<br/>access_by_lua_file</td><td>access tail</td><td>http,server,location,location if</td><td>请求访问阶段处理，用于访问控制</td></tr><tr><td>content_by_lua<br/>content_by_lua file</td><td>content</td><td>location，location if</td><td>内容处理器，接收请求处理并输出响应</td></tr><tr><td>header_filter_by_lua<br/>header_filter_by_lua_file</td><td>output-header-filter</td><td>http，server，location， location if</td><td>设置header和cookie</td></tr><tr><td>body_filter_by_lua<br/>body_filter_by_lua_file</td><td>output-body-filter</td><td>http，server，location，location if</td><td>对响应数据进行过滤，比如截断、替换</td></tr><tr><td>log_by_lua<br/>log_by_lua_file</td><td>log</td><td>http，server，location， location if</td><td>log阶段处理，比如记录访问量&#x2F;统计平均响应时间</td></tr></tbody></table><h2 id="六-OpenResty"><a href="#六-OpenResty" class="headerlink" title="六 : OpenResty"></a>六 : OpenResty</h2><p><strong>概念</strong> : OpenResty 是一个基于 Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p><p><strong>工作原理</strong> : OpenResty 通过汇聚各种设计精良的 Nginx 模块(主要由 OpenResty 团队自主开发)，从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p><p><strong>目标</strong> : OpenResty 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I&#x2F;O 模型，不仅仅对 HTTP 客户端请求甚至于对远程后端诸如 MySOL、PostgreSOL、Memcached 以及 Redis 等都进行一致的高性能响应.</p><h2 id="七-ngx-lua-示例"><a href="#七-ngx-lua-示例" class="headerlink" title="七 : ngx_lua 示例"></a>七 : ngx_lua 示例</h2><p>content_by_lua:内容处理器，接收请求处理并输出响应</p><p>该指令工作在 Nginx 处理流程的 content 阶段，即内容产生阶段是所有请求处理阶段中最为重要的阶段，因为这个阶段的指令通常是用来生成HTTP响应内容的;</p><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">error_log</span> logs/<span class="hljs-literal">error</span>.log;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">default_type</span> text/html;<br>            <span class="hljs-attribute">content_by_lua</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string">                ngx.say(&quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;)</span><br><span class="hljs-string">            &#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl http://127.0.0.1/<br>$ Hello, world<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载均衡中间件</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx代理缓存机制</title>
    <link href="/2020/12/11/Nginx%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/12/11/Nginx%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Ngnix缓存简介"><a href="#一-Ngnix缓存简介" class="headerlink" title="一 : Ngnix缓存简介"></a>一 : Ngnix缓存简介</h2><p>nginx 的 http_proxy 模块, 可以实现类似于 Squid 的缓存功能。</p><p>Nginx对客户已经访问过的内容在 Nginx 服务器本地建立副本, 这样在一段时间内再次访问该数据, 就不需要通过 Nginx 服务器再次向后端服务器发出请求, 所以能够减少 Nginx 服务器与后端服务器之间的网络流量, 减轻网络拥塞, 同时还能减小数据传输延迟, 提高用户访问速度。</p><p>同时, 当后端服务器宕机时, Nginx 服务器上的副本资源还能够回应相关的用户请求, 这样能够提高后端服务器的鲁棒性(健壮性)。</p><pre><code class=" mermaid">graph LRA1[User] --get--&gt; B[Internet]A2[User] --get--&gt; BB --&gt; C[Nginx]C --&gt; D1[Web1]C --&gt; D2[Web2]C --&gt; D3[Web3]C --&gt; D4[Web4]</code></pre><h2 id="二-Ngnix缓存工作原理"><a href="#二-Ngnix缓存工作原理" class="headerlink" title="二 : Ngnix缓存工作原理"></a>二 : Ngnix缓存工作原理</h2><p>对于缓存, 我们大概会有以下问题</p><ol><li>缓存文件放在哪儿?</li><li>如何指定哪些请求被缓存?</li><li>缓存的有效期是多久?</li><li>对于某些请求, 是否可以不走缓存?</li></ol><p>解决这些问题后, nginx的缓存也就基本配置完成了</p><h2 id="三-Ngnix缓存配置"><a href="#三-Ngnix缓存配置" class="headerlink" title="三 : Ngnix缓存配置"></a>三 : Ngnix缓存配置</h2><h3 id="一-缓存文件放在哪儿"><a href="#一-缓存文件放在哪儿" class="headerlink" title="(一) 缓存文件放在哪儿?"></a>(一) 缓存文件放在哪儿?</h3><p>配置参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>proxy_cache_path</td><td>Nginx使用该参数指定缓存位置</td></tr><tr><td>proxy_cache</td><td>该参数为之前指定的缓存名称</td></tr></tbody></table><p>proxy_cache_path 有两个必填参数</p><ul><li>第一个参数为缓存目录。</li><li>第二个参数 <code>keys_zone</code> 指定缓存名称和占用内存空间的大小。</li></ul><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># 定义缓存位置,缓存名称和源数据大小</span><br><span class="hljs-attribute">proxy_cache_path</span> /tmp/nginx/cache keys_zone=one:<span class="hljs-number">10m</span> max_size=<span class="hljs-number">10g</span>;<span class="hljs-comment"># max_size为总量大小</span><br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">proxy_cache</span> one;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>示例中的10m是对内存中缓存内容元数据信息大小的限制, 如果想限制缓存总量大小, 需要用 max_size 参数。</li></ul><h3 id="二-如何指定哪些请求被缓存"><a href="#二-如何指定哪些请求被缓存" class="headerlink" title="(二) 如何指定哪些请求被缓存?"></a>(二) 如何指定哪些请求被缓存?</h3><p>Nginx <strong>默认会缓存所有 get 和 head 方法的请求结果</strong>, 缓存的 key 默认使用请求字符串。</p><p>配置参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>proxy_cache_key</td><td>自定义 key</td></tr><tr><td>proxy_cache_min_uses</td><td>指定请求至少被发送了多少次以上时才缓存, 可以防止低频请求被缓存</td></tr><tr><td>proxy_cache_methods</td><td>指定哪些方法的请求被缓存</td></tr></tbody></table><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-section">http</span> &#123;<br><span class="hljs-attribute">proxy_cache_path</span> /data/nginx/cache keys_zone=one:<span class="hljs-number">10m</span>;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">proxy_cache</span> one;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-comment"># 指定key</span><br>            <span class="hljs-attribute">proxy_cache_key</span><span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span><span class="hljs-variable">$cookie_user</span>;<br>            <span class="hljs-comment"># 至少5次才会被缓存</span><br>            <span class="hljs-attribute">proxy_cache_min_uses</span> <span class="hljs-number">5</span>;<br>            <span class="hljs-comment"># 缓存的请求方式</span><br>            <span class="hljs-attribute">proxy_cache_methods</span> GET HEAD POST;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-缓存的有效期是多久"><a href="#三-缓存的有效期是多久" class="headerlink" title="(三) 缓存的有效期是多久?"></a>(三) 缓存的有效期是多久?</h3><p>默认情况下, 缓存内容是长期存留的, 除非缓存的总量超出限制, 可以指定缓存有效时间</p><p>配置参数 : <code>proxy_cache_valid</code></p><table><thead><tr><th>示例</th><th>作用</th></tr></thead><tbody><tr><td><code>proxy_cache_valid 200 302 10m</code></td><td>响应状态码为200 302时, 10分钟有效</td></tr><tr><td><code>proxy_cache_valid any 5m</code></td><td>对应任何状态码, 5分钟有效</td></tr></tbody></table><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-section">http</span> &#123;<br><span class="hljs-attribute">proxy_cache_path</span> /data/nginx/cache keys_zone=one:<span class="hljs-number">10m</span>;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">proxy_cache</span> one;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">302</span> <span class="hljs-number">10m</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四-对于某些请求-是否可以不走缓存"><a href="#四-对于某些请求-是否可以不走缓存" class="headerlink" title="(四) 对于某些请求, 是否可以不走缓存?"></a>(四) 对于某些请求, 是否可以不走缓存?</h3><p>配置参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>proxy_cache_bypass</td><td>该指令响应来自原始服务器而不是缓存</td></tr></tbody></table><p>例如</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_cache_bypass</span> <span class="hljs-variable">$cookie_nocache</span> <span class="hljs-variable">$arg_nocache</span><span class="hljs-variable">$arg_comment</span>;<br><span class="hljs-comment"># 如果任何一个参数值,不为空或者不等于0,nginx就不会查找缓存,直接进行代理转发</span><br></code></pre></td></tr></table></figure><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-section">http</span> &#123;<br><span class="hljs-attribute">proxy_cache_path</span> /data/nginx/cache keys_zone=one:<span class="hljs-number">10m</span>;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">proxy_cache</span> one;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_cache_bypass</span> <span class="hljs-variable">$cookie_nocache</span> <span class="hljs-variable">$arg_nocache</span><span class="hljs-variable">$arg_comment</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-关于网页的缓存"><a href="#四-关于网页的缓存" class="headerlink" title="四 : 关于网页的缓存"></a>四 : 关于网页的缓存</h2><p>网页的缓存是由 HTTP 消息头中的 “Cache-control” 来控制的, 常见的取值有 private, no-cache, max-age, must-revalidate 等, 默认为 private。其作用根据不同的重新浏览方式分为以下几种情况 : </p><table><thead><tr><th>Cache-directive</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>所有内容都将被缓存(客户端和代理服务器都可缓存)</td></tr><tr><td>private</td><td><strong>默认值</strong>, 内容只缓存到私有缓存中(仅客户端可以缓存, 代理服务器不可缓存)</td></tr><tr><td>no-cache</td><td>必须先与服务器确认返回的响应是否被更改, 然后才能使用该响应来满足后续对同一个网址的请求。因此, 如果存在合适的验证令牌(ETag), no-cache会发起往返通信来验证缓存的响应, 如果资源未被更改, 可以避免下载。</td></tr><tr><td>no-store</td><td>所有内容都不会被缓存到缓存或 internet 临时文件中</td></tr><tr><td>must-revalidation&#x2F;proxy-revalidation</td><td>如果缓存的内容失效, 请求必须发送到服务器&#x2F;代理以进行重新验</td></tr><tr><td>max-age&#x3D;xxx</td><td>缓存的内容将在xxx秒后失效这个选项只在HTTP1.1可用, 并如果和Last-Modified一起使用时, 优先级较高</td></tr></tbody></table><p>实验测试 : 查看 Cache-Control 不同的取值对请求结果的影响</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /h5 &#123;<br>    <span class="hljs-comment"># html不缓存</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_filename</span> <span class="hljs-regexp">~* .*\.(?:html|htm)$)</span> &#123;<br>        <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment"># 图片缓存30天</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_filename</span> <span class="hljs-regexp">~* .*\.(?:gif|jpg|jpeg|png|bmp|swf)$)</span> &#123;<br>        <span class="hljs-attribute">expires</span> <span class="hljs-number">30d</span>;<br>    &#125;<br>    <span class="hljs-comment"># js和css缓存12h</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_filename</span> <span class="hljs-regexp">~* .*\.(?:js|css)$)</span> &#123;<br>        <span class="hljs-attribute">expires</span> <span class="hljs-number">12h</span>;<br>    &#125;<br>    <span class="hljs-attribute">alias</span> /opt/web/h5/dist;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载均衡中间件</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx负载均衡</title>
    <link href="/2020/12/04/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2020/12/04/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Nginx简介"><a href="#一-Nginx简介" class="headerlink" title="一 : Nginx简介"></a>一 : Nginx简介</h2><p>Nginx(发音同 engine x)是一款轻量级的 Web 服务器&#x2F;反向代理服务器及电子邮件(MAP&#x2F;POP3) 代理服务器, 并在一个 BSD协议下发行, 可以在 UNIX、GNU&#x2F;Linux、BSD、Mac OS 、Solaris, 以及 MicrosoftWindows等操作系统中运行。</p><p>Nginx 由俄罗斯的程序设计师 lgor Sysoev 所开发, 最初供俄国大型的入口网站及搜寻引擎 Rambler (俄文:Pam6nep)使用。其特点是占有内存少, 并发能力强(用于解决 C10K 问题), 事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。</p><p>Nginx做为一个强大的Web服务器软件, 具有<strong>高性能、高并发性和低内存占用</strong>的特点。此外, 其也能够提供<strong>强大的反向代理功能</strong>。俄罗斯大约有超过20%的虚拟主机采用Nginx作为反向代理服务器, 在国内也有腾讯、新浪、网易等多家网站在使用Nginx作为反向代理服务器。据Netcraft统计, 世界上最繁忙的网站中有11.48%使用Nginx作为其服务器或者代理服务器。</p><p>基于反向代理的功能, Nginx作为负载均衡的<strong>主要理由</strong> : 高并发连接、内存消耗少、配置文件非常简单、成本低廉、支持Rewrite重写规则、内置的健康检查功能、节省带宽、稳定性高。</p><h2 id="二-正向代理和反向代理"><a href="#二-正向代理和反向代理" class="headerlink" title="二 : 正向代理和反向代理"></a>二 : 正向代理和反向代理</h2><h3 id="一-正向代理"><a href="#一-正向代理" class="headerlink" title="(一) 正向代理"></a>(一) 正向代理</h3><p>正向代理类似一个跳板机, 代理访问外部资源。</p><pre><code class=" mermaid">graph LRA[客户端] --需要配置代理服务器地址--- B[正向代理服务器] ----- C[互联网]</code></pre><h3 id="二-反向代理-Reverse-Proxy"><a href="#二-反向代理-Reverse-Proxy" class="headerlink" title="(二) 反向代理 (Reverse Proxy)"></a>(二) 反向代理 (Reverse Proxy)</h3><p>实际运行方式是指以代理服务器来接受internet上的连接请求然后将请求转发给内部网络上的服务器, 并将从服务器上得到的结果返回给internet上请求连接的客户端, 此时代理服务器对外就表现为一个服务器。</p><pre><code class=" mermaid">graph LRA[客户端] --- B((反向代理服务器&lt;br&gt;外网IP:106.12.76.90&lt;br&gt;内网IP:10.10.10.10)) --- C[web服务器&lt;br&gt;内网IP:10.10.10.20]subgraph D[ ]BCend</code></pre><p><strong>反向代理的作用 :</strong></p><ol><li>保证内网的安全, 可以使用反向代理提供WAF功能, 阻止web攻击。大型网站, 通常将反向代理作为公网访问地址Web服务器是内网</li><li>负载均衡, 通过反向代理服务器来优化网站的负载。</li></ol><h2 id="三-负载均衡原理"><a href="#三-负载均衡原理" class="headerlink" title="三 : 负载均衡原理"></a>三 : 负载均衡原理</h2><p>负载均衡, 单从字面上的意思来理解就可以解释N台服务器平均分担负载, 不会因为某台服务器负载高宕机和某台服务器闲置的情况。那么负载均衡的前提就是要2台以上服务器才能实现。</p><pre><code class=" mermaid">flowchart LRA[客户端] --&gt; B((反向代理服务器&lt;br&gt;外网IP:106.12.76.90&lt;br&gt;内网IP:10.10.10.10))subgraph C[web服务器]C1[&quot;web1&lt;br&gt;内网IP:10.10.10.11&quot;]C2[&quot;web2&lt;br&gt;内网IP:10.10.10.12&quot;]C3[&quot;web3&lt;br&gt;内网IP:10.10.10.13&quot;]endB --&gt; C1B --&gt; C2B --&gt; C3</code></pre><p>Nginx负载均衡有4种方案配置</p><table><thead><tr><th>方案</th><th>说明</th><th>描述</th></tr></thead><tbody><tr><td>Round Robin</td><td>轮询</td><td>根据 Nginx 配置文件中的<strong>顺序</strong>, 依次把客户端的 Web 请求分发到不同的后端服务器上</td></tr><tr><td>least_conn</td><td>最少连接</td><td>Web 请求会被转发到连接数最少的服务器上</td></tr><tr><td>ip_hash</td><td>IP地址哈希</td><td>同一客户端连续的Web请求都会被分发到同一服务器进行处理</td></tr><tr><td>weight</td><td>权重</td><td>把请求更多地分发到高配置的后端服务器上, 把相对较少的请求分发到低配服务器</td></tr></tbody></table><h2 id="四-负载均衡配置"><a href="#四-负载均衡配置" class="headerlink" title="四 : 负载均衡配置"></a>四 : 负载均衡配置</h2><h3 id="一-轮询"><a href="#一-轮询" class="headerlink" title="(一) 轮询"></a>(一) 轮询</h3><p>配置基于 Round Robin 轮询的负载均衡<strong>需要注意以下几点</strong></p><ol><li>缺省配置就是轮询策略:</li><li>nginx 负载均衡支持 http 和 https 协议，只需要修改 proxy_pass 后协议即可</li><li>nginx 支持 FastCGl, uwsgi, SCGl, memcached 的负载均衡, 只需将 proxy_pass 改为 fastcgi_pass, uwsgi_pass, scgi_pass, memcached_pass 即可</li><li>此策略适合服务器配置相当，无状态且短平快的服务使用。</li></ol><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto; <span class="hljs-comment"># 以cpu核心数作为worker的数量</span><br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-comment"># 基于事件的网络IO</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>; <span class="hljs-comment"># 多路复用</span><br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">65535</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span>Host<span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Real-IP<span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Forwarded<span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-最少连接"><a href="#二-最少连接" class="headerlink" title="(二) 最少连接"></a>(二) 最少连接</h3><p>配置基于 least_conn 的负载均衡, 需要注意以下几点</p><ol><li>最少链接负载均衡通过 least_conn 指令定义;</li><li>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况;</li></ol><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-comment"># 基于事件的网络IO</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>; <span class="hljs-comment"># 多路复用</span><br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">65535</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        least_conn;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123; <br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span>Host<span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Real-IP<span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Forwarded<span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-IP地址哈希"><a href="#三-IP地址哈希" class="headerlink" title="(三) IP地址哈希"></a>(三) IP地址哈希</h3><p>前述的两种负载均衡方案中, 同一客户端连续的Web请求可能会被分发到不同的后端服务器进行处理, 因此如果涉及到会话Session, 那么会话会比较复杂。常见的是基于数据库的会话持久化。要克服上面的难题, 可以使用基于IP地址哈希的负载均衡方案这样的话, 同一客户端连续的Web请求都会被分发到同一服务器进行处理。</p><p>配置基于 ip_hash 的负载均衡, 需要注意以下几点:</p><ol><li>ip哈希负载均衡使用 ip_hash 指令定义</li><li>nginx使用请求客户端的ip地址进行哈希计算，确保使用同一个服务器响应请求</li><li>此策略适合有状态服务，比如session;</li></ol><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-comment"># 基于事件的网络IO</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>; <span class="hljs-comment"># 多路复用</span><br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">65535</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        ip_hash;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span>Host<span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Real-IP<span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Forwarded<span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四-基于权重"><a href="#四-基于权重" class="headerlink" title="(四) 基于权重"></a>(四) 基于权重</h3><p>配置基于权重的负载均衡, 需要注意以下几点:</p><ol><li>权重负载均衡需要使用 weight 指令定义;</li><li>权重越高分配到需要处理的请求越多;</li><li>此策略可以与最少链接负载和ip哈希策略结合使用</li><li>此策略比较适合服务器的硬件配置差别比较大的情况</li></ol><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> nginx;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><br><span class="hljs-comment"># 基于事件的网络IO</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>; <span class="hljs-comment"># 多路复用</span><br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">65535</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <br>    <span class="hljs-section">upstream</span> info4z.tk &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8881</span> weight=<span class="hljs-number">3</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8882</span> weight=<span class="hljs-number">2</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8883</span> weight=<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-literal">info</span>4z.tk;<br>        <br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://info4z.tk;<br>            <span class="hljs-attribute">proxy_set_header</span>Host<span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Real-IP<span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span>X-Forwarded<span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载均衡中间件</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ消息可靠性和插件化机制</title>
    <link href="/2020/11/27/RabbitMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <url>/2020/11/27/RabbitMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="一-消息可靠性"><a href="#一-消息可靠性" class="headerlink" title="一 : 消息可靠性"></a>一 : 消息可靠性</h1><p>RabbitMQ的消息可靠性, 一般是业务系统接入消息中间件时首要考虑的问题,一般通过三个方面保障</p><table><thead><tr><th>可靠性</th><th>描述</th></tr></thead><tbody><tr><td>发送可靠性</td><td>确保消息成功发送到 Broker</td></tr><tr><td>存储可靠性</td><td>Broker 对消息持久化, 确保消息不会丢失</td></tr><tr><td>消费可靠性</td><td>确保消息成功被消费</td></tr></tbody></table><h2 id="一-消息发送可靠性"><a href="#一-消息发送可靠性" class="headerlink" title="(一) 消息发送可靠性"></a>(一) 消息发送可靠性</h2><p>—般消息发送可靠性分为三个层级</p><table><thead><tr><th>层级</th><th>描述</th></tr></thead><tbody><tr><td>At most once</td><td>最多一次, 消息可能会丢失, 但绝不会重复传输</td></tr><tr><td>At least once</td><td>最少一次, 消息绝不会丢失, 但可能会重复传输</td></tr><tr><td>Exactly once</td><td>恰好一次, 每条消息肯定会被传输一次且仅传输一次</td></tr></tbody></table><p>RabbitMQ支持其中的<strong>最多一次</strong>和<strong>最少一次</strong>; </p><ul><li><p><strong>最少一次</strong>投递实现需要考虑以下这个几个方面的内容:</p></li><li><p>消息生产者需要开启事务机制或者 publisher confirm 机制, 以确保消息可以可靠地传输到 RabbitMQ 中</p><ul><li>消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器路由到队列中, 进而能够保存下来而不会被丢弃</li></ul></li><li><p><strong>最多一次</strong>的方式就无须考虑以上那些方面, 生产者随意发送, 不过这样很难确保消息会成功发送。</p></li></ul><h2 id="二-消息消费可靠性"><a href="#二-消息消费可靠性" class="headerlink" title="(二) 消息消费可靠性"></a>(二) 消息消费可靠性</h2><p>消费者在消费消息的同时, 需要将 autoAck 设置为false, 然后通过手动确认的方式去确认己经正确消费的消息,以免在消费端引起不必要的消息丢失。</p><h1 id="二-插件机制"><a href="#二-插件机制" class="headerlink" title="二 : 插件机制"></a>二 : 插件机制</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="(一) 概述"></a>(一) 概述</h2><p>RabbitMQ支持插件, 通过插件可以扩展多种核心功能:支持多种协议、系统状态监控、其它AMQP 0-9-1交换类型、节点联合等。许多功能都是通过插件实现的。</p><p>RabbitMQ内置一些插件,通过命令可以查看插件列表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmq-plugins list<br></code></pre></td></tr></table></figure><h2 id="二-启用插件"><a href="#二-启用插件" class="headerlink" title="(二) 启用插件"></a>(二) 启用插件</h2><p>通过rabbitmq-plugins命令可以启用或禁用插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmq-plugins <span class="hljs-built_in">enable</span> plugin-name<br>rabbitmq-plugins <span class="hljs-built_in">disable</span> plugin-name<br></code></pre></td></tr></table></figure><h2 id="三-常用插件"><a href="#三-常用插件" class="headerlink" title="(三) 常用插件"></a>(三) 常用插件</h2><table><thead><tr><th>插件</th><th>作用</th></tr></thead><tbody><tr><td>rabbitmq_auth_mechanism_ssl</td><td>身份验证机制插件, 允许RabbitMQ客户端使用x509证书和TLS(PKI)证书进行身份验证</td></tr><tr><td>rabbitmq_event_exchange</td><td>事件分发插件, 使客户端可以接收到Broker 的 queue.deleted, exchange.created, binding.created 等事件</td></tr><tr><td>rabbitmq_management</td><td>基于Web界面的管理&#x2F;监控插件</td></tr><tr><td>rabbitmq_management_agent</td><td>启用 rabbitmq_management 时, 会自动启用此插件, 用于在 Web 管理中查看集群节点</td></tr><tr><td>rabbitmq_mqtt</td><td>MQTT 插件,使 RabbitMQ 支持 MQTT 协议</td></tr><tr><td>rabbitmq_web_mqtt</td><td>使 RabbitMQ 支持通过 WebSocket 订阅消息, 基于 MQTT 协议传输</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ持久化机制和内存磁盘控制</title>
    <link href="/2020/11/20/RabbitMQ%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2020/11/20/RabbitMQ%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一-持久化机制"><a href="#一-持久化机制" class="headerlink" title="一 : 持久化机制"></a>一 : 持久化机制</h1><p>RabbitMQ 的持久化分为<strong>队列持久化</strong>、<strong>消息持久化</strong>和<strong>交换器持久化</strong>。不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。</p><p>持久化消息会自动写入磁盘, 重启后数据也不会丢失</p><pre><code class=" mermaid">flowchart LRA(Producer) --持久化消息--&gt; B1subgraph B[Broker]B1[Queue]B2((内存))B1 --&gt; B2endB1 --&gt; C[(磁盘)]</code></pre><p>非持久化数据在<strong>内存不足</strong>的情况下也会写入磁盘, 但重启后数据会丢</p><pre><code class=" mermaid">flowchart LRA(Producer) --持久化消息--&gt; B1subgraph B[Broker]B1[Queue]B2((内存))B1 --&gt; B2endB2 --&gt; C[(磁盘)]</code></pre><h2 id="一-队列持久化"><a href="#一-队列持久化" class="headerlink" title="(一) 队列持久化"></a>(一) 队列持久化</h2><p>队列的持久化是在定义队列时的durable参数来实现的, durable为true时, 队列才会持久化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><span class="hljs-comment">//第二个参数设置为true, 即durable=true</span><br>channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>); <br></code></pre></td></tr></table></figure><p>持久化的队列在管理界面的 Features 列可以看到有个 <code>D</code> 的标识</p><h2 id="三-消息持久化"><a href="#三-消息持久化" class="headerlink" title="(三) 消息持久化"></a>(三) 消息持久化</h2><p>消息持久化通过消息的属性 deliveryMode 来设置是否持久化, 在发送消息时通过 basicPublish 的参数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过传入MessageProperties.PERSISTENT_TEXT_PLAIN 就可以实现消息持久化</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;queue1&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="hljs-string">&quot;persistent_test_message&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><h2 id="四-交换器持久化"><a href="#四-交换器持久化" class="headerlink" title="(四) 交换器持久化"></a>(四) 交换器持久化</h2><p>同队列一样, 交换器也需要在定义时设置持久化标识, 否则在Broker重启后将丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// durable为true则开启持久化</span><br>Exchange.DeclareOk <span class="hljs-title function_">exchangeDeclare</span><span class="hljs-params">(String exchange, String type, <span class="hljs-type">boolean</span> durable)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><h1 id="二-内存控制"><a href="#二-内存控制" class="headerlink" title="二 : 内存控制"></a>二 : 内存控制</h1><h2 id="一-内存告警"><a href="#一-内存告警" class="headerlink" title="(一) 内存告警"></a>(一) 内存告警</h2><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时, RabbitMQ 会暂时阻塞客户端的连接, 并停止接收从客户端发来的消息, 以此避免服务崩溃, 客户端与服务端的心跳检测也会失效。</p><h2 id="二-内存控制-1"><a href="#二-内存控制-1" class="headerlink" title="(二) 内存控制"></a>(二) 内存控制</h2><p>当出现内存告警时, 可以通过管理命令临时调整内存大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;fraction&gt;</code>为内存阈值, RabbitMQ 默认值为 <code>0.4</code>, 表示当 RabbitMQ 使用的内存超过 40% 时,就会产生告警并阻塞所有生产者连接。</li><li>通过此命令修改的阈值在Broker重启后将会失效, 通过修改配置文件的方式设置的阈值则不会在重启后消失, 但需要重启Broker才会生效。</li></ul><p>配置文件地址: &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">vm_memory_high_watermark.relative</span> = <span class="hljs-string">0.4</span><br><span class="hljs-comment">#vm_memory_high_watermark.absolute = 1GB</span><br></code></pre></td></tr></table></figure><p>RabbitMQ 提供 relative 或absolute 两种配置方式</p><ul><li><p><strong>relative :</strong> 相对值, 即前面的 fraction, 建议取值在 <code>0.4~0.66</code>之间, 不建议超过 <code>0.7</code></p></li><li><p><strong>absolute :</strong> 绝对值, 单位为KB、MB、GB, 对应的命令是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_vm_memory_high_watermark absolute &lt;value&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三-内存换页"><a href="#三-内存换页" class="headerlink" title="(三) 内存换页"></a>(三) 内存换页</h2><p>在某个 Broker 节点触及内存并阻塞生产者之前, 它会尝试将队列中的消息换页到磁盘以释放内存空间。持久化和非持久化的消息都会被转储到磁盘中, 其中持久化的消息本身就在磁盘中有一份副本, 这里会将持久化的消息从内存中清除掉。</p><p><strong>默认情况下, 在内存到达内存阈值的 50% 时会进行换页动作。</strong>也就是说, 在默认的内存阈值为 <code>0.4</code> 的情况下, 当内存超过 <code>0.4×0.5=0.2</code> 时会进行换页动作。</p><p>可以通过在配置文件中配置 <code>vm_memory_high_watermark_paging_ratio</code> 项来修改此值</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">vm_memory_high_watermark.relative</span> =<span class="hljs-string">0.4</span><br><span class="hljs-attr">vm_memory_high_watermark_paging_ratio</span> = <span class="hljs-string">0.75</span><br><span class="hljs-comment"># 以上配置将会在 RabbitMQ 内存使用率达到30%(0.4*0.75=0.3)时进行换页动作, 并在40%时阻塞生产者</span><br></code></pre></td></tr></table></figure><p>当 <code>vm_memory_high_watermark_paging_ratio</code> 的值大于1时, 相当于<strong>禁用</strong>了换页功能。</p><h1 id="三-磁盘控制"><a href="#三-磁盘控制" class="headerlink" title="三 : 磁盘控制"></a>三 : 磁盘控制</h1><h2 id="一-磁盘告警"><a href="#一-磁盘告警" class="headerlink" title="(一) 磁盘告警"></a>(一) 磁盘告警</h2><p>当磁盘剩余空间低于确定的阈值时, RabbitMQ 同样会阻塞生产者, 这样可以避免因非持久持续换页而耗尽磁盘空间导致服务崩溃。</p><p><strong>默认情况下, 磁盘阈值为50MB;</strong> 表示当磁盘剩余空间低于 50MB 时会阻塞生产者并停止内存中消息的换页动作。</p><p>这个阈值的设置可以减小，但不能完全消除因磁盘耗尽而导致崩溃的可能性。比如在两次磁盘空间检测期间内，磁盘空间从大于50MB被耗尽到0MB。</p><p><strong>一个相对谨慎的做法是将磁盘阈值设置为与操作系统所显示的内存大小一致;</strong> 比如内存大小为 8G, 那磁盘剩余空间就设置为 8G</p><h2 id="二-磁盘限制"><a href="#二-磁盘限制" class="headerlink" title="(二) 磁盘限制"></a>(二) 磁盘限制</h2><p>通过命令可以临时调整磁盘阈值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_disk_free_limit &lt;disk_limit&gt;<br>rabbitmqctl set_disk_free_limit mem_relative &lt;fraction&gt;<br><span class="hljs-comment"># disk_limit 为固定大小，单位为KB、MB、GB; fraction为相对比值，建议的取值为1.0~2.0之间</span><br></code></pre></td></tr></table></figure><p>对应的配置如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">disk_free_limit.relative</span> = <span class="hljs-string">2.0</span><br><span class="hljs-comment"># disk_free_limit.absolute = 50mb</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ高可用方案</title>
    <link href="/2020/11/13/RabbitMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    <url>/2020/11/13/RabbitMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Cluster-实现"><a href="#一-Cluster-实现" class="headerlink" title="一 : Cluster 实现"></a>一 : Cluster 实现</h2><ul><li>RabbitMQ 的 Cluster 模式分为<strong>普通模式</strong>和<strong>镜像模式</strong>两种</li></ul><h3 id="一-普通模式"><a href="#一-普通模式" class="headerlink" title="(一) 普通模式"></a>(一) 普通模式</h3><pre><code class=" mermaid">flowchart LRA[Producer] --message--&gt; B1 --&gt; B2 --&gt; C[Consumer]subgraph B[RabbitMQ普通模式集群]    subgraph B1[Broker1]B11[&quot;元数据&lt;br&gt;-----------&lt;br&gt;队列内容&quot;]     end    subgraph B2[Broker2]    B21[元数据]    endend</code></pre><p>元数据包含以下内容:</p><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>队列元数据</td><td>队列的名称及属性</td></tr><tr><td>交换器</td><td>交换器的名称及属性</td></tr><tr><td>绑定关系元数据</td><td>交换器与队列或者交换器与交换器</td></tr><tr><td>vhost元数据</td><td>为vhost内的队列、交换器和绑定提供命名空间及安全属性之间的绑定关系</td></tr></tbody></table><h3 id="二-普通模式-多机多节点"><a href="#二-普通模式-多机多节点" class="headerlink" title="(二) 普通模式-多机多节点"></a>(二) 普通模式-多机多节点</h3><p>架构图</p><pre><code class=" mermaid">flowchart LRA --- B --- C --- Asubgraph A[10.0.0.1]A1((Broker1))endsubgraph B[10.0.0.2]B1((Broker2))endsubgraph C[10.0.0.3]C1((Broker3))end</code></pre><p>修改三台机器的 <code>/etc/hosts</code> 文件，添加IP地址与节点名的映射信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">10.10.1.41 nodel<br>10.10.1.42 node2<br>10.10.1.43 node3<br></code></pre></td></tr></table></figure><p>编辑 RabbitMQ 的 <code>/var/lib/rabbitmq/.erlang.cookie</code> 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 确保各个节点的 cookie 文件使用的是同一个值, 可以从一个节点复制到其它节点</span><br>scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/<br>scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/<br></code></pre></td></tr></table></figure><p>将三个节点的端口添加到防火墙</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">firewall-cmd --zone=public --add-port=5672/tcp --permanent<br>firewall-cmd --zone=public --add-port=15672/tcp --permanent<br>firewall-cmd --zone=public --add-port=25672/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>启动三个节点的RabbitMQ服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@node1 ~]<span class="hljs-comment"># rabbitmq-server -detached</span><br>[root@node2 ~]<span class="hljs-comment"># rabbitmq-server -detached</span><br>[root@node3 ~]<span class="hljs-comment"># rabbitmq-server -detached</span><br></code></pre></td></tr></table></figure><p>以node1为基准，将node2和node3加入nodel节点的集群中。在node2和node3分别执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl join_cluster rabbit@node1 --ram<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><h3 id="三-普通模式-单机多节点"><a href="#三-普通模式-单机多节点" class="headerlink" title="(三) 普通模式-单机多节点"></a>(三) 普通模式-单机多节点</h3><p>由于某些因素的限制，有时候不得不在单台物理机器上去创建一个多RabbitMQ服务节点的集群。或者只想要实验性地验证集群的某些特性，也不需要浪费过多的物理机器去实现。</p><pre><code class=" mermaid">flowchart TB    subgraph A[10.0.0.1]        A1((Broker1)) --- A2((Broker2)) ---  A3((Broker3)) --- A1    end</code></pre><p>为方便后续命令操作，在<code>/etc/rabbitmq/rabbitmq-env.conf</code> 修改默认的节点名称为rabbit1</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">NODENAME</span>=<span class="hljs-string">rabbit1</span><br></code></pre></td></tr></table></figure><p>为每个 RabbitMQ 服务节点设置不同的端口号和节点名称来启动相应的服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 前面设置了默认节点名，而且也有默认端口5672，所以rabbit1可以直接启动，而rabbit2和rabbit3要指定名称和端口</span><br>rabbitmq-server -detached<br>RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit2 rabbitmq-server-detached<br>RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit3 rabbitmq-server-detached<br></code></pre></td></tr></table></figure><p>如果启用的插件有端口(比如rabbitmq_management)，则需要增加启动参数，修改插件的端口号，否则会启动失败。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># rabbit2的Web管理端口改为15673</span><br>RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="hljs-string">&quot;-rabbitmq_management listenerport,15673&#125;]&quot;</span> RABBITMQ_NODENAME=rabbit2 rabbitmq-server -detached<br><br><span class="hljs-comment"># rabbit3的Web管理端口改为15674</span><br>RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=<span class="hljs-string">&quot;-rabbitmq_management listener&#123;port,15674]]&quot;</span> RABBITMQ_NODENAME=rabbit3 rabbitmq-server -detached<br></code></pre></td></tr></table></figure><h3 id="四-镜像模式"><a href="#四-镜像模式" class="headerlink" title="(四) 镜像模式"></a>(四) 镜像模式</h3><p>架构图</p><pre><code class=" mermaid">flowchart LRA[生产者] --消息--&gt; B1B1 --&gt; B2 B1 --&gt; B3B2 --&gt; C1[消费者]B3 --&gt; C2[消费者]subgraph B[镜像模式集群]subgraph B1[Rabbit01节点]B11[主拷贝&lt;br&gt;Queue&lt;br&gt;镜像]endsubgraph B2[Rabbit03节点]B21[从拷贝&lt;br&gt;Queue&lt;br&gt;镜像]endsubgraph B3[Rabbit03节点]B31[从拷贝&lt;br&gt;Queue&lt;br&gt;镜像]endend</code></pre><ul><li><p>镜像模式的集群是在普通模式的基础上，通过policy来实现，使用镜像模式可以实现RabbitMQ的高可用方案。可以在控制台直接配置</p><ul><li>Name : policy 的名称</li><li>Pattern : 匹配表达式</li><li>Apply to : 规则应用到哪个目标</li><li>Priority : 优先级</li><li>Definition : 规则的定义，对于镜像队列的配置来说, 只需要包含3个部分: ha-mode、ha-params 和 ha-sync-mode。</li></ul></li><li><p><strong>ha-mode</strong> : 指明镜像队列的模式，有效值为all、exactly 、nodes，默认为all</p><table><thead><tr><th>ha-mode</th><th>ha-params</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>(empty)</td><td>队列镜像到集群类所有节点</td></tr><tr><td>exactly</td><td>count</td><td>队列镜像到集群内指定数量的节点。如果集群内节点数少于此值，队列将会镜像到所有节点。如果大于此值，而且一个包含镜像的节点停止，则新的镜像不会在其它节点创建。</td></tr><tr><td>nodes</td><td>nodename</td><td>队列镜像到指定节点，指定的节点不在集群中不会报错。当队列申明时，如果指定的节点不在线，则队列会被创建在客户端所连接的节点上。</td></tr></tbody></table></li><li><p><strong>ha-sync-mode</strong> : 队列中消息的同步方式，有效值为automatic和manual，默认是automatic o</p></li></ul><h2 id="二-插件实现"><a href="#二-插件实现" class="headerlink" title="二 : 插件实现"></a>二 : 插件实现</h2><h3 id="一-Federation"><a href="#一-Federation" class="headerlink" title="(一) Federation"></a>(一) Federation</h3><p>Federation 插件的设计目标是使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群, 该功能在以下场景下非常有用</p><ul><li>各个节点运行在不同版本的Erlang和RabbitMQ上。</li><li>网络环境不稳定，比如广域网当中。</li></ul><p>架构图</p><pre><code class=" mermaid">flowchart LRA --federation link--- B A --federation link--- Csubgraph A[broker1]A1[&quot;exchangeA&lt;br&gt;(federation exchange)&quot;]endsubgraph B[broker2]B1[&quot;exchangeB&lt;br&gt;(upstream exchange)&quot;]endsubgraph C[broker3]C1[&quot;exchangeC&lt;br&gt;(upstream exchange)&quot;]endsubgraph D[upstream set]BCend</code></pre><h3 id="二-Shovel"><a href="#二-Shovel" class="headerlink" title="(二) Shovel"></a>(二) Shovel</h3><p>Shovel 与 Federation 具备的数据转发功能类似, Shovel 能够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个Broker中的交换器(作为目的端，即destination)。</p><p>Shovel可以翻译为“铲子”，是一种比较形象的比喻。这个”铲子”可以将消息从一方”挖到”另一方</p><p>Shovel的主要优势:</p><ul><li><strong>松耦合</strong>，Shovel 可以移动位于不同管理域中的 Broker 或者集群上的消息，这些 Broker 或者集群可以包含不同的用户和 vhost，也可以使用不同的 RabbitMQ 和 Erlang 版本。</li><li><strong>支持广域网</strong>，Shovel 插件同样基于 AMQP 协议在 Broker 之间进行通信，被设计成可以容忍时断时续的连通情形，并且能够保证消息的可靠性。</li><li><strong>高度定制</strong>，当Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li></ul><p>Shovel 的作用</p><pre><code class=" mermaid">graph LRA[Client] --data--&gt; B1((exchange1)) -.rk1&lt;br&gt;data.-&gt; B2[queue1] --data--&gt; C&#123;Shovel&#125; --data--&gt; D1((exchange2)) -.rk2&lt;br&gt;data.-&gt; D2[queue2]subgraph B[broker1]B1B2endsubgraph D[broker2]D1D2end</code></pre><h2 id="三-Federation-x2F-Shovel与Cluster的比较"><a href="#三-Federation-x2F-Shovel与Cluster的比较" class="headerlink" title="三 : Federation&#x2F;Shovel与Cluster的比较"></a>三 : Federation&#x2F;Shovel与Cluster的比较</h2><table><thead><tr><th>Federation&#x2F;Shovel</th><th>cluster</th></tr></thead><tbody><tr><td>各个Broker节点之间逻缉分离</td><td>逻辑上是个Broker节点</td></tr><tr><td>各个Broker节点之间可以运行不同版本的Erlang和RabbitMQ</td><td>各个Broker节点之间必须运行相同版本的Erlang和RabbitMQ</td></tr><tr><td>各个Broker节点之间可以在广域网中相连，当然必须要授予适当的用户和权限</td><td>各个Broker节点之间必须在可信赖的局域网中相连,通过Erlang内部节点传递消息，但节点问需要有相同的Erlang cookie</td></tr><tr><td>各个Broker节点之间能以任何拓扑逻辑部署，连接可以是单向的或者是双向的</td><td>所有Broker节点都双向连续所有其他节点</td></tr><tr><td>从CAP理论中选择可用性和分区耐受性，即AP</td><td>从CAP理论中选择一致性和可用性,即CA</td></tr><tr><td>一个Broker中的交换器可以是Federation生成的或者是本地的</td><td>集群中所有Broker节点中的交换器都是一样的,要么全有要么全无</td></tr><tr><td>客户端所能看到它所连接的Broker节点上的队列</td><td>客户端连接到集群中的任何Broker节点都可以看到所有的队列</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ架构模型</title>
    <link href="/2020/11/06/RabbitMQ%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/11/06/RabbitMQ%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-AMQP-协议"><a href="#一-AMQP-协议" class="headerlink" title="一 : AMQP 协议"></a>一 : AMQP 协议</h2><p>AMQP (Advanced Message Queuing Protocol)高级消息队列协议, 是应用层协议的一个开放标准, 为面向消息的中间件设计。</p><h3 id="一-AMQP-结构"><a href="#一-AMQP-结构" class="headerlink" title="(一) AMQP 结构"></a>(一) AMQP 结构</h3><p>AMQP 也有类似 OSI 的分层结构概念, 从下往上分别为 : Transport Layer, Session Layer, Module Layer</p><pre><code class=" mermaid">graph BTA[Transport Layer] --- B[Session Layer] --- C[Module Layer]</code></pre><table><thead><tr><th>名称</th><th>位置</th><th>作用</th></tr></thead><tbody><tr><td>Module Layer</td><td>位于最高层</td><td>主要定义了一些供客户端调用的命令<br/>客户端可以利用这些命令实现自己的业务逻辑</td></tr><tr><td>Session Layer</td><td>位于中间层</td><td>负责将客户端的命令发送给服务器,再将服务器的应答返回给客户端<br/>主要为客服端与服务器之间的通信提供可靠性同步机制和错误处理</td></tr><tr><td>Transport Layer</td><td>位于最低层</td><td>主要传输二进制数据流<br/>提供帧的处理、信道复用、错误检测和数据表示等</td></tr></tbody></table><h3 id="二-生产者流转过程"><a href="#二-生产者流转过程" class="headerlink" title="(二) 生产者流转过程"></a>(二) 生产者流转过程</h3><pre><code class=" mermaid">sequenceDiagramNote over Producer: 1.建立连接Producer --&gt;&gt; Broker: Protocol Header 0-9-1Broker --&gt;&gt; Producer: Connection.StartProducer --&gt;&gt; Broker: Connection.Start-OKBroker --&gt;&gt; Producer: Connection.TuneProducer --&gt;&gt; Broker: Connection.Tune-OKProducer --&gt;&gt; Broker: Connection.OpenBroker --&gt;&gt; Producer: Connection.Open-OKNote over Producer: 2.开启通道Producer --&gt;&gt; Broker: Channel.OpenBroker --&gt;&gt; Producer: Channel.Open-OKNote over Producer: 3.发送消息Producer --&gt;&gt; Broker: Basic.PublishNote over Producer: 4.释放资源Producer --&gt;&gt; Broker: Channel.CloseBroker --&gt;&gt; Producer: Channel.Close-OKProducer --&gt;&gt; Broker: Connection.CloseBroker --&gt;&gt; Producer: Connection.Close-OK</code></pre><h3 id="三-消费者流转过程"><a href="#三-消费者流转过程" class="headerlink" title="(三) 消费者流转过程"></a>(三) 消费者流转过程</h3><pre><code class=" mermaid">sequenceDiagramNote over Comsumer: 1.建立链接Comsumer --&gt;&gt; Broker: Protocol Header 0-9-1Broker --&gt;&gt; Comsumer: Connection.StartComsumer --&gt;&gt; Broker: Connection.Start-OKBroker --&gt;&gt; Comsumer: Connection.TuneComsumer --&gt;&gt; Broker: Connection.Tune-OKComsumer --&gt;&gt; Broker: Connection.OpenBroker --&gt;&gt; Comsumer: Connection.Open-OKNote over Comsumer: 2.开启通道Comsumer --&gt;&gt; Broker: Channel.OpenBroker --&gt;&gt; Comsumer: Channel.Open-OKNote over Comsumer: 3.准备接收消息Comsumer --&gt;&gt; Broker: Basic.ConsumeBroker --&gt;&gt; Comsumer: Basic.Consume-OKNote over Broker: 4.borker推送消息Broker --&gt;&gt; Comsumer: Basic.DeliverNote over Comsumer: 5.发送确认Comsumer --&gt;&gt; Broker: Basic.ACKNote over Comsumer: 6.释放资源Comsumer --&gt;&gt; Broker: Channel.CloseBroker --&gt;&gt; Comsumer: Channel.Close-OKComsumer --&gt;&gt; Broker: Connection.CloseBroker --&gt;&gt; Comsumer: Connection.Close-OK</code></pre><h2 id="二-核心概念"><a href="#二-核心概念" class="headerlink" title="二 : 核心概念"></a>二 : 核心概念</h2><h3 id="一-模型架构"><a href="#一-模型架构" class="headerlink" title="(一) 模型架构"></a>(一) 模型架构</h3><pre><code class=" mermaid">graph LRA1((P1)) --Channel1--&gt; B1((Exchange1))A2((P2)) --Channel2--&gt; B2((Exchange2)) C1[Queue1] --&gt; D1((C1)) &amp; D2((C2))C2[Queue2] --&gt; D2((C2)) &amp; D3((C3))subgraph B[RabbitMQ Broker]B1 &amp; B2 --binding key--&gt; C1 &amp; C2end</code></pre><h3 id="二-核心概念-1"><a href="#二-核心概念-1" class="headerlink" title="(二) 核心概念"></a>(二) 核心概念</h3><table><thead><tr><th>角色</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>Producer</td><td>生产者</td><td>生产者创建消息, 然后发布到RabbitMQ中<br>消息一般可以包含两个部分 : 消息体和附加信息<br><strong>消息体 (payload) :</strong> 在实际应用中, 一般是一个带有业务逻辑结构的数据, 比如一个JSON字符串当然可以进一步对这个消息体进行序列化操作<br><strong>附加信息 :</strong> 用来表述这条消息, 比如目标交换器的名称、路由键和一些自定义属性等等</td></tr><tr><td>Channel</td><td>频道或信道</td><td>是建立在 Connection 连接之上的一种轻量级的连接, 大部分的操作是在Channel这个接口中完成的<br>包括定义队列的声明 queueDeclare、交换机的声明 exchangeDeclare、队列的绑定 queueBind、发布消息 basicPublish、消费消息 basicConsume 等</td></tr><tr><td>RoutingKey</td><td>路由键</td><td>生产者将消息发给交换器的时候, 一般会指定一个RoutingKey, 用来指定这个消息的路由规则<br><strong>RoutingKey 需要与交换器类型和绑定键(Bindingkey)联合使用</strong><br>在交换器类型和绑定键(BindingKey)固定的情况下, 生产者可以在发送消息给交换器时, 通过指定 RoutingKey 来决定消息流向哪里</td></tr><tr><td>Exchange</td><td>交换器</td><td>生产者将消息发送到 Exchange (交换器, 通常也可以用大写的“X”来表示), 由交换器将消息路由到一个或者多个队列中, 如果路由不到, 或返回给生产者, 或直接丢弃。</td></tr><tr><td>Queue</td><td>队列</td><td>是RabbitMQ的内部对象,用于存储消息</td></tr><tr><td>Binding</td><td>绑定</td><td>RabbitMQ 中通过绑定将交换器与队列关联起来, 在绑定的时候一般会指定一个<strong>绑定键(BindingKey)</strong>, 这样 RabbitMQ 就知道如何正确地将消息路由到队列了</td></tr><tr><td>Virtual Host</td><td>虚拟主机</td><td>表示一批交换器、消息队列和相关对象, 虚拟主机是共享相同的身份认证和加密环境的独立服务器域<br>每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器, 拥有目己的队列、交换器、绑定和权限机制<br>vhost 是 AMQP 概念的基础, 必须在连接时指定, RabbitMQ 默认的 vhost 是 <code>/</code></td></tr><tr><td>Broker</td><td>服务节点</td><td>一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点, 或者 RabbitMQ 服务实例, 也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器</td></tr><tr><td>Consumer</td><td>消费者</td><td>就是接收消息的一方; 消费者连接到RabbitMQ 服务器, 并订<strong>阅到队列上</strong><br>当消费者消费一条消息时, 只是消费消息的<strong>消息体(payload)</strong>; 在消息路由的过程中, 消息的标签会丢弃, 存入到队列中的消息只有消息体, 消费者也只会消费到消息体, 也就不知道消息的生产者是谁,当然也不需要知道</td></tr></tbody></table><h2 id="三-Exchange-类型"><a href="#三-Exchange-类型" class="headerlink" title="三 : Exchange 类型"></a>三 : Exchange 类型</h2><p>RabbitMQ 常用的交换器类型有 fanout、direct、topic、headers 这四种</p><h3 id="一-fanout"><a href="#一-fanout" class="headerlink" title="(一) fanout"></a>(一) fanout</h3><p>扇型交换机 : 它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中; <strong>类似于广播, 用的不多</strong></p><pre><code class=" mermaid">graph LRA[P] --&gt; B[X&lt;br&gt;type=fanout]B --&gt; C1[Queue1] --&gt; D1[C1]B --&gt; C2[Queue2] --&gt; D2[C2]</code></pre><h3 id="二-direct"><a href="#二-direct" class="headerlink" title="(二) direct"></a>(二) direct</h3><p>直连交换机 : 它会把消息路由到那些 BindingKey 和 RoutingKey 完全匹配的队列中</p><pre><code class=" mermaid">graph LRA[P] --&gt; B[X&lt;br&gt;type=direct]B --warning--&gt; C1[Queue1] --&gt; D1[C1]B --info--&gt; C2[Queue2] --&gt; D2[C2]B --warning--&gt; C2[Queue2] B --debug--&gt; C2[Queue2]</code></pre><h3 id="三-topic"><a href="#三-topic" class="headerlink" title="(三) topic"></a>(三) topic</h3><p>主题交换机 : 与direct类似, 但它可以通过通配符进行模糊匹配; <strong>常用</strong></p><pre><code class=" mermaid">graph LRA[P] --&gt; B[X&lt;br&gt;type=topic]B --&quot;*.rabbitmq.*&quot;--&gt; C1[Queue1] --&gt; D1[C1]B --&quot;*.*.client&quot;--&gt; C2[Queue2] --&gt; D2[C2]B --&quot;com.#&quot;--&gt; C2[Queue2]</code></pre><h3 id="四-headers"><a href="#四-headers" class="headerlink" title="(四) headers"></a>(四) headers</h3><p>头交换机 : 不依赖于路由键的匹配规则来路由消息,而是根据发送的消息内容中的headers属性进行匹配</p><p><strong>headers 类型的交换器性能很差, 而且也不实用。</strong></p><h2 id="四-运转流程"><a href="#四-运转流程" class="headerlink" title="四 : 运转流程"></a>四 : 运转流程</h2><h3 id="一-流转过程"><a href="#一-流转过程" class="headerlink" title="(一) 流转过程"></a>(一) 流转过程</h3><pre><code class=" mermaid">graph LR    subgraph Producer                A[业务数据] --可能的序列化--&gt; B[序列化之后的数据] --&quot;为消息添加Label&lt;br&gt;(Exchange和RoutingKey)&quot;--&gt; C[消息]     end    C --发送至Broker中--&gt; D[(Broker)] --Consumer订阅并接收--&gt; E    subgraph Consumer    E[消息] --可能的反序列化--&gt; F[反序列化之后的数据] --&gt; G[接收的业务数据]  --&gt; H[[业务处理]]    end</code></pre><h3 id="二-架构图"><a href="#二-架构图" class="headerlink" title="(二) 架构图"></a>(二) 架构图</h3><pre><code class=" mermaid">flowchart LRA[Producer] --- B --- C --- D --- E[Consumer]subgraph B[Connection]B1[Channel1&lt;br&gt;Channel2&lt;br&gt;Channel3]endsubgraph C[Broker]subgraph C1[Virtual Host]C11[Exchange] --Binding--- C12[Queue]endendsubgraph D[Connection]D1[Channel1&lt;br&gt;Channel2&lt;br&gt;Channel3]end</code></pre><h3 id="三-生产者发送消息的过程"><a href="#三-生产者发送消息的过程" class="headerlink" title="(三) 生产者发送消息的过程"></a>(三) 生产者发送消息的过程</h3><ol><li><p>生产者连接到RabbitMQ Broker, 建立一个连接(Connection), 开启一个信道(Channel)</p></li><li><p>生产者声明一个交换器, 并设置相关属性, 比如交换机类型、是否持久化等</p></li><li><p>生产者声明一个队列井设置相关属性, 比如是否排他、是否持久化、是否自动删除等</p></li><li><p>生产者通过路由键将交换器和队列绑定起来</p></li><li><p>生产者发送消息至RabbitMQ Broker, 其中包含路由键、交换器等信息</p></li><li><p>相应的交换器根据接收到的路由键查找相匹配的队列</p></li><li><p>如果找到, 则将从生产者发送过来的消息存入相应的队列中</p></li><li><p>如果没有找到, 则根据生产者配置的属性选择丢弃还是回退给生产者</p></li><li><p>关闭信道、关闭连接</p></li></ol><h3 id="四-消费者接收消息的过程"><a href="#四-消费者接收消息的过程" class="headerlink" title="(四) 消费者接收消息的过程"></a>(四) 消费者接收消息的过程</h3><ol><li><p>生产者连接到RabbitMQ Broker, 建立一个连接(Connection), 开启一个信道(Channel)</p></li><li><p>消费者向RabbitMQ Broker请求相应队列中的消息, 可能会设置相应的回调函数, 以及做一些准备工作</p></li><li><p>等待RabbitMQ Broker回应并投递相应队列中的消息, 消费者接收消息</p></li><li><p>消费者确认(ack)接收到的消息</p></li><li><p>RabbitMQ从队列中删除相应己经被确认的消息</p></li><li><p>关闭信道、关闭连接</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="/2020/10/30/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <url>/2020/10/30/RabbitMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 : 简介"></a>一 : 简介</h2><p>RabbitMQ 是一个开源的 AMQP 实现, 服务器端用 Erlang 语言编写, 支持多种客户端。</p><p>用于在分布式系统中存储转发消息, 在易用性、扩展性、高可用性等方面表现不俗。</p><p>官方网站 : <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p>查询erlang版本：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p><h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二 : 安装"></a>二 : 安装</h2><p>环境准备 : ContOS 7, Erlang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载erlang</span><br>wget https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.8.21/erlang-21.3.8.21-1.el7.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装erlang</span><br>rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装socat</span><br>yum install -y socat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载 RabbitMQ</span><br>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.28/rabbitmq-server-3.7.28-1.el7.noarch.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>rpm -ivh rabbitmq-server-3.7.28-1.el7.noarch.rpm<br></code></pre></td></tr></table></figure><p>启动命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>systemctl start rabbitmq-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>systemctl status rabbitmq-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开机启动</span><br>systemctl enable rabbitmq-server<br></code></pre></td></tr></table></figure><h2 id="三-配置"><a href="#三-配置" class="headerlink" title="三 : 配置"></a>三 : 配置</h2><h3 id="一-配置文件"><a href="#一-配置文件" class="headerlink" title="(一) 配置文件"></a>(一) 配置文件</h3><p>RabbitMQ 有一套默认的配置, 能够满足日常开发需求, 如果需要修改, 需要自己创建一个配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">touch</span> /etc/rabbitmq/rabbitmq.conf<br></code></pre></td></tr></table></figure><p>配置文件示例 : <a href="https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example">https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example</a></p><p>配置项说明 : <a href="https://www.rabbitmq.com/configure.html#config-items">https://www.rabbitmq.com/configure.html#config-items</a></p><h3 id="二-默认端口"><a href="#二-默认端口" class="headerlink" title="(二) 默认端口"></a>(二) 默认端口</h3><p>RabbitMQ 会绑定一些端口, 安装完后, 需要将这些端口添加至防火墙</p><table><thead><tr><th>端口</th><th>描述</th></tr></thead><tbody><tr><td>4369</td><td>是 Erlang 的端口&#x2F;结点名称映射程序, 用来跟踪节点名称监听地址, 在集群中起到一个类似DNS的作用</td></tr><tr><td>5672, 5671</td><td>AMQP0-9-1 和 1.0 客户端端口, 没有使用 SSL 和使用 SSL 的端口</td></tr><tr><td>25672</td><td>用于 RabbitMQ 节点间和 CLI 工具通信, 配合 4369 使用</td></tr><tr><td><strong>15672</strong></td><td>HTTP_API 端口, 管理员用户才能访问, 用于管理 RabbitMQ, 需要启用management插件</td></tr><tr><td>61613,61614</td><td>当STOMP插件启用的时候打开, 作为STOMP客户端端口(根据是否使用 TLS 选择)</td></tr><tr><td>1883,8883</td><td>当 MQTT 插件启用的时候打开, 作为 MQTT 客户端端口根据是否使用 TLS 选择)</td></tr><tr><td>15674</td><td>基于 WebSocket 的STOMP客户端端口(当插件Web STOMP启用的时候打开)</td></tr><tr><td>15675</td><td>基于 WebSocket 的 MQTT 客户端端口(当插件Web MQTT启用的时候打开)</td></tr></tbody></table><p>释放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">释放端口</span><br>firewall-cmd --zone=public --add-port=4369/tcp --permanent<br>firewall-cmd --zone=public --add-port=5672/tcp --permanent<br>firewall-cmd --zone=public --add-port=25672/tcp --permanent<br>firewall-cmd --zone=public --add-port=15672/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="四-插件"><a href="#四-插件" class="headerlink" title="四 : 插件"></a>四 : 插件</h2><h3 id="一-web管理界面"><a href="#一-web管理界面" class="headerlink" title="(一) web管理界面"></a>(一) web管理界面</h3><p>RabbitMQ安装包中带有管理插件, 但需要手动激活</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看帮助命令</span><br>rabbitmq-plugins --<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 列出所有插件</span><br>rabbitmq-plugins list<br><span class="hljs-comment"># 激活插件,因为有依赖关系,实际上是启动了3个</span><br>rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><p>访问 : <a href="http://ip:15672/">http://ip:15672</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">账号:</span> <span class="hljs-string">guest</span><br><span class="hljs-string">密码:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><p>“guest”用户默认只能通过本机访问, 要让其它机器可以访问, 需要创建一个新用户, 为其分配权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#添加用户,参数格式: username,password</span><br>rabbitmqctl add_user admin admin <br><span class="hljs-comment"># 为用户分配角色,参数格式: username tag</span><br>rabbitmqctl set_user_tags admin administrator <br><span class="hljs-comment">#为用户分配资源权限,参数格式: -p vhost username conf wirte read</span><br>rabbitmqctl set_permissions -p / admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure><p>修改密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">参数格式: 用户名,新密码</span><br>rabbitmqctl change_password admin Admin@123<br></code></pre></td></tr></table></figure><p>RabbitMQ 的用户角色(tags)分类 : none、management、policymaker、monitoring、administrator</p><table><thead><tr><th>tag</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>不能访问 management plugin</td></tr><tr><td>management</td><td>1.用户可以通过 AMQP 做的任何事<br>2.列出自己可以通过 AMQP 登入的 virtual hosts<br>3.查看自己的 virtual hosts 中的 queues, exchanges 和 bindings<br>4.查看和关闭自己的 channels 和 connections<br>5.查看有关自己的 virtual hosts 的“全局”的统计信息, 包含其他用户在这些virtual hosts中的活动</td></tr><tr><td>policymaker</td><td>1.management 可以做的任何事<br>2.查看、创建和删除自己的 virtual hosts 所属的 policies 和 parameters</td></tr><tr><td>monitoring</td><td>1.management可以做的任何事<br>2.列出所有virtual hosts, 包括他们不能登录的virtual hosts<br>3.查看其他用户的connections和channels<br>4.查看节点级别的数据如clustering和memory使用情况<br>5.查看真正的关于所有virtual hosts的全局的统计信息</td></tr><tr><td>administrator</td><td>1.policymaker和monitoring可以做的任何事<br>2.创建和删除virtual hosts<br>3.查看、创建和删除users<br>4.查看创建和删除permissions<br>5.关闭其他用户的connections</td></tr></tbody></table><h3 id="二-延迟消息插件"><a href="#二-延迟消息插件" class="headerlink" title="(二) 延迟消息插件"></a>(二) 延迟消息插件</h3><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.8.0/rabbitmq_delayed_message_exchange-3.8.0.ez<br></code></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找rabbitmq安装包全名</span><br>rpm -qa | grep rabbit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找插件位置</span><br>rpm -ql rabbitmq-server-3.7.28-1.el7.noarch | grep plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装插件</span><br>cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.7.28/plugins/<br>cp /usr/local/src/rabbitmq/rabbitmq_delayed_message_exchange-3.8.0.ez ./<br></code></pre></td></tr></table></figure><p>激活插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-plugins list<br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><h2 id="五-使用"><a href="#五-使用" class="headerlink" title="五 : 使用"></a>五 : 使用</h2><h3 id="一-java中使用"><a href="#一-java中使用" class="headerlink" title="(一) java中使用"></a>(一) java中使用</h3><p>maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactld</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简单队列生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 2、设置连接属性</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.100.242&quot;</span>);<br>        factory.setPort(<span class="hljs-number">5672</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从连接工厂获取连接</span><br>            connection = factory.newConnection(<span class="hljs-string">&quot;生产者&quot;</span>);<br><br>            <span class="hljs-comment">// 4、从链接中创建通道</span><br>            channel = connection.createChannel();<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 5、声明(创建)队列,如果队列不存在,才会创建;不允许声明两个队列名相同,属性不同的队列,否则会报错</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * 参数说明：</span><br><span class="hljs-comment">             * 1) queue: 队列名称</span><br><span class="hljs-comment">             * 2) durable: 队列是否持久化</span><br><span class="hljs-comment">             * 3) exclusive: 是否排他,即是否为私有的,如果为true,会对当前队列加锁,其它通道不能访问,并且在连接关闭时会自动删除,不受持久化和自动删除的属性控制;一般在队列和交换器绑定时使用</span><br><span class="hljs-comment">             * 4) autoDelete: 是否自动删除,当最后一个消费者断开连接之后是否自动删除</span><br><span class="hljs-comment">             * 5) arguments: 队列参数,设置队列的有效期、消息最大长度、队列中所有消息的生命周期等等</span><br><span class="hljs-comment">             */</span><br>            channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>            <span class="hljs-comment">// 6、发送消息</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>.getBytes());<br>            <br>            <span class="hljs-comment">// 7、关闭通道 关闭连接</span><br>            channel.close();<br>            connection.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单队列消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1、创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 2、设置连接属性</span><br>        factory.setHost(<span class="hljs-string">&quot;192.168.100.242&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3、从连接工厂获取连接</span><br>            connection = factory.newConnection(<span class="hljs-string">&quot;消费者&quot;</span>);<br><br>            <span class="hljs-comment">// 4、从链接中创建通道</span><br>            channel = connection.createChannel();<br><br>            <span class="hljs-comment">// 5、声明(创建)队列</span><br>            channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>            <span class="hljs-comment">// 6、定义收到消息后的回调</span><br>            <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeliverCallback</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(String consumerTag, Delivery message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    System.out.println(<span class="hljs-string">&quot;收到消息: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br>            &#125;;<br>            <span class="hljs-comment">// 7、监听队列</span><br>            channel.basicConsume(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-literal">true</span>, callback, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelCallback</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(String consumerTag)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                &#125;<br>            &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;开始接收消息&quot;</span>);<br>            System.in.read();<br><span class="hljs-comment">// 8、关闭通道,关闭连接</span><br>            channel.close();<br>            connection.close();<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-spring中使用"><a href="#二-spring中使用" class="headerlink" title="(二) spring中使用"></a>(二) spring中使用</h3><p>spring 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactld</span>&gt;</span>spring-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactld</span>&gt;</span>spring-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactld</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>springboot 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Bean</span><br>    CommandLineRunner <span class="hljs-title function_">runner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> args -&gt; rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-string">&quot;hello spring&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;queue1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(String message)</span>&#123;<br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ActiveMQ持久化及事务机制</title>
    <link href="/2020/10/23/ActiveMQ%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/10/23/ActiveMQ%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ActiveMQ持久化机制"><a href="#一-ActiveMQ持久化机制" class="headerlink" title="一 : ActiveMQ持久化机制"></a>一 : ActiveMQ持久化机制</h2><p>ActiveMO 的消息持久化机制有JDBC, AMO, KahaDB和LevelDB无论使用哪种持久化方式, 消息的存储逻辑都是一致的。</p><h3 id="一-Queue类型的持久化机制"><a href="#一-Queue类型的持久化机制" class="headerlink" title="(一) Queue类型的持久化机制"></a>(一) Queue类型的持久化机制</h3><p>消息一旦消费成功就会被删除</p><pre><code class=" mermaid">sequenceDiagramProducer -&gt;&gt;+ ActiveMQ: queue1activate ProducerActiveMQ -&gt;&gt; ActiveMQ: 存储queue1ActiveMQ -&gt;&gt; Producer: 发送成功deactivate ProducerActiveMQ -&gt;&gt;+ Consumer: queueConsumer --&gt;&gt;- ActiveMQ: 消费成功ActiveMQ -&gt;&gt;- ActiveMQ: 删除queue1</code></pre><h3 id="二-Topic-类型的持久化机制"><a href="#二-Topic-类型的持久化机制" class="headerlink" title="(二) Topic 类型的持久化机制"></a>(二) Topic 类型的持久化机制</h3><p>和queue有所不同, 由于topic会有多个消费者订阅, 所以AMQ需要保存不同订阅者的处理进度, 这里就需要有一个类似 java gc 的定期清除策略</p><pre><code class=" mermaid">flowchart LRA((Producer)) --&gt; B4subgraph B[&quot;ActiveMQ(offset:1)&quot;]B1[topic1]B2[topic2]B3[topic3]B4[topic4]endB1 --&gt; C((Consumer))</code></pre><h2 id="二-持久化方式"><a href="#二-持久化方式" class="headerlink" title="二 : 持久化方式"></a>二 : 持久化方式</h2><h3 id="一-JDBC方式"><a href="#一-JDBC方式" class="headerlink" title="(一) JDBC方式"></a>(一) JDBC方式</h3><p><strong>将消息存储到数据库</strong>中, 例如: Mysql、SQL Server、Oracle、DB2等</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方便管理</td><td>性能低</td></tr><tr><td>可以支持强一致性</td><td>&#x2F;</td></tr></tbody></table><h3 id="二-AMQ方式"><a href="#二-AMQ方式" class="headerlink" title="(二) AMQ方式"></a>(二) AMQ方式</h3><p>基于文件的存储方式, 它具有<strong>写入速度快和容易恢复的特点</strong>, 但是由于其重建索引时间过长, 而且索引文件占用磁盘空间过大, 所以已经不推荐使用</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>性能高于JDBC</td><td>索引占用磁盘空间量大</td></tr><tr><td>&#x2F;</td><td>重建索引速度非常慢</td></tr></tbody></table><h3 id="三-KahaDB方式"><a href="#三-KahaDB方式" class="headerlink" title="(三) KahaDB方式"></a>(三) KahaDB方式</h3><p>从 ActiveMQ 5.4开始<strong>默认</strong>的持久化方式, KahaDb恢复时间远远小于其前身AMQ并且使用更少的数据文件, 所以可以完全代替AMQ</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>indexWriteBatchSize</td><td>1000</td><td>索引批量写入磁盘的条数</td></tr><tr><td>indexCacheSize</td><td>10000</td><td>索引缓存条数</td></tr><tr><td>journalMaxFileLength</td><td>32mb</td><td>数据文件的大小</td></tr></tbody></table><h3 id="四-LevelDB方式"><a href="#四-LevelDB方式" class="headerlink" title="(四) LevelDB方式"></a>(四) LevelDB方式</h3><p>LevelDB 是 Google 开发的一套用于持久化数据的高性能类库LevelDB并不是一种服务, 用户需要自行实现 Server。 是单进程的服务, 能够处理十亿级别规模 Key-Value 型数据, 占用内存小。<strong>5.9以后弃用了</strong></p><p>特点 : </p><ol><li>基于KV存储</li><li>Key值有序存储</li><li>操作接口简单</li><li>支持数据快照</li><li>支持数据压缩</li></ol><p>LevelDB的结构</p><pre><code class=" mermaid">flowchart LRA[Data] --写入操作--&gt; B1[MemTable] --&gt; B2[Immutable&lt;br&gt;MemTable] --Compaction--&gt; Csubgraph B[内存]B1B2endsubgraph C[磁盘]subgraph C1[SSTable]        C11[Level0]        C12[Level1]        C13[Level2]endsubgraph C2[文件]C21[.log文件]C22[manifest文件]C23[Current文件]endendC22 --.sst--&gt; C11 C22 --&gt; C12 C22 --&gt; C13 </code></pre><p>ActiveMQ配置LevelDB : 修改配置文件 <code>$&#123;ACTIVEMQ_HOME&#125;/conf/activemq.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">persistenceAdapter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">levelDB</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;$&#123;activemq.data&#125;/activemg-data&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">persistenceAdapter</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三-事务机制"><a href="#三-事务机制" class="headerlink" title="三 : 事务机制"></a>三 : 事务机制</h2><h3 id="一-事务实现机制"><a href="#一-事务实现机制" class="headerlink" title="(一) 事务实现机制"></a>(一) 事务实现机制</h3><p>生产者</p><table><thead><tr><th>Producer</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td><strong>Action:</strong> Create Session<br>transacted: true</td><td></td><td></td></tr><tr><td><strong>Action:</strong> Send Message<br>transactionlD: xxxx</td><td>&#x3D;&gt;</td><td><strong>Actions:</strong><br>1.transaction store<br>2.wait for commit or rollback</td></tr><tr><td><strong>Action:</strong> commit&#x2F;rollback</td><td>&#x3D;&gt;</td><td><strong>Actions:</strong><br>Store Message<br>or<br>Discard Message</td></tr></tbody></table><p>消费者</p><table><thead><tr><th>Consumer</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td><strong>Action:</strong> Create Session<br>transacted: true</td><td></td><td></td></tr><tr><td><strong>Action:</strong> Receive Message</td><td>&lt;&#x3D;</td><td><strong>Action:</strong> Send Message</td></tr><tr><td><strong>Action:</strong> commit&#x2F;rollback</td><td>&#x3D;&gt;</td><td><strong>Actions:</strong><br>Store Message<br/>or<br/>Discard Message</td></tr></tbody></table><h3 id="二-开启事务"><a href="#二-开启事务" class="headerlink" title="(二) 开启事务"></a>(二) 开启事务</h3><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数为事务开关, 为true则会忽略第二个参数, 被jms服务器设置为SESSION_TRANSACTED</span><br>conn.createSession(<span class="hljs-literal">true</span>,Session.SESSION_TRANSACTED);<br><br><span class="hljs-comment">// 提交事务</span><br>session.commit();<br><span class="hljs-comment">// 回滚事务:对应的消息会重发,默认会重发6次</span><br>session.rollback();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>ActiveMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ActiveMQ高可用集群方案</title>
    <link href="/2020/10/16/ActiveMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/16/ActiveMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ActiveMQ高可用集群方案"><a href="#一-ActiveMQ高可用集群方案" class="headerlink" title="一 : ActiveMQ高可用集群方案"></a>一 : ActiveMQ高可用集群方案</h2><p>ActiveMQ 有哪些集群部署方式</p><ol><li>Master-Slave部署方式</li><li>Broker-Cluster部署方式</li><li>Master-Slave与Broker-Cluster相结合的部署方式</li></ol><h2 id="二-Master-Slave部署方式"><a href="#二-Master-Slave部署方式" class="headerlink" title="二 : Master-Slave部署方式"></a>二 : Master-Slave部署方式</h2><h3 id="一-Shared-filesystem"><a href="#一-Shared-filesystem" class="headerlink" title="(一) Shared filesystem"></a>(一) Shared filesystem</h3><pre><code class=" mermaid">graph TBA[File System] --&gt; B1[Broker1 Master]A --&gt; B2[Broker2 Slave]A --&gt; B3[Broker3 Slave]B1 --&gt; C1[Client1]B1 --&gt; C2[Client2]</code></pre><h3 id="二-Shared-database"><a href="#二-Shared-database" class="headerlink" title="(二) Shared database"></a>(二) Shared database</h3><pre><code class=" mermaid">graph TBA[Database] --&gt; B1[Broker1 Master]A --&gt; B2[Broker2 Slave]A --&gt; B3[Broker3 Slave]B1 --&gt; C1[Client1]B1 --&gt; C2[Client2]</code></pre><p>引入数据库驱动包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把mysql驱动包放在activemq目录下的/lib/extra下</span><br>mysql-connector-java-5.1.47.jar<br></code></pre></td></tr></table></figure><p>配置数据源 : <code>conf/activemq.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql-ds&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://10.0.0.10:3306/test_activemq?relaxAutoCommit=true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPreparedStatements&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 开启持久化:persistent=true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">broker</span> <span class="hljs-attr">brokerName</span>=<span class="hljs-string">&quot;localhost&quot;</span> <span class="hljs-attr">persistent</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://activemq.apache.org/schema/core&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">persistenceAdapter</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 持久化适配器引入数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcPersistenceAdapter</span> <span class="hljs-attr">dataSource</span>=<span class="hljs-string">&quot;#mysql-ds&quot;</span> <span class="hljs-attr">useDatabaseLock</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">transactionIsolation</span>=<span class="hljs-string">&quot;4&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">persistenceAdapter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">broker</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>集群配置</strong> : 多台服务器部署启动activemq服务，使用同一个数据库</p><p>客户端使用(<a href="http://activemq.apache.org/failover-transport-reference.html">官方文档</a>) : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// brokerURI 使用failover，故障自动切换方式</span><br>brokerUrl = <span class="hljs-string">&quot;failover:(tcp://10.0.0.11:61616,tcp://10.0.0.12:61616)?initialReconnectDelay=100&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>基本原理 :</strong> </p><ol><li>数据库表自动创建</li><li>多服务器争抢获取 Lock 表锁</li><li>连接断开后, 客户端自动重连</li></ol><h3 id="三-Replicated-LevelDB-Store-弃用"><a href="#三-Replicated-LevelDB-Store-弃用" class="headerlink" title="(三) Replicated LevelDB Store(弃用)"></a>(三) Replicated LevelDB Store(弃用)</h3><p>这种方案就是在数据库层面做主从同步, 但是从 5.9 版本已经弃用, 取代的是KahaDB, 而该方案扔在审核中…</p><pre><code class=" mermaid">flowchart RLA1[Client] --&gt; BA2[Client] --&gt; BA3[Client] --&gt; Bsubgraph B[Master-Slave]B1[Master]B2[Slave]B3[Slave]B1 --- B2 --- B3 --- B1endB --&gt; C[Zookeeper Servers]</code></pre><h2 id="三-Broker-Cluster部署方式"><a href="#三-Broker-Cluster部署方式" class="headerlink" title="三 : Broker-Cluster部署方式"></a>三 : Broker-Cluster部署方式</h2><h3 id="一-部署方式"><a href="#一-部署方式" class="headerlink" title="(一) 部署方式"></a>(一) 部署方式</h3><pre><code class=" mermaid">flowchart LRA[Client] --&gt; BB[负载均衡器] -.-&gt; C1[Broker1]B -.-&gt; C2[Broker2]C1 &lt;--networkConnector--&gt; C2</code></pre><p>通过网络连接, 将多个broker组合, 对外构成一个整体, 集群间共享队列和主题列表。</p><h3 id="二-Static-部署配置"><a href="#二-Static-部署配置" class="headerlink" title="(二) Static 部署配置"></a>(二) Static 部署配置</h3><p>在 <code>$&#123;ACTIVEMQ_HOME&#125;/conf/activemq.xml</code> 中静态指定Broker需要桥连接的其它Broker</p><ol><li><p>所有节点中添加 networkConnector 节点, uri地址为集群内其他节点信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">networkConnectors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">networkConnector</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;static:(tcp://other-broker:port)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">networkConnectors</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>所有的broker都启动后, 可以在web管理界面的Network页面可以看到连接信息</p></li></ol><h3 id="三-Dynamic-部署配置"><a href="#三-Dynamic-部署配置" class="headerlink" title="(三) Dynamic 部署配置"></a>(三) Dynamic 部署配置</h3><p>在 <code>$&#123;ACTIVEMQ_HOME]/conf/activemq.xml</code> 中静态指定Broker需要桥连接的其它Broker,由activemg启动后动态查找; 基于multicast技术, 确保网络互通</p><ol><li><p>首先在Broker节点中添加networkConnector节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">networkConnectors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">networkConnector</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;multicast://default&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">networkConnectors</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改transportConnector, 增加discoveryUri属性, 并添加publishedAddressPolicy</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;openwire&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="hljs-symbol">&amp;amp;</span>wireFormat.maxFiameSize=104857600&quot;</span> <span class="hljs-attr">discoveryUri</span>=<span class="hljs-string">&quot;multicast://default&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">publishedAddressPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">publishedAddressPolicy</span> <span class="hljs-attr">publishedHostStrategy</span>=<span class="hljs-string">&quot;IPADDRESS&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">publishedAddressPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">publishedAddressPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transportConnector</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="四-Master-Slave结合Broker-Cluster"><a href="#四-Master-Slave结合Broker-Cluster" class="headerlink" title="四 : Master-Slave结合Broker-Cluster"></a>四 : Master-Slave结合Broker-Cluster</h2><h3 id="一-结构"><a href="#一-结构" class="headerlink" title="(一) 结构"></a>(一) 结构</h3><pre><code class=" mermaid">flowchart LRA[Client] --&gt; B[负载均衡器]B --&gt; C1B --&gt; D1B --&gt; E1subgraph C[Master-Slave]C1[Master]C2[Slave]C3[Slave]C1 --- C2 --- C3 --- C1endsubgraph D[Master-Slave]D1[Master]D2[Slave]D3[Slave]D1 --- D2 --- D3 --- D1endsubgraph E[Master-Slave]E1[Master]E2[Slave]E3[Slave]E1 --- E2 --- E3 --- E1end</code></pre><h3 id="二-部署配置"><a href="#二-部署配置" class="headerlink" title="(二) 部署配置"></a>(二) 部署配置</h3><p>修改 <code>$&#123;ACTIVEMQ_HOME&#125;/conf/activemq.xml</code> 在Broker节点中添加多个networkConnector, 连接到多个broker集群</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">networkConnectors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">networkConnector</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;masterslave:(tcp://other-cluster-1-master:61616,tcp://cluster-1-slave:61616)&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">networkConnector</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;masterslave:(tcp://other-cluster-2-master:61616,tcp://cluster-2-slave:61616)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">networkConnectors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="五-网络连接器配置说明"><a href="#五-网络连接器配置说明" class="headerlink" title="五 : 网络连接器配置说明"></a>五 : 网络连接器配置说明</h2><p>networkConnector配置属性</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>bridge</td><td>名称</td></tr><tr><td>dynamicOnly</td><td>false</td><td>如果为true,持久订阅被激活时才创建对应的持久订阅</td></tr><tr><td>decreaseNetworkConsumerPriority</td><td>false</td><td>如果为true,网络的消费者优先级降低为-5;如果为false,则默认跟本地消费者一样为0</td></tr><tr><td>networkTTL</td><td>1</td><td>消息和订阅在网络上通过的broker数量</td></tr><tr><td>conduitSubscriptions</td><td>true</td><td>多个网络消费者是否被当做一个消费者来对待</td></tr><tr><td>excludedDestinations</td><td>empty</td><td>不通过网络转发的destination</td></tr><tr><td>dynamicallylncludedDestinations</td><td>empty</td><td>通过网络转发的destinations,<strong>注意空列表代表所有的都转发</strong></td></tr><tr><td>staticallylncludedDestinations</td><td>empty</td><td>匹配的都将通过网络转发-即使没有对应的消费者</td></tr><tr><td>duplex</td><td>false</td><td>如果为true, 则既可消费又可生产消息到网络broker</td></tr><tr><td>prefetchSize</td><td>1000</td><td>设置网络消费者的prefetch size参数; <strong>必须大于0</strong>,因为网络消费者不能自己轮询消息</td></tr><tr><td>suppressDuplicateQueueSubscriptions</td><td>false</td><td>如果为true,重复的订阅关系一产生即被阻止(注意: 从5.3版本开始)</td></tr><tr><td>bridgeTempDestinations</td><td>true</td><td>是否广播advisory messages来创建临时destination</td></tr><tr><td>alwaysSyncSend</td><td>false</td><td>如果为true,非持久化消息也将使用request&#x2F;reply方式代替oneway方式发送到远程broker(注意: 5.6版本开始)</td></tr><tr><td>staticBridge</td><td>false</td><td>如果为true,只有staticallylncludedDestinations中配置的destination可以被处理(注意: 5.6版本开始)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>ActiveMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ActiveMQ支持的消息协议</title>
    <link href="/2020/10/09/ActiveMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/10/09/ActiveMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ActiveMQ-支持哪些协议"><a href="#一-ActiveMQ-支持哪些协议" class="headerlink" title="一 : ActiveMQ 支持哪些协议"></a>一 : ActiveMQ 支持哪些协议</h2><h3 id="一-支持的协议"><a href="#一-支持的协议" class="headerlink" title="(一) 支持的协议"></a>(一) 支持的协议</h3><p>ActiveMO支持多种协议传输和传输方式, 允许客户端使用多种协议连接。</p><p>ActiveMQ支持的协议 : AUTO、OpenWire、AMQP、Stomp、MQTT等。</p><p>ActiveMO支持的基础传输方式 : VM、TCP、SSL、UDP、Peer、Multicast、HTTP(S)等, 以及更高级的Failover、Fanout、 Discovery、 ZeroConf方式。</p><h3 id="二-协议连接配置"><a href="#二-协议连接配置" class="headerlink" title="(二) 协议连接配置"></a>(二) 协议连接配置</h3><p>在 <code>$&#123;ACTIVEMQ_HOME&#125;/conf/activemq.xml</code> 中, 通过配置 <code>&lt;transportConnectors&gt;</code> 就可以使用多种传输方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnectors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;openwire&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;tcp:/0.0.0.0:61616?maximumConnections-1000&amp;wireFormat.maxFramesSize=104857600&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;amqp&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;amgp://0.0.0.0:5672?maximumConnections=1000&amp;wirefFormat.maxFramesSize=104857600&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stomp&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;matt&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;matt:/0.0.0.0:1883?maximumConnections=1000&amp;wireformat,.maxFramesize=104857600&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name-</span>&quot;<span class="hljs-attr">ws</span>&quot; <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat,maxFrameSize=104857600&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transportConnectors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="二-传输方式配置"><a href="#二-传输方式配置" class="headerlink" title="二 : 传输方式配置"></a>二 : 传输方式配置</h2><h3 id="一-TCP"><a href="#一-TCP" class="headerlink" title="(一) TCP"></a>(一) TCP</h3><p>由于TCP具有可靠传输的特性, 它在ActiveMQ中也是最常使用的一种协议。在默认的配置中, TCP连接的端口为61616</p><p>配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp://hostname:port?key=value<br></code></pre></td></tr></table></figure><p>配置注意事项</p><ul><li><p>在服务器端配置时, 参数要以 <code>transport.</code> 开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">服务器端配置示例</span><br>tcp://ocalhost:61616?transport.threadName&amp;transport.trace=false&amp;transport.soTimeout=60000<br></code></pre></td></tr></table></figure></li><li><p>在客户端连接时, 参数省略 <code>transport.</code> 前缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">客户端配置示例</span><br>tcp://localhost:61616?threadName&amp;trace=false&amp;soTimeout=60000<br></code></pre></td></tr></table></figure></li></ul><p>TCP配置参数说明</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>backlog</td><td>5000</td><td>指定传输服务器套接字等待接受的最大连接数。</td></tr><tr><td>connectionTimeout</td><td>30000</td><td>超时时间, &gt;&#x3D;1时才有超时时间 (单位为毫秒); 为0表示没有超时, 负值被忽略。</td></tr><tr><td>daemon</td><td>false</td><td>如果为true, 则传输线程将以守护进程模式运行; 将代理嵌入Spring容器或Web容器中时, 请将此参数设置为true,以允许容器正确关闭。</td></tr><tr><td>dynamicManagement</td><td>false</td><td>如果为true, 则可以通过JMX管理TransportLogger。</td></tr><tr><td>ioBufferSize</td><td>8*1024</td><td>协议解析使用的缓冲区的大小。(非TCP缓冲区)</td></tr><tr><td>jmxPort</td><td>1099</td><td>(仅在客户端有效)JMX端口</td></tr><tr><td>keepAlive</td><td>false</td><td>如果为true, 则在<strong>Broker连接上启用TCP KeepAlive</strong>, 以防止连接在TCP级别超时; 这不要和<strong>InactivitvMonitor使用的KeepAlivelnfo</strong>消息混淆。</td></tr><tr><td>maximumConnections</td><td>Integer.MAX_VALUE</td><td>broker允许的最大socket数量</td></tr><tr><td>socketBufferSize</td><td>64*1024</td><td>设置接受的套接字读写缓冲区的大小(以字节为单位)</td></tr><tr><td>soLinger</td><td>Integer.MIN_VALUE</td><td>当值&gt;-1时, 设置套接字的选项soLinger; 设置为-1时, 将禁用soLinger套接字选项</td></tr><tr><td>soTimeout</td><td>0</td><td>设置套接字的读取超时(以毫秒为单位); 0表示没有超时</td></tr><tr><td>soWriteTimeout</td><td>0</td><td>设置套接字的写入超时(以毫秒为单位); 0表示没有超时</td></tr><tr><td>stackSize</td><td>0</td><td>设置服务端后台读取线程的堆栈大小; 必须以128K的倍数指定; 0表示忽略此参数</td></tr><tr><td>startLogging</td><td>true</td><td>true, 将传输信息TransportLogger对象写入日志; 仅在trace&#x3D;true的场景下生效</td></tr><tr><td>tcpNoDelay</td><td>false</td><td>如果为true, 则设置套接字的选项TCP_NODELAY; 这会禁用Nagle的小数据包传输算法</td></tr><tr><td>threadName</td><td>N&#x2F;A</td><td>指定调用transport的线程名称; 若以服务器host命名, 调试线程的时候可以看到</td></tr><tr><td><strong>trace</strong></td><td>false</td><td>为true时, 服务器记录传输发送的所有命令内容; log4j.logger.org.apache.activemq.transport.TransportLogger&#x3D;DEBUG</td></tr><tr><td>trafficClass</td><td>0</td><td>ip协议级别的服务质量参数。(0x02, 0x04, 0x08, 0x10)</td></tr><tr><td>uselnactivityMonitor</td><td>true</td><td>false, 则禁用InactivityMonitor, 连接永远不会超时</td></tr><tr><td><strong>useKeepAlive</strong></td><td>true</td><td>true,在空闲连接上发送KeepAlivelnfo消息, 防止它超时; false, 指定的时间内没有接收到数据, 连接超时。</td></tr></tbody></table><h3 id="二-SSL"><a href="#二-SSL" class="headerlink" title="(二) SSL"></a>(二) SSL</h3><p>需要一个安全连接的时候可以考虑使用SSL, 适用于client和broker在公网的情况如使用aws云平台等; </p><p>官方文档 : <a href="http://activemq.apache.org/ssl-transport-reference.html">http://activemq.apache.org/ssl-transport-reference.html</a></p><p>配置格式(可配置参数和TCP相同)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssl://localhost:61616<br></code></pre></td></tr></table></figure><p>SSL客户端配置 : JMS 客户端需要使用ActiveMQSslConnectionFactory 类创建连接, brokerUrl以 <code>ssl://</code> 开头, 以下是 Spring 配置示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AMQJMSConnectionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.activemq.ActiveMQSslConnectionFactory&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trustStore&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/path/to/truststore.ts&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trustStorePassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keyStore&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/path/to/keystore.ks&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keyStorePassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;brokerURL&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ssl://localhost:61616&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;admin&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;admin&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SSL主机名验证 : 从ActiveMQ5.15.6开始, ActiveMo 开始支持TLS主机名验证, 默认情况下客户端启用了该验证, 而服务器端没有启用。</p><p>服务器端配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssl://localhost:61616?transport.verifyHostName=true<br></code></pre></td></tr></table></figure><p>客户端端配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssl://localhost:61616?socket.verifyHostName=false<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>ssl://localhost:61616?verifyHostName=false<br></code></pre></td></tr></table></figure><h3 id="三-NIO"><a href="#三-NIO" class="headerlink" title="(三) NIO"></a>(三) NIO</h3><p>使用 Java 的 NIO 方式对连接进行改进, 因为 NIO 使用线程池, 可以复用线程, 所以可以用更少的线程维持更多的连接; 如果有大量的客户端, 或者性能瓶颈在网络传输上, 可以考虑使用NIO的连接方式。</p><p>NIO配置格式, 可配置参数和TCP相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nio://hostname:port?key=value<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NIO是OpenWire协议的传输方式,其它协议,像AMQP、MQTT、Stomp,也有NIO的实现,通常在协议前缀中加<span class="hljs-string">&quot;+nio&quot;</span>来区分。示例:</span><br>mgtt+nio://localhost:1883<br></code></pre></td></tr></table></figure><p>NIO传输线程使用情况配置 : 从5.15.0开始, ActiveMQ支持调整NIO的传输线程, 可以设置以下属性</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>org.apache.activemq.transport.nio.SelectorManager.corePoolSize</td><td>10</td><td>核心线程池线程数</td></tr><tr><td>org.apache.activemq.transport.nio.SelectorManager.maximumPoolSize</td><td>1024</td><td>线程池最大线程数</td></tr><tr><td>org.apache.activemq.transport.nio.SelectorManager.workQueueCapacity</td><td>0</td><td>线程池队列容量</td></tr><tr><td>org.apache.activemq.transport.nio.SelectorManager.rejectWork</td><td>false</td><td>当达到容量时, 允许使用IOException 拒绝工作以便可以保留现有的QOS</td></tr></tbody></table><p>NIO传输线程使用情况配置 : 属性可以在 <code>$&#123;ACTIVEMQ_HOME&#125;/bin/env</code> 中配置, 示例 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACTIVEMQ_OPTS=&quot;$ACTIVEMQ_OPTS -Dorg.apache.activemq.transport.nio.SelectorManager.corePoolSize=2000 -Dorg.apache.activemq.transport.nio.SelectorManagermaximumPoolSize=2000 -Dorg.apache.activemq.transport.nio.SelectorManager.workQueueCapacity=1024&quot;<br></code></pre></td></tr></table></figure><p>NIO SSL : 从ActiveMQ5.6版本开始, NIO可以支持和SSL搭配使用的传输连接。</p><p>NIO+SSL配置格式, 可配置参数和TCP相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nio+ssl://0.0.0.0:61616<br></code></pre></td></tr></table></figure><h3 id="四-UDP"><a href="#四-UDP" class="headerlink" title="(四) UDP"></a>(四) UDP</h3><p>与面向连接, 可靠的字节流服务的TCP不同, UDP是一个面向数据的简单传输连接, 没有TCP的三次握手, 所以性能大大强于TCP, 但是是以牺牲可靠性为前提。适用于丢失也无所谓的消息。</p><p>UDP配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">udp://localhost:8123<br></code></pre></td></tr></table></figure><p>UDP配置参数说明</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>trace</td><td>false</td><td>为true时, 将会记录传输发送的所有命令</td></tr><tr><td>useLocalHost</td><td>true</td><td>为true时, 本机机器名被解析为localhost</td></tr><tr><td>datagramSize</td><td>4*1024</td><td>指定数据报的大小</td></tr></tbody></table><h3 id="五-HTTP-S"><a href="#五-HTTP-S" class="headerlink" title="(五) HTTP(S)"></a>(五) HTTP(S)</h3><p>需要穿越防火墙, 可以考虑使用HTTP(S), 但由于HTTP(S)是短连接, 每次创建连接的成本较高, 所以性能最差。通过XML传输数据。</p><p>HTTP配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://localhost:8080?param1=val1&amp;param2=val2<br></code></pre></td></tr></table></figure><p>HTTPS配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://localhost:8080?param1=val1&amp;param2=val2<br></code></pre></td></tr></table></figure><h3 id="六-VM"><a href="#六-VM" class="headerlink" title="(六) VM"></a>(六) VM</h3><p>虚拟机协议(方法直调), 使用场景是client和broker在同一个Java虚拟机内嵌的情况, 无需网络通信的开销。</p><p>VM配置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vm://brokerName?marshal=false&amp;broker.persistent=false<br></code></pre></td></tr></table></figure><p>VM配置参数说明</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>create</td><td>true</td><td>如果不存在, 则创建broker</td></tr><tr><td>waitForStart</td><td>-1</td><td>如果&gt;0, 则表示等待代理启动的超时 (以毫秒为单位); 值-1和0表示不等待, 仅在ActiveMQ 5.2+支持</td></tr><tr><td>wireFormat</td><td>default</td><td>命令的组装格式(协议)</td></tr><tr><td>marshal</td><td>false</td><td>强制发送的每个命令使用WireFormat进行格式转换</td></tr></tbody></table><h2 id="三-OpenWire-协议"><a href="#三-OpenWire-协议" class="headerlink" title="三 : OpenWire 协议"></a>三 : OpenWire 协议</h2><h3 id="一-OpenWire协议是什么"><a href="#一-OpenWire协议是什么" class="headerlink" title="(一) OpenWire协议是什么"></a>(一) OpenWire协议是什么</h3><p><strong>OpenWire</strong> 是Apache的一种跨语言的协议, 允许从不同的语言和平台访问ActiveMQ, 是ActiveMQ 4.x以后的版本默认的传输协议。</p><p>官方文档 : </p><ul><li><a href="http://activemq.apache.org/openwire-version-2-specification.html">http://activemq.apache.org/openwire-version-2-specification.html</a></li><li><a href="http://activemq.apache.org/wire-protocol.html">http://activemq.apache.org/wire-protocol.html</a></li></ul><h3 id="二-OpenWire协议如何使用"><a href="#二-OpenWire协议如何使用" class="headerlink" title="(二) OpenWire协议如何使用"></a>(二) OpenWire协议如何使用</h3><p>OpenWire 支持TCP、SSL、NIO、UDP、VM等传输方式, 直接配置这些连接, 就是使用的OpenWire协议, OpenWire有自己的配置参数, 客户端和服务器端配置的参数名都通过前缀 <code>wireFormat.</code>表示。官方文档 : <a href="http://activemq.apache.org/configuring-wire-formats.html">http://activemq.apache.org/configuring-wire-formats.html</a></p><p>示例 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp://localhost:61616?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false<br></code></pre></td></tr></table></figure><p>OpenWire的配置参数说明</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>stackTraceEnabled</td><td>true</td><td>是否应该把已经发生并且跟踪到的堆栈异常, 通过Broker发送到客户端</td></tr><tr><td>tcpNoDelayEnabled</td><td>true</td><td>socket的NoDelay参数</td></tr><tr><td>cacheEnabled</td><td>true</td><td>如果不断重复的值进行缓存, 以便少编组(马上要进行的发送)发生</td></tr><tr><td>tightEncodingEnabledtrue</td><td>true</td><td>根据CPU使用情况, 自动调整传输内容大小(压缩比例)</td></tr><tr><td>prefixPacketSize</td><td>true</td><td>在每个包被编组前(马上要被发送), 每个包的大小是否应该作为前缀</td></tr><tr><td>maxlnactivityDuration</td><td>30000</td><td>连接的最大空闲时间,以毫秒为单位; broker服务会根据配置关闭超时的连接; 同时也可以通过心跳机制来保持连接; 值&lt;&#x3D;0则禁用活动连接的监测。</td></tr><tr><td>maxInactivityDurationlnitalDelay</td><td>10000</td><td>连接建立之后, 多久开始进行超时检测</td></tr><tr><td>cacheSize</td><td>1024</td><td>如果能被缓存, 那么这个规定了缓存的最大数量; 此属性中在ActiveMO的4.1中开始添加使用</td></tr><tr><td>maxFrameSize</td><td>MAX_LONG</td><td>可发送最大帧大小; 可以帮助防止OOMDOS攻击</td></tr></tbody></table><h2 id="四-MQTT-协议"><a href="#四-MQTT-协议" class="headerlink" title="四 : MQTT 协议"></a>四 : MQTT 协议</h2><h3 id="一-为什么使用MQTT协议"><a href="#一-为什么使用MQTT协议" class="headerlink" title="(一) 为什么使用MQTT协议"></a>(一) 为什么使用MQTT协议</h3><p><strong>MQTT</strong> (Message Queuing Telemetry Transport) 消息队列遥测传输是 IBM 开发的一个即时通讯协议，已成为物联网通信的标准。</p><p><strong>MQTT</strong> 的结构简单, 相对于其它消息协议, 它更加轻量级。适合在计算能力有限、低带宽、不可靠的网络环境使用。</p><h3 id="二-MQTT的发布订阅模型"><a href="#二-MQTT的发布订阅模型" class="headerlink" title="(二) MQTT的发布订阅模型"></a>(二) MQTT的发布订阅模型</h3><pre><code class=" mermaid">graph LRA[Sensor] --Publish sensor_data--&gt; B[Broker]B --Subscribe config_change--&gt; AB --Subscribe sensor_data--&gt; C[Data processing and storage]B --Publish config_change--- D[Admin console]</code></pre><h3 id="三-MQTT服务质量"><a href="#三-MQTT服务质量" class="headerlink" title="(三) MQTT服务质量"></a>(三) MQTT服务质量</h3><p>什么是服务质量? <strong>服务质量(QoS)</strong> 级别是一种关于发送者和接收者之间信息投递的保证协议。</p><table><thead><tr><th>级别(值)</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>至多一次</td></tr><tr><td>1</td><td>至少一次</td></tr><tr><td>2</td><td>只有一次</td></tr></tbody></table><p><strong>为什么要有服务质量?</strong> QoS是MQTT的一个主要功能, 它使得在不可靠的网络下进行通信变得更为简单, 因为即便是在非常不可靠的网络下, 协议也可以掌控是否需要重发消息并保证消息到达。它也能帮助客户端根据网络环境和程序逻辑来自由选择 QoS。</p><p><strong>Qos level 0 是怎样工作的?</strong> </p><table><thead><tr><th>Client</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td>Qos &#x3D; 0</td><td>PUBLISH &#x3D;&gt;</td><td><strong>Action:</strong> Publish message to subscribers then Forget<br><strong>Reception:</strong> &lt;&#x3D;1</td></tr></tbody></table><p><strong>Qos level 1 是怎样工作的?</strong> </p><p>针对客户端发布消息到服务器的消息流 :</p><table><thead><tr><th>Client</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td>OoS&#x3D;1<br/>DUP&#x3D;0<br/>Message ID&#x3D;x<br/>Action: Store<br/>message</td><td>PUBLISH &#x3D;&gt;</td><td><strong>Actions:</strong> <br>1.Store message<br>2.Publish message to subscribers<br>3.Delete message<br/><strong>Reception:</strong> &gt;&#x3D;1</td></tr><tr><td>Action: Discard<br/>message</td><td>PUBACK &lt;&#x3D;</td><td>Message ID&#x3D;x</td></tr></tbody></table><p>针对服务器发布到订阅者的消息流 :</p><table><thead><tr><th>Server</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td>QoS&#x3D;1<br>DUP&#x3D;0<br>MessageID&#x3D;x</td><td>PUBLISH &#x3D;&gt;</td><td><strong>Actions:</strong> <br>1.Store message<br>2.Make message available<br><strong>Reception:</strong> &gt;&#x3D;1</td></tr><tr><td></td><td>PUBACK &lt;&#x3D;</td><td>Message ID &#x3D;x</td></tr></tbody></table><p><strong>Qos level 2 是怎样工作的?</strong> </p><p>针对客户端发布消息到服务器的消息流</p><table><thead><tr><th>Client</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td>QoS&#x3D;2<br>DUP&#x3D;0<br/>MessageID &#x3D;x<br/>Action: Store message</td><td>PUBLISH &#x3D;&gt;</td><td><strong>Action(a):</strong> Store message<br>or<br/><strong>Actions(b):</strong><br/>1.Store message ID<br/>2.Publish message to subscribers</td></tr><tr><td></td><td>PUBREC &lt;&#x3D;</td><td>MessageID&#x3D;x</td></tr><tr><td>MessageID&#x3D;x</td><td>PUBREL &#x3D;&gt;</td><td><strong>Actions(a):</strong> <br>1.Publish message to subscribers<br>2.Delete message<br/>or<br><strong>Action(b):</strong> Delete message lD</td></tr><tr><td></td><td>PUBCOMP &lt;&#x3D;</td><td>MessageID&#x3D;x</td></tr></tbody></table><p>针对服务器发布到订阅者的消息流 :</p><table><thead><tr><th>Server</th><th>Message and direction</th><th>Server</th></tr></thead><tbody><tr><td>QoS&#x3D;2<br/>DUP&#x3D;0<br/>MessageID&#x3D;x</td><td>PUBLISH &#x3D;&gt;</td><td><strong>Action:</strong> Store message</td></tr><tr><td></td><td>PUBREC &lt;&#x3D;</td><td>MessageID&#x3D;x</td></tr><tr><td>MessageID&#x3D;x</td><td>PUBREL &#x3D;&gt;</td><td><strong>Actions:</strong> Make message available</td></tr><tr><td></td><td>PUBCOMP &lt;&#x3D;</td><td>MessageID&#x3D;x</td></tr></tbody></table><h3 id="四-ActiveMQ中如何使用MQTT协议"><a href="#四-ActiveMQ中如何使用MQTT协议" class="headerlink" title="(四) ActiveMQ中如何使用MQTT协议"></a>(四) ActiveMQ中如何使用MQTT协议</h3><p>ActiveMQ 服务器端配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnectors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mgtt&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;mgtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transportConnectors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MOTT配置参数说明</p><table><thead><tr><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>maxFrameSize</td><td>268435456</td><td>(v5.12.0) 可以发送的最大大小。协议限制为256MB, 其值不能设置得更高。可以帮助防止OOM DOS攻击</td></tr></tbody></table><p>配置示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mgtt&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;mgtt://localhost:1883?wireFormat.maxFrameSize=100000&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>MQTT 使用NIO</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mgtt+nio&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;mgtt+nio://localhost:1883&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>MQTT 使用NIO +SSL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mgtt+nio&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;mgtt+nio+ssl://localhost:1883&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>MQTT 也支持层次结构和通配符, 但分隔符和ActiveMQ不同, 映射关系</p><table><thead><tr><th>作用</th><th>ActiveMQ</th><th>MQTT</th></tr></thead><tbody><tr><td>分隔符</td><td>.</td><td>&#x2F;</td></tr><tr><td>元素</td><td>*</td><td>+</td></tr><tr><td>子节点</td><td>&gt;</td><td>#</td></tr></tbody></table><p>示例</p><ul><li>主题名: foo.blah.bar</li><li>在MQTT的客户端订阅时, 可以为foo&#x2F;+&#x2F;bar</li><li>在JMS订阅时, 可以为foo.*.bar</li></ul><h3 id="五-Spring使用MQTT"><a href="#五-Spring使用MQTT" class="headerlink" title="(五) Spring使用MQTT"></a>(五) Spring使用MQTT</h3><p>Spring integration 提供了MQTT协议的支持, 通过Maven添加依赖即可使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.integration<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-integration-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>官方教程 : <a href="https://docs.spring.io/spring-integration/reference/html/mqtt.html">https://docs.spring.io/spring-integration/reference/html/mqtt.html</a></p><h2 id="五-AUTO-协议"><a href="#五-AUTO-协议" class="headerlink" title="五 : AUTO 协议"></a>五 : AUTO 协议</h2><h3 id="一-AUTO协议是什么"><a href="#一-AUTO协议是什么" class="headerlink" title="(一) AUTO协议是什么"></a>(一) AUTO协议是什么</h3><p><strong>AUTO</strong> 自动检测协议</p><p>从ActiveMQ 5.13.0开始, ActiveMO 开始支持协议格式检测, 可以自动检测OpenWire、STOMP、AMQP和MQTT。</p><p>允许这4种类型的客户端共享一个传输。</p><h3 id="二-如何使用AUTO协议"><a href="#二-如何使用AUTO协议" class="headerlink" title="(二) 如何使用AUTO协议"></a>(二) 如何使用AUTO协议</h3><p>AUTO 使用TCP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;auto://localhost:5671&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>AUTO 使用SSL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto+ssl&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;auto+ssl://localhost:5671&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>AUTO 使用NIO</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto+nio&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;auto+nio://localhost:5671&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>AUTO 使用NIO+SSL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transportConnector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto+nio+ssl&quot;</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">&quot;auto+nio+ssl://localhost:5671&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>ActiveMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ActiveMQ入门</title>
    <link href="/2020/09/25/ActiveMQ%E5%85%A5%E9%97%A8/"/>
    <url>/2020/09/25/ActiveMQ%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一-ActiveMQ-是什么"><a href="#一-ActiveMQ-是什么" class="headerlink" title="一 : ActiveMQ 是什么"></a>一 : ActiveMQ 是什么</h1><p>ActiveMQ 是 Apache 出品, 最流行的, 能力强劲的开源消息总线</p><p>ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现, 尽管 jMS 规范出台已经是很久的事情了, 但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位</p><h1 id="二-JMS-规范"><a href="#二-JMS-规范" class="headerlink" title="二 : JMS 规范"></a>二 : JMS 规范</h1><p>Java 消息服务 (java message service, 即 JMS) 应用程序接口是一个 java 平台中关于面向消息中间件 (MOM) 的 API, 用于在两个应用程序之间, 或分布式系统中发送消息, 进行异步通信; </p><p><strong>JMS 是一个与具体平台无关的 API</strong></p><h2 id="一-JMS-的对象模型"><a href="#一-JMS-的对象模型" class="headerlink" title="(一) JMS 的对象模型"></a>(一) JMS 的对象模型</h2><table><thead><tr><th>对象</th><th>解释</th></tr></thead><tbody><tr><td>ConnectionFactory</td><td>连接工厂</td></tr><tr><td>Connection</td><td>连接</td></tr><tr><td>Session</td><td>会话</td></tr><tr><td>Destination</td><td>目的</td></tr><tr><td>MessageProducer</td><td>生产者</td></tr><tr><td>MessageConsumer</td><td>消费者</td></tr><tr><td>Message</td><td>消息</td></tr><tr><td>Broker</td><td>消息中间件的实例(ActiveMQ)</td></tr></tbody></table><h2 id="二-JMS-的消息模型"><a href="#二-JMS-的消息模型" class="headerlink" title="(二) JMS 的消息模型"></a>(二) JMS 的消息模型</h2><p>Point-to-Point (P2P) &#x2F; 点对点 </p><pre><code class=" mermaid">graph LRA1[Producer] --message--&gt; B[Queue] A2[Producer] --&gt; BA3[Producer] --&gt; BB --&gt; C1[Consumer]B --&gt; C2[Consumer]B --&gt; C3[Consumer]B --message--&gt; C4[Consumer]B --&gt; C5[Consumer]</code></pre><p>Publish &#x2F; Subscribe (Pub &#x2F; Sub) &#x2F; 主题 (发布订阅)</p><pre><code class=" mermaid">graph LRA1[Producer] --message--&gt; B[Topic] A2[Producer] --&gt; BA3[Producer] --&gt; BB --message--&gt; C1[Consumer]B --message--&gt; C2[Consumer]B --message--&gt; C3[Consumer]B --message--&gt; C4[Consumer]B --message--&gt; C5[Consumer]</code></pre><h2 id="三-JMS-的消息结构"><a href="#三-JMS-的消息结构" class="headerlink" title="(三) JMS 的消息结构"></a>(三) JMS 的消息结构</h2><pre><code class=" mermaid">graph TBsubgraph 消息消息头消息属性消息体end</code></pre><p><strong>消息头 :</strong> 关于一些消息的描述信息</p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>JMSDestination</td><td>消息的目的地, Topic 或者是 Queue</td></tr><tr><td>JMSDeliveryMode</td><td>消息的发送模式</td></tr><tr><td>JMSTimestamp</td><td>消息传递给Broker的时间戳, 它不是实际发送的事件</td></tr><tr><td>JMSExpiration</td><td>消息的有效期,在有效期内,消息消费者才可以消费</td></tr><tr><td>JMSPriority</td><td>消息的优先级;0-4为正常的优先级,5-9为高优先级</td></tr><tr><td>JMSMessageID</td><td>一个字符串用来唯一标示一个消息</td></tr><tr><td>JMSReplyTo</td><td>有时消息生产者希望消费者返回一个消息,JMSReplyTo为一个Destination,表示需要回复的目的地</td></tr><tr><td>JMSCorrelationID</td><td>通常用来关联多个Message</td></tr><tr><td>JMSType</td><td>表示消息体的结构,和JMS提供者有关</td></tr><tr><td>JMSRedelivered</td><td>如果这个值为true,表示消息是被重新发送了</td></tr></tbody></table><p><strong>消息属性 :</strong> 可以理解为消息的附加消息头, 属性名可以自定义; </p><pre><code class=" mermaid">graph TB属性值类型 --&gt; boolean属性值类型 --&gt; byte属性值类型 --&gt; int属性值类型 --&gt; long属性值类型 --&gt; float属性值类型 --&gt; double属性值类型 --&gt; String</code></pre><p><strong>消息体类型 :</strong> </p><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>BytesMessage</td><td>用来传递字节消息</td></tr><tr><td>MapMessage</td><td>用来传递键值对消息</td></tr><tr><td>ObjectMessage</td><td>用来传递序列化对象</td></tr><tr><td>StreamMessage</td><td>用来传递文件等</td></tr><tr><td>TextMessage</td><td>用来传递字符串</td></tr></tbody></table><h1 id="三-ActiveMQ-的特性"><a href="#三-ActiveMQ-的特性" class="headerlink" title="三 : ActiveMQ 的特性"></a>三 : ActiveMQ 的特性</h1><ol><li><p>支持多种编程语言</p></li><li><p>支持多种传输协议</p></li><li><p>有多种持久化方式</p></li></ol><h1 id="四-安装-ActiveMQ"><a href="#四-安装-ActiveMQ" class="headerlink" title="四 : 安装 ActiveMQ"></a>四 : 安装 ActiveMQ</h1><h2 id="一-环境准备"><a href="#一-环境准备" class="headerlink" title="(一) 环境准备"></a>(一) 环境准备</h2><p>CentOS 7, JDK 1.8</p><h2 id="二-下载-ActiveMQ"><a href="#二-下载-ActiveMQ" class="headerlink" title="(二) 下载 ActiveMQ"></a>(二) 下载 ActiveMQ</h2><p>下载地址 : <a href="https://activemq.apache.org/download-archives">https://activemq.apache.org/download-archives</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入/tmp</span><br>cd /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装wget</span><br>yum install -y wget<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 wget 下载存档</span><br>wget -c https://archive.apache.org/dist/activemq/5.15.8/apache-activemq-5.15.8-bin.tar.gz<br></code></pre></td></tr></table></figure><h2 id="三-安装-ActiveMQ"><a href="#三-安装-ActiveMQ" class="headerlink" title="(三) 安装 ActiveMQ"></a>(三) 安装 ActiveMQ</h2><p>提取存档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf apache-activemq-5.15.8-bin.tar.gz -C /var<br></code></pre></td></tr></table></figure><p>修改ActiveMQ的目录名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /var/apache-activemq-5.15.8/ /var/activemq/<br></code></pre></td></tr></table></figure><h2 id="四-启动-ActiveMQ"><a href="#四-启动-ActiveMQ" class="headerlink" title="(四) 启动 ActiveMQ"></a>(四) 启动 ActiveMQ</h2><p>作为后台进程启动ActiveMQ</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost bin]# ./activemq start<br>INFO: Loading &#x27;/opt/activemq//bin/env&#x27;<br>INFO: Using java &#x27;/usr/bin/java&#x27;<br>INFO: Starting - inspect logfiles specified in logging.properties and log4j.properties to get details<br>INFO: pidfile created : &#x27;/opt/activemq//data/activemq.pid&#x27; (pid &#x27;68433&#x27;)<br></code></pre></td></tr></table></figure><p>停止ActiveMQ</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost bin]# ./bin/activemq stop<br></code></pre></td></tr></table></figure><h2 id="五-ActiveMQ-服务"><a href="#五-ActiveMQ-服务" class="headerlink" title="(五) ActiveMQ 服务"></a>(五) ActiveMQ 服务</h2><p>前面使用命令运行 ActiveMQ, 但最好的方式是<strong>将 ActiveMQ 作为服务启动;</strong></p><p>使用 system 服务将可以确保 ActiveMQ 能在系统启动时自动启动</p><p><strong>创建 ActiveMQ 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.使用vim创建一个system的服务</span><br>vi /usr/lib/systemd/system/activemq.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.填入以下内容</span><br>[Unit]<br>Description=ActiveMQ service<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/var/activemq/bin/activemq start<br>ExecStop=/var/activemq/bin/activemq stop<br>User=root<br>Group=root<br>Restart=always<br>RestartSec=9<br>StandardOutput=syslog#输出到系统日志中/var/log/message<br>StandardError=syslog<br>SyslogIdentifier=activemq<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p><strong>修改配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">找到java命令的位置</span><br>[root@localhost ~]# whereis java<br>java: /usr/bin/java /usr/local/java /usr/share/man/man1/java.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.修改/var/activemq/bin/env中的JAVA_HOME为JDK的目录</span><br>JAVA_HOME=&quot;/usr/java/jdk1.8.0_221-amd64&quot;<br>JAVACMD=&quot;auto&quot;<br></code></pre></td></tr></table></figure><p><strong>ActiveMQ 服务操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动ActiveMQ服务</span><br>systemctl start activemq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看服务状态</span><br>systemctl status activemq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机启动</span><br>systemctl enable activemq<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查开机自启</span><br>systemctl list-unit-files | grep activemq<br></code></pre></td></tr></table></figure><p><strong>防火墙添加 ActiveMQ 的端口 :</strong> ActiveMQ 启动后, 外部还无法访问, 还需要在防火墙配置中增加 ActiveMQ 的 Web 管理端口和通讯端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加端口: Web管理端口默认为8161，通讯端口默认为61616</span><br>firewall-cmd --zone=public --add-port=8161/tcp --permanent<br>firewall-cmd --zone=public --add-port=61616/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙</span><br>systemctl restart firewalld.service<br></code></pre></td></tr></table></figure><h1 id="五-使用-ActiveMQ"><a href="#五-使用-ActiveMQ" class="headerlink" title="五 : 使用 ActiveMQ"></a>五 : 使用 ActiveMQ</h1><h2 id="一-使用-ActiveMQ-的-web-管理平台"><a href="#一-使用-ActiveMQ-的-web-管理平台" class="headerlink" title="(一) 使用 ActiveMQ 的 web 管理平台"></a>(一) 使用 ActiveMQ 的 web 管理平台</h2><p>ActiveMQ 自带有管理平台, 在浏览器访问</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://IP:8161/admin<br></code></pre></td></tr></table></figure><p>默认开启了身份校验</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">账号:</span> <span class="hljs-string">admin</span><br><span class="hljs-string">密码:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><p><strong>Web 管理配置 :</strong> ActiveMQ 的 Web 管理平台是基于 jetty 运行, 因此在&#x2F;var&#x2F;activemq&#x2F;conf目录可以看到jetty的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ll /var/activemq/conf<br>-rw-r--r-- 1 root root 1087 Nov 15  2018 jetty-realm.properties<br>-rw-r--r-- 1 root root 7795 Nov 15  2018 jetty.xml<br></code></pre></td></tr></table></figure><p>修改web管理平台的默认端口 : &#x2F;var&#x2F;activemq&#x2F;conf&#x2F;jetty.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;securityConstraint&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.eclipse.jetty.util.security.Constraint&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BASIC&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;roles&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;user,admin&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 改为false即可关闭登陆 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;authenticate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jettyPort&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.activemq.web.WebConsolePort&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;start&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- the default port number for the web console --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--此处即为管理平台的端口--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;port&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8161&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改账号密码 : &#x2F;var&#x2F;activemq&#x2F;conf&#x2F;jetty-realm.properties</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Defines <span class="hljs-built_in">users</span> that can access the web (console, demo, etc.)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">username: password [,rolename ...]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在此即可维护账号密码，格式(用户名:密码,角色)</span><br>admin: 888888, admin<br>user: 123, user<br></code></pre></td></tr></table></figure><h2 id="二-在-Java-中使用-ActiveMQ"><a href="#二-在-Java-中使用-ActiveMQ" class="headerlink" title="(二) 在 Java 中使用 ActiveMQ"></a>(二) 在 Java 中使用 ActiveMQ</h2><p>使用 jar 包 : 在 activemq 的根目录有 <code>activemq-all-5.15.8.jar</code> 包, 将其直接复制到工程即可</p><p>Maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.activemq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activemq-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.15.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建连接工厂</span><br>            <span class="hljs-type">ActiveMQConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveMQConnectionFactory</span>(<br>                <span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;tcp://10.0.0.11:61616&quot;</span>);<br>            <span class="hljs-comment">// 2.创建连接对象</span><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.createConnection();<br>            <span class="hljs-comment">// 启动</span><br>            connection.start();<br>            <span class="hljs-comment">// 3.创建会话</span><br>            <span class="hljs-comment">// 第一个参数表示是否支持事务,如果为true,会忽略第二个参数,并设置为SESSION_TRANSACTED</span><br>            <span class="hljs-comment">// 如果为false,第二个参数可设为AUTO_ACKNOWLEDGE,CLIENT_ACKNOWLEDGE,DUPS_OK_ACKNOWLEDGE</span><br>            <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> connection.createSession(<span class="hljs-literal">false</span>, Session.AUTO_ACKNOWLEDGE);<br>            <span class="hljs-comment">// 4.创建发送目标(queue/topic)</span><br>            <span class="hljs-type">Destination</span> <span class="hljs-variable">destination</span> <span class="hljs-operator">=</span> session.createQueue(<span class="hljs-string">&quot;queue1&quot;</span>);<br><span class="hljs-comment">//Destination destination = session.createTopic(&quot;topic1&quot;);</span><br>            <span class="hljs-comment">// 5.创建消息生产者</span><br>            <span class="hljs-type">MessageProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> session.createProducer(destination);<br>            <span class="hljs-comment">// 指定持久化策略:</span><br>            producer.setDeliveryMode(DeliveryMode.PERSISTENT);<br>            <span class="hljs-comment">// 6.创建消息</span><br>            <span class="hljs-type">TextMessage</span> <span class="hljs-variable">textMessage</span> <span class="hljs-operator">=</span> session.createTextMessage(<span class="hljs-string">&quot;hello amq&quot;</span>);<br>            <span class="hljs-comment">// 7.发送消息</span><br>            producer.send(textMessage);<br><span class="hljs-comment">// 8.关闭会话和连接</span><br>            session.close();<br>            connection.close();<br><br>        &#125; <span class="hljs-keyword">catch</span> (JMSException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.创建连接工厂</span><br>            <span class="hljs-type">ActiveMQConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveMQConnectionFactory</span>(<br>                <span class="hljs-string">&quot;tcp://10.0.0.11:61616&quot;</span>);<br>            <span class="hljs-comment">// 2.创建连接对象</span><br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.createConnection(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>            <span class="hljs-comment">// 启动</span><br>            connection.start();<br>            <span class="hljs-comment">// 3.创建会话</span><br>            <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> connection.createSession(<span class="hljs-literal">false</span>, Session.AUTO_ACKNOWLEDGE);<br>            <span class="hljs-comment">// 4.创建接收目标(queue/topic)</span><br>            <span class="hljs-type">Destination</span> <span class="hljs-variable">destination</span> <span class="hljs-operator">=</span> session.createQueue(<span class="hljs-string">&quot;queue1&quot;</span>);<br>            <span class="hljs-comment">//Destination destination = session.createTopic(&quot;topic1&quot;);</span><br>            <span class="hljs-comment">// 5.创建消息消费者</span><br>            <span class="hljs-type">MessageConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> session.createConsumer(destination);<br>            <span class="hljs-comment">// 6.接收消息</span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> consumer.receive();<br>            <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> TextMessage) System.out.println(((TextMessage) message).getText());<br><span class="hljs-comment">// 7.关闭会话和连接</span><br>            session.close();<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (JMSException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-在-Spring-中使用-ActiveMQ"><a href="#三-在-Spring-中使用-ActiveMQ" class="headerlink" title="(三) 在 Spring 中使用 ActiveMQ"></a>(三) 在 Spring 中使用 ActiveMQ</h2><p>Spring官方教程 : <a href="http://spring.io/guides/gs/messaging-jms">http://spring.io/guides/gs/messaging-jms</a></p><p>spring 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.activemq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activemq-broker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.15.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apachegeronimo.specs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>geronimo-jms_1.1_spec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>springboot 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">activemq:</span><br>    <span class="hljs-attr">broker-url:</span> <span class="hljs-string">tcp://10.0.0.11:61616</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableJms</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmqApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(AmqApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JmsTemplate jmsTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        jmsTemplate.convertAndSend(<span class="hljs-string">&quot;queue1&quot;</span>, <span class="hljs-string">&quot;hello spring&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <br>    <span class="hljs-meta">@JmsListener(destination = &quot;queue1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;收到消息: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>ActiveMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式消息中间件设计</title>
    <link href="/2020/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-消息中间件概述"><a href="#一-消息中间件概述" class="headerlink" title="一 : 消息中间件概述"></a>一 : 消息中间件概述</h2><p>单体架构</p><pre><code class=" mermaid">flowchart LRsubgraph A[XX商城系统]商品会员订单登录注册...endA --&gt; B[(数据库)]</code></pre><p>分布式系统架构 : 一个请求后台多系统协同处理</p><pre><code class=" mermaid">flowchart LRA[前端系统] --&gt; B[订单系统]B &lt;-.相互调用.-&gt; CA --&gt; C[会员系统]B --&gt; D[(数据库)]C --&gt; E((缓存)) --&gt; D</code></pre><p>基于消息中间件的分布式系统架构</p><pre><code class=" mermaid">graph LRA[前端系统] --发送注册消息--&gt; B&#123;消息中间件&#125;A[前端系统] --创建订单消息--&gt; B&#123;消息中间件&#125;A[前端系统] --发送支付消息--&gt; B&#123;消息中间件&#125;B --接收注册消息--&gt; C[会员系统]B --接收订单消息--&gt; D[订单系统]B --接收支付消息--&gt; E[支付系统]</code></pre><h3 id="一-什么是消息中间件"><a href="#一-什么是消息中间件" class="headerlink" title="(一) 什么是消息中间件"></a>(一) 什么是消息中间件</h3><p>什么是消息中间件</p><ul><li>利用高效可靠的消息传递机制进行平台无关的数据交流;</li><li>并基于数据通信来进行分布式系统的集成;</li><li>通过提供消息传递和消息排队模型, 它可以在分布式环境下扩展进程间的通信</li></ul><p>消息中间件的应用场景</p><ul><li>跨系统数据传递</li><li>高并发流量削峰</li><li>数据异步处理…等等</li></ul><p>常用的消息中间件</p><ul><li>ActiveMQ, RabbitMQ, kafka, RocketMQ</li></ul><h3 id="二-消息中间件核心设计"><a href="#二-消息中间件核心设计" class="headerlink" title="(二) 消息中间件核心设计"></a>(二) 消息中间件核心设计</h3><ul><li>本质<ul><li>一种具备接收请求, 保存数据, 发送数据等功能的网络应用</li><li>和一般网络应用程序的区别是它主要负责数据的接收和传递, 所以性能一般都高于普通程序</li></ul></li><li>5大核心组成<ul><li>协议</li><li>持久化机制</li><li>消息分发机制</li><li>高可用设计</li><li>高可靠设计</li></ul></li></ul><h2 id="二-协议"><a href="#二-协议" class="headerlink" title="二 : 协议"></a>二 : 协议</h2><h3 id="一-协议是什么"><a href="#一-协议是什么" class="headerlink" title="(一) 协议是什么"></a>(一) 协议是什么</h3><p>协议是计算机之间通信时共同遵从的一组约定, 都遵守相同的约定, 计算机之间才能相互交流; </p><p>是对数据格式和计算机之间交换数据时必须遵守的规则的正式描述</p><p><strong>协议三要素 :</strong> </p><ol><li>语法 : 即数据与控制信息的结构或格式</li><li>语义 : 即需要发出何种控制信息, 完成何种动作以及做出何种响应</li><li>时许(同步) : 即事件实现顺序的详细说明</li></ol><p><strong>举例 : Http 协议</strong> </p><ol><li>语法 : http 规定了请求报文和响应报文的具体格式</li><li>语义 : 客户端主动发起的操作称为请求</li><li>时序 : 一个请求对应一个响应</li></ol><h3 id="二-消息中间件常见协议"><a href="#二-消息中间件常见协议" class="headerlink" title="(二) 消息中间件常见协议"></a>(二) 消息中间件常见协议</h3><p><strong>OpenWire :</strong> Apache的一种跨语言的协议, 允许从不同的语言和平台访问ActiveMQ, 是ActiveMQ 4.x以后的版本默认的传输协议。</p><p><strong>AMQP :</strong> Advanced Message Queuing Protocol, 高级消息队列协议, 2004 年 JPMorgan Chase (摩根大通集团)联合其他公司共同设计</p><ul><li><strong>特性 :</strong> 事务支持, 持久化支持, 出生金融行业, 在可靠性消息处理上具备天然的优势</li><li>代表产品 : ActiveMQ, RabbitMQ</li></ul><p><strong>MQTT :</strong> Message Queuing Telemrtry Transport, 消息队列遥测传输, 是IBM开发的一个即时通讯协议, 物联网系统架构中的重要组成部分</p><ul><li><strong>特性 :</strong> 轻量, 结构简单, 传输快, 没有事务支持, 没有持久化相关设计</li><li><strong>应用场景 :</strong> 适用于计算能力有限, 低带宽, 网络不稳定的场景</li><li>代表产品 : ActiveMQ, RabbitMQ</li></ul><p><strong>Kafka :</strong> 基于 TCP 的二进制协议; 消息内部是通过长度来分割, 由一些基本数据类型组成</p><ul><li><strong>特性 :</strong> 结构简单, 解析快, 无事务设计, 有持久化设计</li></ul><p><strong>OpenMessage :</strong> 近一两年由阿里发起, 与雅虎, 滴滴出行, Streamlio 等公司共同参与创立的分布式消息中间件, 流处理领域的应用开发标准; 是<strong>国内首个</strong>在全球范围内发起的分布式消息领域国际标准</p><ul><li><strong>特性 :</strong> 结构简单, 解析快, 有事务设计, 有持久化设计</li><li>代表产品 : Apache RocketMQ</li></ul><h3 id="三-问题"><a href="#三-问题" class="headerlink" title="(三) 问题"></a>(三) 问题</h3><p><strong>为什么消息中间件不直接使用 Http 协议 ?</strong></p><ol><li>首先 http 的内容很多,请求报文和响应报文很复杂</li><li>http 大部分情况都是短连接, 不利于消息中间件的场景, 消息中间件要求客户端长期的获取信息或者是往消息中间件中发送数据</li></ol><h2 id="三-消息分发"><a href="#三-消息分发" class="headerlink" title="三 : 消息分发"></a>三 : 消息分发</h2><h3 id="一-为什么要有消息分发策略"><a href="#一-为什么要有消息分发策略" class="headerlink" title="(一) 为什么要有消息分发策略"></a>(一) 为什么要有消息分发策略</h3><p><strong>业务场景一 :</strong> 前台系统创建订单, 然后传递数据到消息中间件, 那这条消息要给后端的哪个系统呢? 因为一个消息中间件会有多个子系统进行连接, 这个时候就<strong>需要有消息分发策略, 根据什么策略将消息分发给一个正确的系统</strong>; 例如订单系统要接收订单消息, 而购物车系统和用户系统就不需要接收</p><pre><code class=" mermaid">graph LRA[前台系统] --创建订单--&gt; B&#123;消息中间件&#125; --订单消息--&gt; C[订单系统]B --订单消息--&gt; 购物车系统B --订单消息--&gt; 用户系统</code></pre><p><strong>业务场景二 :</strong> 下了订单要支付, 支付会有一个支付成功或者失败的消息, 支付失败之后, 可能由于支付系统处理发生失败, 这个时候需要有重试的机制, 我们要求<strong>不仅可以正确的分发, 还要求能够支持重发</strong></p><pre><code class=" mermaid">graph LRA[前台系统] --支付--&gt; B[消息中间件] B --支付消息--&gt; C[支付系统]C --失败--&gt; B</code></pre><h3 id="二-常用的消息中间件分发策略"><a href="#二-常用的消息中间件分发策略" class="headerlink" title="(二) 常用的消息中间件分发策略"></a>(二) 常用的消息中间件分发策略</h3><p>发布订阅, 轮询分发, 公平分发, 重发, 消息拉取</p><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>发布订阅</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>轮询分发</td><td>支持</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>公平分发</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>&#x2F;</td></tr><tr><td>重发</td><td>支持</td><td>支持</td><td>&#x2F;</td><td>支持</td></tr><tr><td>消息拉取</td><td>&#x2F;</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><h2 id="四-持久化"><a href="#四-持久化" class="headerlink" title="四 : 持久化"></a>四 : 持久化</h2><h3 id="一-持久化是什么"><a href="#一-持久化是什么" class="headerlink" title="(一) 持久化是什么"></a>(一) 持久化是什么</h3><p>简单来说就是数据存入磁盘, 而不是存在内存中随服务重启而消失, 使数据能够永久保存叫做持久化</p><pre><code class=" mermaid">graph LRA[前台系统] --发送消息--&gt; B&#123;消息中间件&#125; --消费消息--&gt; C[订单系统]B --存储消息--&gt; D((&quot;磁盘&lt;br&gt;(持久存储)&quot;))</code></pre><h3 id="二-常用持久化方式"><a href="#二-常用持久化方式" class="headerlink" title="(二) 常用持久化方式"></a>(二) 常用持久化方式</h3><p>文件系统和数据库, 举例说明</p><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>文件系统</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据库</td><td>支持</td><td>&#x2F;</td><td>&#x2F;</td><td>&#x2F;</td></tr></tbody></table><h2 id="五-高可用"><a href="#五-高可用" class="headerlink" title="五 : 高可用"></a>五 : 高可用</h2><h3 id="一-高可用机制"><a href="#一-高可用机制" class="headerlink" title="(一) 高可用机制"></a>(一) 高可用机制</h3><p><strong>高可用性</strong>是指产品在规定的条件和规定的时刻或时间区间内处于可执行规定功能状态的能力</p><p>当业务量大时, 一台消息中间件服务器可能无法满足需求, 所以需要消息中间件能够集群部署, 来达到高可用的目的</p><h3 id="二-实现方式"><a href="#二-实现方式" class="headerlink" title="(二) 实现方式"></a>(二) 实现方式</h3><p>Master-Slave 主从共享数据的部署方式</p><pre><code class=" mermaid">graph BTB1[Broker1 Master] --&gt; A[&quot;消息存储&lt;br&gt;(文件系统/数据库...)&quot;]B2[Broker2 Slave] --&gt; AB3[Broker3 Slave] --&gt; AC1[Client] --&gt; B1C2[Client] --&gt; B1</code></pre><p>Master-Slave 主从同步部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; C1subgraph C[Master-Slave]subgraph C1[broker1-master]C11[消息数据]endsubgraph C2[broker2-slave]C21[&quot;消息数据&lt;br&gt;(副本)&quot;]endsubgraph C3[broker3-slave]C31[&quot;消息数据&lt;br&gt;(副本)&quot;]endC1 -.-&gt; C2C1 -.-&gt; C3endC2 --&gt; D[消费者]</code></pre><p>Broker-Cluster 多主集群同步部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; C1subgraph C[ ]subgraph C1[broker1]C11[消息数据]endsubgraph C2[broker2]C21[&quot;消息数据&lt;br&gt;(副本)&quot;]endsubgraph C3[broker3]C31[&quot;消息数据&lt;br&gt;(副本)&quot;]endC1 -.-&gt; C2C1 -.-&gt; C3endC2 --&gt; D[消费者]C3 --&gt; E[消费者]</code></pre><p>Broker-Cluster 多主集群转发部署方式</p><pre><code class=" mermaid">flowchart LRA[生产者] --&gt; B[消息] --&gt; Csubgraph C[broker1]C1[&quot;元数据&lt;br&gt;(队列内容)&quot;]endsubgraph D[broker2]D1[&quot;元数据&lt;br&gt;(队列内容)&quot;]endC &lt;-.转发数据&lt;br&gt;转发请求.-&gt; DD --&gt; E[消费者]</code></pre><p>Master-Slave 与 Broker-Cluster 结合</p><pre><code class=" mermaid">flowchart LRA1[Master1] --- B1[Slave1] --- C1[Slave1]  --- A1A2[Master2] --- B2[Slave2] --- C2[Slave2]  --- A2A3[Master3] --- B3[Slave3] --- C3[Slave3]  --- A3D[Load Balance] --&gt; A1D --&gt; A2D --&gt; A3E[Client] --&gt; D</code></pre><h2 id="六-高可靠"><a href="#六-高可靠" class="headerlink" title="六 : 高可靠"></a>六 : 高可靠</h2><p><strong>高可靠性</strong>是指系统可以无故障持续运行; 比如一个系统从来不崩溃, 报错, 或者崩溃, 报错的几率极低, 那就是高可靠</p><p>在高并发业务场景下, 如果不能保证系统的高可靠, 那造成的损失将会非常严重</p><p>保证消息中间件的高可靠性, 可以从以下几方面考虑 : </p><ul><li><strong>消息传输可靠 :</strong> 通过协议来保证系统间数据解析的正确性</li><li><strong>消息存储可靠 :</strong> 通过持久化来保证消息的存储可靠性</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式消息中间</tag>
      
      <tag>设计原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat参数调优</title>
    <link href="/2020/09/11/Tomcat%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/"/>
    <url>/2020/09/11/Tomcat%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一-参数调优"><a href="#一-参数调优" class="headerlink" title="一 : 参数调优"></a>一 : 参数调优</h2><table><thead><tr><th>配置项</th><th>解释</th><th>默认</th><th>建议</th><th>注意</th></tr></thead><tbody><tr><td>ConnectionTimeout</td><td>连接超时时间</td><td>20s</td><td>减少</td><td></td></tr><tr><td>maxThreads</td><td>处理连接的最大线程数</td><td>200</td><td>增加</td><td>不是越大越好</td></tr><tr><td>acceptCount(backlog)</td><td>等待接受accept的请求数量限制</td><td>100</td><td>增加</td><td>socket参数, min(accept, &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn)</td></tr><tr><td>maxConnections</td><td>最大连接处理数</td><td>nio:1w&#x2F;apr:8192</td><td>不变</td><td></td></tr></tbody></table><p>maxConnections : tomcat能够处理的最大连接数</p><p>acceptCount(backlog) : 当请求数超过 <code>maxConnections</code> 将会进入操作系统的等待区域 <code>acceptCount</code>, 这个值会取 <code>accept</code> 和 <code>/proc/sys/net/core/somaxconn</code> 中的最小值</p><pre><code class=" mermaid">graph LRRequest --&gt; AcceptCount --&gt; maxConnections --&gt; maxThreadssubgraph 总可受理连接数AcceptCountmaxConnectionsend</code></pre><h3 id="一-连接数调整"><a href="#一-连接数调整" class="headerlink" title="(一) 连接数调整"></a>(一) 连接数调整</h3><p>总共连接数 &#x3D; acceptCount+ connections</p><p>connections： Tomcat能接收的请求限制；</p><p>acceptCount： 超过Tomcat能接收的请求数以后，堆积在操作系统的数量(windows 和 linux 略有不同);</p><pre><code class=" mermaid">flowchart LRA[用户请求] --linux--&gt; B[Linux 操作系统&lt;/br&gt;TCP握手过程&lt;/br&gt;SYN queue]B -.-&gt; C[OS 操作系统&lt;br/&gt;TCP 完毕&lt;br/&gt;accept queue&lt;br/&gt;&lt;b&gt;acceptCount=1&lt;/b&gt;]A --windows--&gt; CC --&gt; D[selector收到socket事件通知&lt;br/&gt;连接处理计数&lt;br/&gt;默认限制1W&lt;br/&gt;&lt;b&gt;maxConnections=1&lt;/b&gt;] D --&gt; E((请求堆积)) E --&gt; Fsubgraph F[线程数量:MaxThreads]线程-1线程-2线程-nendsubgraph 操作系统BCendsubgraph TomcatDEFend</code></pre><p><strong>什么时候需要调整connections？如何调整？</strong></p><ul><li>connections小于maxThread的时候；需要调大；最好是比预期的最高并发数要大20%；例如 MaxThreads &#x3D; 5000, 则 MaxConnections &#x3D; 6000</li><li>反正是堆积到tomcat的work处理线程池中(堆积占内存)；</li></ul><p><strong>什么时候需要调整acceptCount？</strong></p><ul><li><p>想受理更多用户请求，却又不想堆积在tomcat中，利用操作系统来高效的堆积，可以调整为最高并发数 ­ connections；</p></li><li><p>实际上不需要调整，tomcat默认100，linux默认128；最好是把连接控制交给应用程序，这样方便管理。</p></li></ul><p>启动方式： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar xxx.jar --server.tomcat.max-connections=1 --server.tomcat.max-thread=1 --server.tomcat.acceptCount=1<br></code></pre></td></tr></table></figure><h3 id="二-并发处理线程数调整"><a href="#二-并发处理线程数调整" class="headerlink" title="(二) 并发处理线程数调整"></a>(二) 并发处理线程数调整</h3><p>线程太少，CPU利用率过低，程序的吞吐量变小，资源浪费，容易堆积。</p><p>线程太多，上下文频繁切换，性能反而变低。</p><p>场景代入：服务器配置2核，不考虑内存问题。收到请求，java代码执行耗时50ms，等待数据返回50ms</p><p>那么, <strong>线程数调为多少合适？</strong></p><ul><li><p><strong>理想</strong>的线程数量&#x3D; (1 + 代码阻塞时间&#x2F;代码执行时间) * cpu数量</p></li><li><p><strong>实际情况</strong>是跑起代码，压测环境进行调试。不断调整线程数，将CPU打到80~90%的利用率。</p></li></ul><p>启动方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar web-demo-1.1.0.jar --server.tomcat.max-threads=500<br></code></pre></td></tr></table></figure><h2 id="二-整体架构"><a href="#二-整体架构" class="headerlink" title="二 : 整体架构"></a>二 : 整体架构</h2><pre><code class=" mermaid">graph LRA1[PC] --HTTPS--&gt; B2A2[Mobile] --HTTPS--&gt; B2subgraph B[Connection &amp; Load Balance]B1[Nginx]B2[Nginx]B3[Nginx]endsubgraph C[ ]    subgraph D[API GATEWAY]        D1[Nginx]        D2[Tomcat]    end    subgraph E1[WEB APP]        E11[Nginx]        E12[Tomcat]        E11 --&gt; E12    end    subgraph E2[WEB APP]        E21[Nginx]        E22[Tomcat]        E21 --&gt; E22    end    B2 --HTTP--&gt; D1    D1 --&gt; D2    D2 --HTTP--&gt; E11    D2 --RPC--&gt; E21endsubgraph F[Database]F1[Database]F2[Database]F3[Database]endE12 --&gt; F1</code></pre><p>如有需要 : 每台机器可以是nginx+tomcat，Nginx负责限流+日志记录</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat网络处理线程模型</title>
    <link href="/2020/09/04/Tomcat%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/09/04/Tomcat%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-BIO-同步-Servlet"><a href="#一-BIO-同步-Servlet" class="headerlink" title="一 : BIO + 同步 Servlet"></a>一 : BIO + 同步 Servlet</h2><p>一个请求，一个工作线程，CPU利用率低。</p><p>新版本中不再使用</p><pre><code class=" mermaid">graph LRA[User Request] --&gt; B[Nginx] --&gt; C[BIO Connector] --&gt; D[Servlet]D[Servlet] --&gt; E1[Remote Service]D[Servlet] --RPC--&gt; E2[Remote Service]D[Servlet] --HTTP--&gt; E3[Remote Service]subgraph NginxB[Nginx]endsubgraph TomcatC[BIO Connector]D[Servlet]endsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="二-APR-异步-Servlet"><a href="#二-APR-异步-Servlet" class="headerlink" title="二 : APR + 异步 Servlet"></a>二 : APR + 异步 Servlet</h2><p>APR(Apache Portable Runtime&#x2F;Apache可移植运行库)，是Apache HTTP服务器的支持库</p><p>JNI(Java Native Interface)的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作</p><p>Tomcat默认监听指定路径，如果有APR安装，则自动启用</p><pre><code class=" mermaid">graph LRA[User Request] --HTTP/1.1--&gt; B[Nginx] --&gt; C[APR Connector] --&gt; D[Async Servlet]D[Async Servlet] --&gt; E1[Remote Service]D[Async Servlet] --Async RPC--&gt; E2[Remote Service]D[Async Servlet] --Async HTTP--&gt; E3[Remote Service]subgraph NginxBendsubgraph TomcatCDendsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="三-NIO-异步-Servlet"><a href="#三-NIO-异步-Servlet" class="headerlink" title="三 : NIO + 异步 Servlet"></a>三 : NIO + 异步 Servlet</h2><p>Tomcat8开始，默认NIO方式</p><p>非阻塞读取请求信息，非阻塞处理下一个请求，完全异步</p><pre><code class=" mermaid">graph LRA[User Request] --HTTP/1.1--&gt; B[Nginx] --&gt; C[NIO Connector] --&gt; D[Async Servlet]D[Async Servlet] --Async RPC--&gt; E1[Remote Service]D[Async Servlet] --Async HTTP--&gt; E2[Remote Service]D[Async Servlet] --&gt; E3[Remote Service]subgraph NginxBendsubgraph TomcatCDendsubgraph RemoteE1E2E3endsubgraph API GatewayNginxTomcatend</code></pre><h2 id="四-NIO-处理流程"><a href="#四-NIO-处理流程" class="headerlink" title="四 : NIO 处理流程"></a>四 : NIO 处理流程</h2><pre><code class=" mermaid">graph TDA[User Request] --1--&gt; B[Acceptor]B --3--&gt; C1[PollerEvent]B --3--&gt; C2[PollerEvent]C1 --4--&gt; D1[Poller1 selector1]C2 --4--&gt; D2[Poller2 selector2]D1 --5--&gt; E1D2 --5--&gt; E1E1 --&gt; F1[nioChannel1]subgraph C[PollerEvent]C1[PollerEvent]C2[PollerEvent]endsubgraph D[Poller selector]D1[Poller1 selector1]D2[Poller2 selector2]endsubgraph E[SocketProcessor]E1[SocketProcessor1]E2[SocketProcessor2]E3[SocketProcessor3]endsubgraph F[nioChannel]F1F2[nioChannel2]F3[nioChannel3]endF1 --2--&gt; B</code></pre><ol><li>接受器接受套接字</li><li>接受器从缓存中检索niochannel对象</li><li>Pollerthread将nioChannel注册到它的选择器I0事件</li><li>轮询器将nioChannel分配给一个work线程来处理请求</li><li>SocketProcessor完成对请求的处理和返回</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/2020/08/28/JVM%E8%B0%83%E4%BC%98/"/>
    <url>/2020/08/28/JVM%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-调优基本概念"><a href="#一-调优基本概念" class="headerlink" title="一 : 调优基本概念"></a>一 : 调优基本概念</h2><p>在调整性能时, JVM有三个组件 :</p><ol><li>堆大小调整</li><li>垃圾收集器调整</li><li>JIT编译器</li></ol><p>通常, 在调优 Java 应用程序时, 重点是以下两个主要目标之一 :</p><ul><li><strong>响应性 :</strong> 应用程序或系统对请求的数据进行响应的速度, 对于专注于响应性的应用程序, 长的暂停时间是不可接受的, 重点是在短时间内做出回应</li><li><strong>吞吐量 :</strong> 侧重于在特定时间段内最大化应用程序的工作量, 对于专注于吞吐量的应用程序, 高暂停时间是可接受的。由于高吞吐量应用程序在较长时间内专注于基准测试, 因此不需要考虑快速响应时间</li></ul><p><strong>系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化。</strong></p><p><strong>JDK版本不断更新, JVM参数和具体说明, 建议需要时参考oracle官网的手册。</strong></p><p>官方调优指南 : <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></p><h2 id="二-常用-JVM-参数"><a href="#二-常用-JVM-参数" class="headerlink" title="二 : 常用 JVM 参数"></a>二 : 常用 JVM 参数</h2><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:+AlwaysPreTouch</td><td>jvm启动时分配内存, 非使用时再分配</td></tr><tr><td>-XX: ErrorFile &#x3D; filename</td><td>崩溃日志</td></tr><tr><td>-XX:+TraceClassLoading</td><td>跟踪类加载信息</td></tr><tr><td>-XX:+PrintClassHistogram</td><td>按下Ctrl+Break后, 打印类的信息</td></tr><tr><td>-Xmx -Xms</td><td>最大堆和最小堆</td></tr><tr><td>-xx:permSize、-xx:metaspaceSize</td><td>永久代&#x2F;元数据空间</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>OOM时导出堆到文件</td></tr><tr><td>-XX:+HeapDumpPath</td><td>OOM时堆导出的路径</td></tr><tr><td>-XX:OnOutOfMemoryError</td><td>在OOM时, 执行一个脚本</td></tr><tr><td>iava -XX:+PrintFlagsFinal -version</td><td>打印所有的-XX参数和默认值</td></tr></tbody></table><h2 id="三-GC-调优思路"><a href="#三-GC-调优思路" class="headerlink" title="三 : GC 调优思路"></a>三 : GC 调优思路</h2><table><thead><tr><th>步骤</th><th>目标</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>分析场景</td><td>启动速度慢; 偶尔出现响应慢于平均水平或者出现卡顿</td></tr><tr><td>2</td><td>确定目标</td><td>内存占用、低延时、吞吐量</td></tr><tr><td>3</td><td>收集日志</td><td>通过参数配置收集GC日志;通过JDK工具查看GC状态</td></tr><tr><td>4</td><td>分析日志</td><td>使用工具辅助分析日志, 查看GC次数, GC时间</td></tr><tr><td>5</td><td>调整参数</td><td>切换垃圾收集器或者调整垃圾收集器参数</td></tr></tbody></table><h2 id="四-通用-GC-参数"><a href="#四-通用-GC-参数" class="headerlink" title="四 : 通用 GC 参数"></a>四 : 通用 GC 参数</h2><p>GC线程数量</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:ParallelGCThreads</td><td>并行GC线程数量</td></tr><tr><td>-XX:ConcGCThreads</td><td>并发GC线程数量</td></tr></tbody></table><p>GC时间 : 意义不大, JVM只能尽量满足</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:MaxGCPauseMillis</td><td>最大停顿时间, 单位毫秒; GC尽力保证回收时间不超过设定值</td></tr><tr><td>-XX:GCTimeRatio</td><td>0-100的取值范围; 垃圾收集时间占总时间的比; 默认99, 即最大允许1%时间做GC</td></tr></tbody></table><p>内存占比 : 用默认值就好</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:SurvivorRatio</td><td>新生代Eden和Survivor大小的比例; 默认8, 表示2个Survivor:Eden&#x3D;2:8, 即1个Survivor占新生代的1&#x2F;10</td></tr><tr><td>-XX:NewRatio</td><td>新生代和老年代的比例; 默认4, 表示新生代:老年代&#x3D;1:4, 即年轻代占堆的1&#x2F;5</td></tr></tbody></table><p>GC信息</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-verbose:gc、-XX:+printGC</td><td>打印GC的简要信息</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC详细信息, <strong>jdk9已经舍弃</strong></td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>打印CG发生的时间戳, <strong>jdk9已经舍弃</strong></td></tr><tr><td><strong>-Xloggc:log&#x2F;gc.log</strong></td><td>指定Gc日志的位置, 以文件输出</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>每次一次GC后, 都打印堆信息</td></tr></tbody></table><h2 id="五-垃圾收集器-Parallel-参数"><a href="#五-垃圾收集器-Parallel-参数" class="headerlink" title="五 : 垃圾收集器 Parallel 参数"></a>五 : 垃圾收集器 Parallel 参数</h2><p>Parallel 是 JDK1.8 的默认收集器, 适用于<strong>吞吐量优先</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>新生代使用并行回收收集器</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>老年代使用并行回收收集器</td></tr><tr><td><strong>-XX:ParallelGCThreads</strong></td><td>设置用于垃圾回收的线程数</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>打开自适应GC策略,<strong>默认开启</strong></td></tr></tbody></table><h2 id="六-垃圾收集器-CMS-参数调优"><a href="#六-垃圾收集器-CMS-参数调优" class="headerlink" title="六 : 垃圾收集器 CMS 参数调优"></a>六 : 垃圾收集器 CMS 参数调优</h2><p><strong>响应时间优先;</strong> ParallelGC 无法满足应用程序延迟要求时再考虑使用 CMS 垃圾收集器; 新版建议用 G1 垃圾收集器</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>新生代使用并行收集器;老年代使用CMS+串行收集器</td></tr><tr><td>-XX:+UseParNewGC</td><td>在新生代使用并行收集器;CMS下默认开启</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction</td><td>设置触发GC的阈值,默认68%;如果内存预留空间不够,就会引起concurrentmode failure</td></tr><tr><td>-XX:+ UseCMSCompactAtFullCollection</td><td>Full GC后,进行一次整理,整理过程是独占的,会引起停顿时间变长</td></tr><tr><td>-XX:+CMSFullGCsBeforeCompaction</td><td>设置进行几次Full GC后,进行一次碎片整理</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td>允许对类元数据进行回收</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>表示只在到达阀值的时候,才进行CMS回收</td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>使用增量模式,比较适合单 CPU,<strong>不再维护</strong></td></tr></tbody></table><h2 id="七-垃圾收集器-G1-参数调优"><a href="#七-垃圾收集器-G1-参数调优" class="headerlink" title="七 : 垃圾收集器 G1 参数调优"></a>七 : 垃圾收集器 G1 参数调优</h2><p><strong>兼顾吞吐量和响应时间;</strong> 超过50%的Java堆被实时数据占用; 建议大堆(大小约为6GB更大)</p><p>GC延迟要求有限的应用(稳定且可预测的暂停时间低于0.5秒)。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:G1HeapRegionSize&#x3D;&lt;N,例如 16&gt;M</td><td>设置region大小,默认heap&#x2F;2000</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent</td><td>老年代依靠Mixed GC, 触发闻值</td></tr><tr><td>-XX:G1OldCSetRegionThresholdPercent</td><td>定多被包含在一次Mixed GC中的region比例</td></tr><tr><td>-XX:+ClassUnloadingWithConcurrentMark</td><td>G1增加并默认开启,在并发标记阶段结束后,JVM即进行类型卸载</td></tr><tr><td>-XX:GINewSizePercent</td><td>新生代的最小比例</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代的最大比例</td></tr><tr><td>-XX:G1MixedGCCountTarget</td><td>Mixed GC 数量控制</td></tr></tbody></table><h2 id="八-运行时-JIT-编译器优化参数"><a href="#八-运行时-JIT-编译器优化参数" class="headerlink" title="八 : 运行时 JIT 编译器优化参数"></a>八 : 运行时 JIT 编译器优化参数</h2><p>JIT编译指的是字节码编译为本地代码(汇编)执行, 只有热点代码才会编译为本地代码。</p><p>解释器执行节约内存, 反之可以使用编译执行来提升效率</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+AggressiveOpts</td><td>允许ivm使用积极的性能优化功能</td></tr><tr><td>-XX:-TieredCompilation</td><td>分层编译idk8默认开启, idk7默认关闭client</td></tr><tr><td>-Xmaxjitcodesize、-XX:ReservedCodeCacheSize</td><td>指定JIT编译代码的最大代码高速缓存最大值</td></tr><tr><td>-Xmixed</td><td>除了热方法之外, 解释器执行所有字节码, 热方法被编译为本机代码</td></tr><tr><td>-XX:lnitialCodeCacheSize</td><td>初始化编译后的汇编指令, 缓存区大小, 字节</td></tr><tr><td>-XX:+PrintCompilation</td><td>打开编译日志istat -compiler pid</td></tr><tr><td>-XX:CICompilerCount</td><td>JIT编译所使用的线程数量</td></tr><tr><td>-XX:+DoEscapeAnalysis</td><td>逃逸分析, 默认打开。对代码的深度优化</td></tr><tr><td>-XX:-Inline</td><td>方法内联, 默认打开。</td></tr></tbody></table><p><strong>很少需要对较新版本的JVM进行JIT调优</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>性能调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="/2020/08/21/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/08/21/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="一-javap-反编译"><a href="#一-javap-反编译" class="headerlink" title="一 : javap(反编译)"></a>一 : javap(反编译)</h2><p>java 反编译工具, 主要用于根据 java 字节码文件汇编为 java 源代码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# javap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出附加信息到文件</span><br>[root@localhost ~]# javap -v HelloWorld.class &gt; HelloWorld.txt<br></code></pre></td></tr></table></figure><blockquote><p>官方文档 : <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/">https://docs.oracle.com/javase/8/docs/technotes/tools/</a></p></blockquote><h2 id="二-jps-进程状态"><a href="#二-jps-进程状态" class="headerlink" title="二 : jps(进程状态)"></a>二 : jps(进程状态)</h2><p>jps : java virtual machine process status tool, 显示当前所有 java 进程 pid 的命令 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行的java进程</span><br>[root@localhost ~]# jps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jps -help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前运行的java进程及jar包</span><br>[root@localhost ~]# jps -l<br></code></pre></td></tr></table></figure><h2 id="三-jstat-统计"><a href="#三-jstat-统计" class="headerlink" title="三 : jstat(统计)"></a>三 : jstat(统计)</h2><p>jstat : Monitors Java Virtual Machine (JVM) statistics, 监视 java 虚拟机 (JVM) <strong>统计信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jstat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数</span><br>[root@localhost ~]# jstat -options<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看gc信息</span><br>[root@localhost ~]# jstat -gc 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">每10行输出一次表头,每秒更新一次</span><br>[root@localhost ~]# jstat -gc -h10 34977 1000<br></code></pre></td></tr></table></figure><h2 id="四-jcmd-命令"><a href="#四-jcmd-命令" class="headerlink" title="四 : jcmd(命令)"></a>四 : jcmd(命令)</h2><p>jcmd : Sends diagnostic command requests to a running Java Virtual Machine (JVM), 发送<strong>诊断指令</strong>请求到运行的 JVM </p><p>可以替代 jps 工具查看本地的 jvm 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">当前运行的java进程及jar包</span><br>[root@localhost ~]# jcmd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jcmd -h<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出具体指令</span><br>[root@localhost ~]# jcmd 34977 help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看堆内存信息</span><br>[root@localhost ~]# jcmd 34977 GC.heap_info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看gc</span><br>[root@localhost ~]# jcmd 34977 VM.flags<br></code></pre></td></tr></table></figure><h2 id="五-jinfo-配置信息"><a href="#五-jinfo-配置信息" class="headerlink" title="五 : jinfo(配置信息)"></a>五 : jinfo(配置信息)</h2><p>jinfo : Generates configuration information, 生成<strong>配置信息</strong></p><p>可以查看运行中 jvm 的全部参数, 还可以设置部分参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jinfo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定进程的参数</span><br>[root@localhost ~]# jinfo 34977<br></code></pre></td></tr></table></figure><h2 id="六-jmap-映射信息"><a href="#六-jmap-映射信息" class="headerlink" title="六 : jmap(映射信息)"></a>六 : jmap(映射信息)</h2><p>Prints shared object memory maps or heap memory details for a process, core file, or remote debug server</p><p>打印出 java 进程内存中 Object 的情况; 或者将 VM 中的堆, 以二级制输出成文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jmap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看堆内存</span><br>[root@localhost ~]# jmap -heap 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">内存快照: 以文件形式保存下来</span><br>[root@localhost ~]# jmap -dump:live,format=b,file=heap.bin 34977<br></code></pre></td></tr></table></figure><h2 id="七-jhat-堆内存"><a href="#七-jhat-堆内存" class="headerlink" title="七 : jhat(堆内存)"></a>七 : jhat(堆内存)</h2><p>jhat(java head analyse tool) : Analyzes the Java heap, 分析 java 堆的命令, 可以将堆中的对象以 html 的形式显示出来, 支持对象查询语言 OQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>[root@localhost ~]# jhat -help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载内存快照,以9001提供web服务</span><br>[root@localhost ~]# jhat -port 9001 heap.bin<br></code></pre></td></tr></table></figure><p>这里需要注意的有 : </p><ul><li>Show all members of the rootset</li><li>Show heap histogram</li><li>Execute Object Query Language (OQL) query</li></ul><h2 id="八-jstack-栈内存"><a href="#八-jstack-栈内存" class="headerlink" title="八 : jstack(栈内存)"></a>八 : jstack(栈内存)</h2><p><strong>堆栈跟踪工具</strong>; jstack 用于打印出给定的 java 进程 ID 或 core file 或远程调试服务的 java 堆栈信息, 如果是在 64 位机器上, 需要指定选项 “-J-d64”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看帮助命令</span><br>[root@localhost ~]# jstack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定进程的栈,-F为强制</span><br>[root@localhost ~]# jstack -F 34977<br><span class="hljs-meta prompt_"># </span><span class="language-bash">内容太多,文件保存</span><br>[root@localhost ~]# jstack -F 34977 &gt; jstack.log<br></code></pre></td></tr></table></figure><h2 id="九-Jconsole"><a href="#九-Jconsole" class="headerlink" title="九 : Jconsole"></a>九 : Jconsole</h2><p>java 监控和管理控制台</p><p>在测试和性能调试的时候可以用到</p><p><img src="/../java/image-2020082101.png"> </p><h2 id="十-JvisualVM"><a href="#十-JvisualVM" class="headerlink" title="十 : JvisualVM"></a>十 : JvisualVM</h2><p>虚拟机工具, 可以看 GC, 内存, 堆栈</p><p>功能很全面啊</p><p><img src="/../java/image-2020082102.png"> </p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2020/08/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/14/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一-自动垃圾收集"><a href="#一-自动垃圾收集" class="headerlink" title="一 : 自动垃圾收集"></a>一 : 自动垃圾收集</h2><p>自动垃圾收集是查看堆内存, 识别哪些对象<strong>正在使用</strong>以及哪些对象<strong>未被删除</strong>以及<strong>删除</strong>未使用对象的过程</p><p>使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针; 程序的任何部分都不再引用未使用的对象或未引用的对象, 因此可以回收未引用对象使用的内存</p><p>例如 : 像 C 这样的编程语言中, 分配和释放内存是一个<strong>手动过程</strong>; 在 java 中, 解除分配内存的过程由<strong>垃圾收集器</strong>自动处理</p><h2 id="二-如何确定内存需要被回收"><a href="#二-如何确定内存需要被回收" class="headerlink" title="二 : 如何确定内存需要被回收"></a>二 : 如何确定内存需要被回收</h2><p>该过程的第一步称为<strong>标记</strong>; 这是垃圾收集器识别哪些内存正在使用而哪些不在使用的地方</p><p><img src="/../java/image-2020081401.png" alt="内存标记"> </p><p><strong>不同类型内存的判断方法</strong></p><ul><li>对象回收 : <u>引用计数</u>, 简单来说就是引用一次就加1, 用完之后就减1, java中很少用, 会造成循环引用的问题</li><li>对象回收 : <strong>可达性算法</strong></li><li>方法区回收</li></ul><h2 id="三-可达性分析算法"><a href="#三-可达性分析算法" class="headerlink" title="三 : 可达性分析算法"></a>三 : 可达性分析算法</h2><p>简单来说, 将对象及其引用关系看作一个图, 选定<strong>活动的对象</strong>作为 GC Roots, 然后跟踪引用链条, 如果一个对象和 GC Roots 之间不可达, 也就是不存在引用, 那么即可认为是可回收对象</p><p><img src="/../java/image-2020081402.png" alt="可达性分析算法"> </p><p><strong>可以作为 GC Root 的对象 :</strong></p><ol><li>虚拟机栈中正在引用的对象</li><li>本地方法栈中正在引用的对象</li><li>静态属性引用的对象</li><li>方法区常量引用的对象</li></ol><h2 id="四-引用类型和可达性级别"><a href="#四-引用类型和可达性级别" class="headerlink" title="四 : 引用类型和可达性级别"></a>四 : 引用类型和可达性级别</h2><p><strong>引用类型</strong></p><ol><li>强引用(StrongReference) : 最常见的普通对象(new Object())引用, 只要还有强引用指向一个对象, 就不会回收</li><li>软引用(SoftReference) : JVM 认为内存不足时, 才会去试图回收软引用指向的对象(缓存场景)</li><li>弱引用(WeakReference) : 虽然是引用, 但随时可能被回收掉</li><li>虚引用(Phantom) : 不能通过它访问对象, 关联对象被 finalized 以后, 执行指定逻辑的机制(Cleaner)</li></ol><p><strong>可达性级别</strong></p><ol><li>强可达(Strongly Reachable) : 一个对象可以有一个或多个线程可以不通过各种引用访问到的情况</li><li>软可达(Softly Reachable) : 就是当我们只能通过软引用才能访问到对象的状态</li><li>弱可达(Weakly Reachable) : 只能通过弱引用访问时的状态; 当弱引用被清除的时候, 就符合销毁条件</li><li>幻象可达(Phantom Reachable) : 不存在其他引用, 并且 finalize 过了, 只有幻象引用指向这个对象</li><li>不可达(unreachable) : 意味着对象可以被清楚了</li></ol><h2 id="五-垃圾收集算法"><a href="#五-垃圾收集算法" class="headerlink" title="五 : 垃圾收集算法"></a>五 : 垃圾收集算法</h2><p><strong>标记-清除 (Mark-Sweep) 算法</strong> : </p><ul><li>首先标识出所有要回收的对象, 然后进行清除; </li><li>标记清除过程效率有限, 有内存碎片化问题, 不适合特别大的堆; </li><li>收集算法基本基于<strong>标记-清除</strong>的思路进行改进</li></ul><p><strong>复制 (Copying) 算法 :</strong> </p><ul><li>划分两块同等大小的区域, 收集时将活着的对象复制到另一块区域; 原区域清空</li><li>拷贝过程中将对象顺序放置, 就可以避免内存碎片化; </li><li>复制 + 预留内存, 有一定的浪费</li></ul><p><strong>标记整理(Mark-Compact) :</strong> </p><ul><li>类似于<strong>标记-清除</strong>, 但为避免<u>内存碎片化</u>, 它会在清理过程中将<strong>对象移动</strong>, 以确保移动后的对象占用连续的内存空间</li><li>避免内存碎片化</li></ul><h2 id="六-分代收集"><a href="#六-分代收集" class="headerlink" title="六 : 分代收集"></a>六 : 分代收集</h2><p>根据对象的存活周期, 将内存划分为几个区域(Eden, form, to, Tenured), 不同区域菜哦也能够合适的垃圾收集算法</p><p>新对象会分配到 Eden, 如果超过<code>-XX:+PrentenureSizeThreshold:</code> 设置大对象直接进入老年代(Tenured)的阈值</p><p>新生代采用<strong>复制算法</strong> : Eden 中的对象经过一次 GC 后, 如果未回收则 Copy 进入 form; 第二次 GC 后, 将 Eden 和 form 中的对象统一 Copy 到 to; 第三次 GC 后, 将 Eden 和 to 中的对象 Copy 到 form 中; GC 一定次数未回收对象移动到老年代 <code>(-XX:MaxTenuringThreshold)</code></p><p><img src="/../java/image-2020081403.png" alt="新生代:复制算法"> </p><p>老年代采用<strong>标记整理</strong> : 标记 &#x3D;&gt; 清除 &#x3D;&gt; 整理</p><p><img src="/../java/image-2020081404.png" alt="老年代:标记整理"> </p><h2 id="七-垃圾收集器"><a href="#七-垃圾收集器" class="headerlink" title="七 : 垃圾收集器"></a>七 : 垃圾收集器</h2><h3 id="一-串行收集器"><a href="#一-串行收集器" class="headerlink" title="(一) 串行收集器"></a>(一) 串行收集器</h3><p><strong>Serial GC :</strong> <code>-XX:+UseSerialGC</code></p><ul><li>单个线程来执行所有垃圾收集工作, 适合单处理器设备</li><li><strong>Client 模式下 JVM 的默认选项</strong></li></ul><p><strong>Serial Old GC :</strong> <code>-XX:+UseSerialOldGC</code></p><ul><li>可以在老年代使用, 它采用了标记整理(Mark-Compact)算法, 区别于新生代的复制算法</li></ul><p><img src="/../java/image-2020081405.png" alt="串行收集器"></p><h3 id="二-并行收集器"><a href="#二-并行收集器" class="headerlink" title="(二) 并行收集器"></a>(二) 并行收集器</h3><p><strong>Parallel GC :</strong> <code>-XX:+UseParallelGC</code></p><p><strong>Parallel Old GC :</strong> <code>-XX:+UseParallelOldGC</code></p><p><u>server 模式 JVM 的默认 GC 选项</u>, 整体算法和 Serial 比较相似, 区别是新生代和老年代 GC 都是并行进行; 可以设置 GC 时间或吞吐量等值, 可以自动进行适应性调整 Eden, Survivor 大小和 MaxTenuringThreshold 的值</p><p>也称为吞吐量优先的 GC : 吞吐量 &#x3D; 用户代码运行时间&#x2F;(用户代码运行时间 + GC 停顿时间)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:ParallelGCThreads : 设置用于垃圾回收的线程数;通常情况下可以和CPU数量相等<br>-XX:MaxGCPauseMills : 设置最大垃圾收集停顿时间;它的值是一个大于0的整数;只能尽量满足这个值<br>-XX:GCTimeRatio : 设置吞吐量大小,它的值是一个0~100之间的整数<br>-XX:+UseAdaptiveSizePolicy : 打开自适应GC策略;以达到在堆大小,吞吐量和停顿时间之间的平衡点;默认开启<br></code></pre></td></tr></table></figure><h3 id="三-并发收集器"><a href="#三-并发收集器" class="headerlink" title="(三) 并发收集器"></a>(三) 并发收集器</h3><p><strong>CMS (Concurrent Mark Sweep) GC :</strong> <code>-XX:+UseConcMarkSweepGC</code></p><ul><li>专用<strong>老年代</strong>, 基于标记清除(Mark-Sweep)算法, 设计目标是尽量减少停顿时间</li><li>采用的标记清除算法, 存在着内存碎片化问题, 长时间运行等情况下发生 full GC, 导致恶劣的停顿</li><li>CMS 会占用更多的 CPU 资源, 并和用户线程争抢</li><li>减少了停顿时间, 这一点对于互联网 web 等对时间敏感的系统非常重要, 一直到今天, 仍然有很多系统使用 CMS GC</li></ul><p><img src="/../java/image-2020081406.png"> </p><h3 id="四-其他"><a href="#四-其他" class="headerlink" title="(四) 其他"></a>(四) 其他</h3><p><strong>ParNew GC :</strong> <code>-XX:+UseParNewGC</code></p><ul><li>并行收集器</li><li><strong>新生代</strong> GC 实现, 它实际是 Serial GC 的多线程版本</li><li>可以控制线程数量, 参数 : <code>-XX:ParallelGCThreads</code></li><li>最常见的<strong>应用场景</strong>是配合老年代的 CMS GC 工作; 参数 : <code>-XX:=UseConcMarkSweepGC</code></li></ul><p><img src="/../java/image-2020081407.png"> </p><p><strong>G1 GC :</strong> <code>-XX:+UseG1GC</code></p><ul><li>并发收集器</li><li>针对大堆内存设计的收集器, 兼顾吞吐量和停顿时间, JDK9 后默认选型, 目标是替代 CMS;</li><li>G1 将堆分成固定大小的区域, Region 之间是复制算法, 但整体上实际可看作是标记整理(Mark-Compact)算法, 可以有效地避免内存碎片;</li></ul><ul><li>红色新生代(Eden和Surivor)，淡蓝色老年代。找不到大内存时执行FullGC</li></ul><p><img src="/../java/image-2020081408.png"></p><h2 id="八-垃圾收集器组合"><a href="#八-垃圾收集器组合" class="headerlink" title="八 : 垃圾收集器组合"></a>八 : 垃圾收集器组合</h2><p><img src="/../java/image-2020081409.png"> </p><p>常用选择</p><ol><li>默认选择: Parallel Scavenge + Parallel Old</li><li>常用选择: ParNew + CMS</li><li>激进选择: G1</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2020/08/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一-类生命周期"><a href="#一-类生命周期" class="headerlink" title="一 : 类生命周期"></a>一 : 类生命周期</h2><pre><code class=" mermaid">graph LR加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化 --&gt; 使用 --&gt; 卸载</code></pre><p>重点关注: 从加载到初始化的过程</p><ol><li>加载 : 读取二进制内容</li><li>验证 : 验证class文件格式规范,语义分析,引用验证,字节码验证</li><li>准备 : 分配内存,设置类static修饰的变量初始值</li><li>解析 : 类,接口,字段,类方法等解析</li><li>初始化 : 为静态变量赋值,执行静态代码块</li><li>使用 : 创建实例对象</li><li>卸载 : 从JVM方法区中卸载</li></ol><h2 id="二-类加载器"><a href="#二-类加载器" class="headerlink" title="二 : 类加载器"></a>二 : 类加载器</h2><p><strong>类加载器负责装入类</strong>, 搜索网络, jar, zip, 文件夹, 二进制数据, 内存等指定位置的资源</p><p>一个 java 程序运行, 最少有三个类加载器实例, 负责不同类的加载</p><table><thead><tr><th>序号</th><th>加载器</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Bootstrap Loader</td><td>核心类库加载器</td><td>C&#x2F;C++ 实现, 无对应 java 类(null); 加载 <code>JRE_HOME/jre/lib</code> 目录, 或者用户配置的目录; JDK 核心类库 rt.jar…String…</td></tr><tr><td>2</td><td>Extension Class Loader</td><td>扩展类库加载器</td><td>ExtClassLoader 的实例; 加载 <code>JRE_HOME/jre/lib/ext</code> 目录, JDK 扩展包, 或者用户配置的目录</td></tr><tr><td>3</td><td>Application Class Loader</td><td>用户应用程序加载器</td><td>AppClassLoader 的实例; 加载 <code>java.class.path</code> 指定的目录, 用户应用程序 class-path 或者 java 命令运行时参数 -cp …</td></tr></tbody></table><h2 id="三-验证问题"><a href="#三-验证问题" class="headerlink" title="三 : 验证问题"></a>三 : 验证问题</h2><h3 id="一-查看类对应的加载器"><a href="#一-查看类对应的加载器" class="headerlink" title="(一) 查看类对应的加载器"></a>(一) 查看类对应的加载器</h3><p>通过 JDK-API 进行查看: java.lang.Class.getClassLoader, 返回装载类的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查看类的加载器实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderView</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 加载核心类库的 BootStrap ClassLoader</span><br>        System.out.println(<span class="hljs-string">&quot;核心类库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader()<br>                           .loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader());<br>        <span class="hljs-comment">// 加载拓展库的 Extension ClassLoader</span><br>        System.out.println(<span class="hljs-string">&quot;拓展类库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader()<br>                           .loadClass(<span class="hljs-string">&quot;com.sun.nio.zipfs.ZipCoder&quot;</span>).getClassLoader());<br>        <span class="hljs-comment">// 加载应用程序的</span><br>        System.out.println(<span class="hljs-string">&quot;应用程序库加载器：&quot;</span> + ClassLoaderView.class.getClassLoader());<br><br>        <span class="hljs-comment">// 双亲委派模型 Parents Delegation Model</span><br>        System.out.println(<span class="hljs-string">&quot;应用程序库加载器的父类：&quot;</span> + ClassLoaderView.class.getClassLoader().getParent());<br>        System.out.println(<br>            <span class="hljs-string">&quot;应用程序库加载器的父类的父类：&quot;</span> + ClassLoaderView.class.getClassLoader().getParent().getParent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个类是由 bootstrapClassLoader 加载的, 那么这个方法在这种实现中返回 null</p><h3 id="二-jvm-如何知道我们的类在何方"><a href="#二-jvm-如何知道我们的类在何方" class="headerlink" title="(二) jvm 如何知道我们的类在何方"></a>(二) jvm 如何知道我们的类在何方</h3><p>class 信息存放在不同的位置, 桌面 jar, 项目 bin 目录, target 目录等等</p><p>查看 openjdk 源代码 : sum.misc.Launcher.AppClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br></code></pre></td></tr></table></figure><p>结论 : 读取 java.class.path 配置, 指定去哪些地址加载类资源</p><p>验证过程 : 以 <code>hello world</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>System.in.read();<span class="hljs-comment">//阻塞进程,没有其他意义</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 java 进程 : jps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.jps 查看本机 java 进程</span><br>[root@localhost ~]# jps<br>2467 HelloWorld<br>2477 Jps<br></code></pre></td></tr></table></figure><p>查看运行时配置 : jcmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2.查看运行时配置: jcmd 进程号 VM.system_properties</span><br>[root@localhost ~]# jcmd<br>2467 HelloWorld<br>2487 sun.tools.jcmd.JCmd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看命令格式</span><br>[root@localhost ~]# jcmd -h<br>Usage: jcmd &lt;pid | main class&gt; &lt;command ...|PerfCounter.print|-f file&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看对应进程可选的<span class="hljs-built_in">command</span></span><br>[root@localhost ~]# jcmd 2467 help<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统配置</span><br>[root@localhost ~]# jcmd 2467 VM.system_properties<br></code></pre></td></tr></table></figure><h3 id="三-类不会重复加载"><a href="#三-类不会重复加载" class="headerlink" title="(三) 类不会重复加载"></a>(三) 类不会重复加载</h3><p>类的唯一性: 同一个类加载器, 类名一样, 代表是同一个类</p><p><strong>识别方式 :</strong> ClassLoader Instance Id + PackaeName + ClassName</p><p><strong>验证方式 :</strong> 使用类加载器, 对同一个 class 类的不同版本, 进行多次加载, 检查是否会加载到最新的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-comment">// 创建一个新的类加载器</span><br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-comment">// 加载class</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br>            <span class="hljs-comment">// 创建对象(反射)</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>); <br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论 :</strong> 程序运行中修改 HelloService 中代码, 经重新编译后, 输出内容无变化, 说明 <code>.class</code> 文件不会被重复加载</p><h3 id="四-类的卸载"><a href="#四-类的卸载" class="headerlink" title="(四) 类的卸载"></a>(四) 类的卸载</h3><p>类什么时候会被卸载? 满足如下两个条件 : </p><ol><li>该 Class 所有的实例都已经被 GC</li><li>加载该类的 ClassLoader 实例已经被 GC</li></ol><p><strong>验证方式 :</strong> jvm 启动中增加 -<code>verbose:class</code> 参数, 输出类加载和卸载的日志信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            <br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>);<br>            System.out.println();<br><br>            <span class="hljs-comment">// help gc  -verbose:class</span><br>            newInstance = <span class="hljs-literal">null</span>;<br>            loader = <span class="hljs-literal">null</span>;<br>        &#125;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-双亲委派模型"><a href="#五-双亲委派模型" class="headerlink" title="(五) 双亲委派模型"></a>(五) 双亲委派模型</h3><pre><code class=" mermaid">graph TDbootstrap顶层类加载器 --查找--&gt; ext扩展类库类加载器ext扩展类库类加载器 --委托--&gt; bootstrap顶层类加载器ext扩展类库类加载器 --查找--&gt; app用户应用程序类加载器app用户应用程序类加载器 --委托--&gt; ext扩展类库类加载器app用户应用程序类加载器 --查找--&gt; 最底端子类加载器最底端子类加载器 --委托--&gt; app用户应用程序类加载器</code></pre><p>为了避免重复加载, <strong>由下到上逐级委托, 由上到下主机查找</strong></p><ul><li>首先<strong>不会自己去尝试加载</strong>类, 而是<strong>把这个请求委托给父加载器</strong>去完成</li><li>每一个层次的加载器都是如此, 因此所有的类加载请求都会传给上层的启动类加载器</li><li><strong>只有当父加载器</strong>反馈自己<strong>无法</strong>完成该<strong>加载</strong>请求(该加载器的搜索范围中没有找到对应的类)时, 子加载器<strong>才会尝试自己去加载</strong></li></ul><p><strong>注意 :</strong> 类加载器之间不存在父类子类的关系, “双亲”是翻译, 可以理解为逻辑上定义的上下级关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoaderTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        <span class="hljs-type">URL</span> <span class="hljs-variable">classUrl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:D:\\tmp\\&quot;</span>);<br>        <span class="hljs-comment">// 父加载器</span><br><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">parentLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;);<br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>            <span class="hljs-comment">// 每次循环都创建新的类加载器</span><br>            <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;classUrl&#125;, parentLoader);<br>            System.out.println(DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loader.loadClass(<span class="hljs-string">&quot;HelloService&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;ClassLoader: &quot;</span> + clazz.getClassLoader());<br><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).invoke(newInstance);<br>            System.out.println(<span class="hljs-string">&quot;return value: &quot;</span> + value);<br><br>            Thread.sleep(<span class="hljs-number">5000L</span>);<br>            System.out.println();<br><br>            <span class="hljs-comment">// help gc  -verbose:class</span><br>            newInstance = <span class="hljs-literal">null</span>;<br>            loader = <span class="hljs-literal">null</span>;<br>        &#125;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考 :</strong> 很多优秀框架的<strong>热加载</strong>功能会不会是每次都创建新的加载器</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java系统性能调优</tag>
      
      <tag>jvm性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty零拷贝</title>
    <link href="/2020/07/31/netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/07/31/netty%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="一-ByteBuf"><a href="#一-ByteBuf" class="headerlink" title="一 : ByteBuf"></a>一 : ByteBuf</h2><p>ByteBuf 是为解决 ByteBuffer 的问题和满足网络应用程序开发人员的日常需求而设计的。</p><p>JDK ByteBuffer的缺点︰</p><ul><li><strong>无法动态扩容 :</strong> 长度是固定, 不能动态扩展和收缩, 当数据大于ByteBuffer容量时, 会发生索引越界异常。</li><li><strong>API使用复杂 :</strong> 读写的时候需要手工调用flip()和rewind()等方法, 使用时需要非常谨慎的使用这些api,否则很容出现错误</li></ul><p>ByteBuf 做了哪些增强</p><ul><li>API操作便捷性</li><li>动态扩容</li><li>多种 ByteBuf实现</li><li>高效的零拷贝机制</li></ul><h2 id="二-ByteBuf-操作"><a href="#二-ByteBuf-操作" class="headerlink" title="二 : ByteBuf 操作"></a>二 : ByteBuf 操作</h2><p>ByteBuf 三个<strong>重要属性</strong> : capacity容量、readerIndex读取位置、writerIndex写入位置。</p><p>提供了两个指针变量来支持顺序读和写操作, 分别是readerIndex和写操作writerIndex</p><p>常用方法定义</p><ul><li>随机访问索引 getByte</li><li>顺序读read*</li><li>顺序写write*</li><li>清除已读内容discardReadBytes</li><li>清除缓冲区clear</li><li>搜索操作</li><li>标记和重置</li><li>引用计数和释放</li></ul><p>下图显示了一个缓冲区是如何被两个指针分割成三个区域的</p><p><img src="/../java/image-2020073101.png" alt="image-2020073101"> </p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apiTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个非池化的ByteBuf, 大小为10个字节</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;原始ByteBuf为====================&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;1.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 2.写入一段内容</span><br>        <span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        buf.writeBytes(bytes);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;2.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 3.读取一段内容</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> buf.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> buf.readByte();<br>        System.out.println(<span class="hljs-string">&quot;读取的bytes为====================&gt;&quot;</span> + Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;b1, b2&#125;));<br>        System.out.println(<span class="hljs-string">&quot;读取一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;3.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 4.将读取的内容丢弃</span><br>        buf.discardReadBytes();<br>        System.out.println(<span class="hljs-string">&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;4.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 5.清空读写指针</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;将读写指针清空后ByteBuf为==========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;5.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 6.再次写入一段内容, 比第一段内容少</span><br>        <span class="hljs-type">byte</span>[] bytes2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        buf.writeBytes(bytes2);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes2));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;6.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 7.将ByteBuf清零</span><br>        buf.setZero(<span class="hljs-number">0</span>, buf.capacity());<br>        System.out.println(<span class="hljs-string">&quot;将内容清零后ByteBuf为==============&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;7.ByteBuf中的内容为================&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// 8.再次写入一段超过容量的内容</span><br>        <span class="hljs-type">byte</span>[] bytes3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>        buf.writeBytes(bytes3);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes3));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        System.out.println(<span class="hljs-string">&quot;8.ByteBuf中的内容为===============&gt;&quot;</span> + Arrays.toString(buf.array()) + <span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-comment">//  随机访问索引 getByte</span><br>        <span class="hljs-comment">//  顺序读 read*</span><br>        <span class="hljs-comment">//  顺序写 write*</span><br>        <span class="hljs-comment">//  清除已读内容 discardReadBytes</span><br>        <span class="hljs-comment">//  清除缓冲区 clear</span><br>        <span class="hljs-comment">//  搜索操作</span><br>        <span class="hljs-comment">//  标记和重置</span><br>        <span class="hljs-comment">//  完整代码示例：参考</span><br>        <span class="hljs-comment">// 搜索操作 读取指定位置 buf.getByte(1);</span><br>        <span class="hljs-comment">//</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-ByteBuf-动态扩容"><a href="#三-ByteBuf-动态扩容" class="headerlink" title="三 : ByteBuf 动态扩容"></a>三 : ByteBuf 动态扩容</h2><p>capacity默认值:256字节、最大值:Integer.MAX_VALUE ( 2GB)</p><p><code>write*</code> 方法调用时, 通过 <code>AbstractByteBuf.ensureWritable0</code> 进行检查。</p><p>容量计算方法 : AbstractByteBufAllocator. calculateNewCapacity (新capacity的最小要求, capacity最大值), 根据新capacity的最小值要求, 对应有两套计算方法:</p><ol><li><strong>没超过4兆 :</strong> 从64字节开始, 每次增加一倍, 直至计算出来的newCapacity满足新容量最小要求。示例 : 当前大小256, 已写250, 继续写10字节数据, 需要的容量最小要求是261, 则新容量是  64 * 2 * 2 * 2&#x3D;512</li><li><strong>超过4兆 :</strong> 新容量 &#x3D; 新容量最小要求&#x2F;4兆 * 4兆＋4兆; 示例:当前大小3兆, 已写3兆, 继续写2兆数据, 需要的容量最小要求是5兆, 则新容量是9兆(不能超过最大值)。</li></ol><h2 id="四-ByteBuf-的具体实现"><a href="#四-ByteBuf-的具体实现" class="headerlink" title="四 : ByteBuf 的具体实现"></a>四 : ByteBuf 的具体实现</h2><p>3个维度, 8种实现</p><p><img src="/../java/image-2020073102.png" alt="image-2020073102"> </p><p>unsafe意味着不安全的操作。但是更底层的操作会带来性能提升和特殊功能, Netty中会尽力使用unsafe。</p><p>Java语言很重要的特性是“一次编写到处运行”, 所以它针对底层的内存或者其他操作, 做了很多封装。而unsafe提供了一系列我们操作底层的方法, 可能会导致不兼容或者不可知的异常。</p><ul><li>Info.仅返回一些低级的内存信息 : addressSize, pageSize</li><li>Objects.提供用于操作对象及其字段的方法 : allocatelnstance, objectFieldOffset</li><li>Classes.提供用于操作类及其静态字段的方法 : staticFieldoffset, defineClass, defineAnonymousClass, ensureClassInitialized</li><li>Synchronization.低级的同步原语 : monitorEnter, tryMonitorEnter, monitorExit, compareAndSwaplnt, putOrderedInt</li><li>Memory.直接访问内存方法 : allocateMemory, copyMemory, freeMemory, getAddress, getln, tputlnt</li><li>Arrays.操作数组 : arrayBaseOffset, arrayIndexScale</li></ul><p>在使用中, 都是通过 ByteBufAllocator 分配器进行申请, 同时分配器具备有内存管理的功能</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆外内存的常规API</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectByteBufDemo</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apiTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.创建一个非池化的ByteBuf, 大小为10个字节</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.directBuffer(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;原始ByteBuf为====================&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">// System.out.println(&quot;1.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 2.写入一段内容</span><br>        <span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        buf.writeBytes(bytes);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;2.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 3.读取一段内容</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> buf.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> buf.readByte();<br>        System.out.println(<span class="hljs-string">&quot;读取的bytes为====================&gt;&quot;</span> + Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;b1, b2&#125;));<br>        System.out.println(<span class="hljs-string">&quot;读取一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">//System.out.println(&quot;3.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 4.将读取的内容丢弃</span><br>        buf.discardReadBytes();<br>        System.out.println(<span class="hljs-string">&quot;将读取的内容丢弃后ByteBuf为========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;4.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 5.清空读写指针</span><br>        buf.clear();<br>        System.out.println(<span class="hljs-string">&quot;将读写指针清空后ByteBuf为==========&gt;&quot;</span> + buf.toString());<br>        <span class="hljs-comment">//System.out.println(&quot;5.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 6.再次写入一段内容, 比第一段内容少</span><br>        <span class="hljs-type">byte</span>[] bytes2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        buf.writeBytes(bytes2);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes2));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;6.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 7.将ByteBuf清零</span><br>        buf.setZero(<span class="hljs-number">0</span>, buf.capacity());<br>        System.out.println(<span class="hljs-string">&quot;将内容清零后ByteBuf为==============&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;7.ByteBuf中的内容为================&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br><br>        <span class="hljs-comment">// 8.再次写入一段超过容量的内容</span><br>        <span class="hljs-type">byte</span>[] bytes3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>        buf.writeBytes(bytes3);<br>        System.out.println(<span class="hljs-string">&quot;写入的bytes为====================&gt;&quot;</span> + Arrays.toString(bytes3));<br>        System.out.println(<span class="hljs-string">&quot;写入一段内容后ByteBuf为===========&gt;&quot;</span> + buf.toString());<br>       <span class="hljs-comment">// System.out.println(&quot;8.ByteBuf中的内容为===============&gt;&quot; + Arrays.toString(buf.array()) + &quot;\n&quot;);</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-PooledByteBuf-对象、内存复用"><a href="#五-PooledByteBuf-对象、内存复用" class="headerlink" title="五 : PooledByteBuf 对象、内存复用"></a>五 : PooledByteBuf 对象、内存复用</h2><p><strong>PoolThreadCache :</strong> PooledByteBufAllocator 实例维护的一个线程变量。</p><p>多种分类的 MemoryRegionCache <strong>数组</strong>用作内存缓存，MemoryRegionCache内部是链表，队列里面存Chunk</p><p>PoolChunk里面维护了内存引用，内存复用的做法就是把 buf 的 memory 指向 chunk 的 memory</p><p>PooledByteBufAllocator.ioBuffer<strong>运作过程</strong>梳理</p><p><img src="/../java/image-2020073103.png" alt="image-2020073103"> </p><h2 id="六-零拷贝机制"><a href="#六-零拷贝机制" class="headerlink" title="六 : 零拷贝机制"></a>六 : 零拷贝机制</h2><p>Netty的零拷贝机制，是一种应用层的实现。和底层JVM、操作系统内存机制并无过多关联。</p><p>CompositeByteBuf，将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝</p><p><img src="/../java/image-2020073104.png" alt="image-2020073104">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">compositeByteBuf</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> compositeByteBuf.addComponents(<span class="hljs-literal">true</span>, buffer1, buffer2);<br></code></pre></td></tr></table></figure><p>wrapedBuffer()方法，将byte[]数组包装成ByteBuf对象。</p><p><img src="/../java/image-2020073105.png" alt="image-2020073105"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><p>slice()方法。将一个ByteBuf对象切分成多个ByteBuf对象。</p><p><img src="/../java/image-2020073106.png" alt="image-2020073106"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> buffer1.slice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 零拷贝</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZeroCopyTest</span> &#123;<br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(arr);<br>        System.out.println(byteBuf.getByte(<span class="hljs-number">4</span>));<br>        arr[<span class="hljs-number">4</span>] = <span class="hljs-number">6</span>;<br>        System.out.println(byteBuf.getByte(<span class="hljs-number">4</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sliceTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.wrappedBuffer(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> buffer1.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        newBuffer.unwrap();<br>        System.out.println(newBuffer.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@org</span>.junit.Test<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compositeTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">3</span>);<br>        buffer1.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">3</span>);<br>        buffer2.writeByte(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">compositeByteBuf</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br>        <span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> compositeByteBuf.addComponents(<span class="hljs-literal">true</span>, buffer1, buffer2);<br>        System.out.println(newBuffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty责任链</title>
    <link href="/2020/07/24/netty%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
    <url>/2020/07/24/netty%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一-设计模式-责任链模式"><a href="#一-设计模式-责任链模式" class="headerlink" title="一 : 设计模式 - 责任链模式"></a>一 : 设计模式 - 责任链模式</h2><p>责任链模式(Chain of Responsibility Pattern)为请求创建了一个处理对象的链。<br><strong>发起请求和具体处理请求的过程进行解耦</strong> : 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可, 无须关心请求的处理细节和请求的传递</p><pre><code class=" mermaid">graph LR请求 --&gt; 责任链调用 --chains--&gt; handler1 --&gt; handler2 --&gt; handler3 --&gt; handler-n --&gt; ... </code></pre><h3 id="一-实现责任链模式"><a href="#一-实现责任链模式" class="headerlink" title="(一) : 实现责任链模式"></a>(一) : 实现责任链模式</h3><p>实现责任链模式4个要素 : </p><ol><li>处理器抽象类</li><li>具体的处理器实现类</li><li>保存处理器信息</li><li>处理执行</li></ol><p>伪代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 集合形式存储: 类似tomcat中filters</span><br><span class="hljs-comment">// 1.处理器抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandler</span><span class="hljs-params">(Object arg0)</span>; <br>&#125;<br><br><span class="hljs-comment">// 2.处理器具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><br><span class="hljs-comment">// 3.创建集合并存储所有处理器实例信息</span><br><span class="hljs-type">List</span> <span class="hljs-variable">handlers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();<br>handlers.add(handler1, handler2, handler3);<br><br><span class="hljs-comment">// 4.处理请求，调用处理器()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Process</span><span class="hljs-params">(request)</span>&#123;<br>    <span class="hljs-keyword">for</span>( handler in handlers)&#123;<br>        handler.doHandler(request) ;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 发起请求调用，通过责任链处理请求</span><br>call.process(request);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//链表形式调用: 参考netty的实现形式</span><br><span class="hljs-comment">// 1.处理器抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> &#123;<br>    AbstractHandle next;<span class="hljs-comment">//下一个节点</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandler</span> <span class="hljs-params">(Object argo)</span>; <span class="hljs-comment">// handler方法</span><br>&#125;<br><span class="hljs-comment">// 2.处理器具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandler</span> &#123; <span class="hljs-keyword">assert</span> coutinue;&#125;<br><br><span class="hljs-comment">// 3.将处理器串成链表存储</span><br><span class="hljs-comment">// pipeline=头[ handler1 -&gt; handler2 -&gt;handler3]尾</span><br><br><span class="hljs-comment">// 4.处理请求，调用处理器(从头到尾)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Process</span><span class="hljs-params">( request)</span>&#123;<br>    handler = pipeline.findOne;<br>    <span class="hljs-comment">//查找第一个</span><br>    <span class="hljs-keyword">while</span>(hand != <span class="hljs-literal">null</span>)&#123;<br>        handler.doHandler(request);<br>        handler = handler.next();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-Netty-中的-ChannelPipeline-责任链"><a href="#二-Netty-中的-ChannelPipeline-责任链" class="headerlink" title="(二) : Netty 中的 ChannelPipeline 责任链"></a>(二) : Netty 中的 ChannelPipeline 责任链</h3><p><strong>Pipeline管道</strong>保存了通道所有处理器信息。</p><p>创建新channel时自动创建一个专有的pipeline。入站<strong>事件</strong>和出站<strong>操作</strong>会调用pipeline上的处理器</p><p><img src="/../java/image-2020072401.png"> </p><h2 id="二-事件"><a href="#二-事件" class="headerlink" title="二 : 事件"></a>二 : 事件</h2><h3 id="一-入站事件和出站事件"><a href="#一-入站事件和出站事件" class="headerlink" title="(一) 入站事件和出站事件"></a>(一) 入站事件和出站事件</h3><p><strong>入站事件 :</strong> 通常指I&#x2F;O线程生成了入站数据。(通俗理解:从socket底层自己往上冒上来的事件都是入站)</p><p>比如EventLoop收到selector的OP_READ事件，入站处理器调用socketChannel.read(ByteBuffer)接收到数据后，这将导致通道的ChannelPipeline中包含的下一个中的channelRead方法被调用。</p><p><strong>出站事件 :</strong> 经常是指I&#x2F;O线程执行实际的输出操作。(通俗理解:想主动往socket底层操作的事件的都是出站)</p><p>比如bind方法用意是请求server socket绑定到给定的SocketAddress，这将导致通道的ChannelPipeline中包含的下一个出站处理器中的bind方法被调用。</p><h3 id="二-Netty-中事件的定义"><a href="#二-Netty-中事件的定义" class="headerlink" title="(二) Netty 中事件的定义"></a>(二) Netty 中事件的定义</h3><p>入站事件(inbound)</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>fireChannelRegistered</td><td>channel注册事件</td></tr><tr><td>fireChannelUnregistered</td><td>channel解除注册事件</td></tr><tr><td>fireChannelActive</td><td>channel活跃事件</td></tr><tr><td>fireChannelInactive</td><td>channel非活跃事件</td></tr><tr><td>fireExceptionCaught</td><td>异常事件</td></tr><tr><td>fireUserEventTriggered</td><td>用户自定义事件</td></tr><tr><td>fireChannelRead</td><td>channel读事件</td></tr><tr><td>fireChannelReadComplete</td><td>channel读完成事件</td></tr><tr><td>fireChannelWritabilityChanged</td><td>channel写状态变化事件</td></tr></tbody></table><p>出站事件(outbound)</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>bind</td><td>端口绑定事件</td></tr><tr><td>connect</td><td>连接事件</td></tr><tr><td>disconnect</td><td>断开连接事件</td></tr><tr><td>close</td><td>关闭事件</td></tr><tr><td>deregister</td><td>解除注册事件</td></tr><tr><td>flush</td><td>刷新数据到网络事件</td></tr><tr><td>read</td><td>读事件，用于注册OP_READ到selector</td></tr><tr><td>write</td><td>写事件</td></tr><tr><td>writeAndFlush</td><td>写出数据事件</td></tr></tbody></table><h2 id="三-处理器"><a href="#三-处理器" class="headerlink" title="三 : 处理器"></a>三 : 处理器</h2><h3 id="一-Pipeline-中的-handler-是什么"><a href="#一-Pipeline-中的-handler-是什么" class="headerlink" title="(一) Pipeline 中的 handler 是什么"></a>(一) Pipeline 中的 handler 是什么</h3><p><strong>ChannelHandler :</strong> 用于处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作, 并转发到 ChannelPipeline 中的下一个处理器; 这个顶级接口定义功能很弱, 实际使用时会去实现以下两大子接口 : 处理入站 I&#x2F;O 事件的 ChannelInBoundHandler, 处理出站 I&#x2F;O 操作的 ChannelOutBoundHandler</p><p><strong>适配器类 :</strong> 为了开发方便, 避免所有 handler 去实现一遍接口方法, Netty 提供了简单的实现类</p><ul><li>处理入站 I&#x2F;O 事件 : ChannelInboundHandlerAdapter</li><li>处理出站 I&#x2F;O 事件 : ChannelOutboundHandlerAdapter</li><li>同时处理入站和出站事件 : ChannelDuplexHandler</li></ul><p><strong>ChannelHandlerContext :</strong> 实际存储在 Pipeline 中的对象并非 ChannelHandler, 而是上下文对象; 将 handler 包裹在上下文对象中, 通过上下文对象与它所属的 ChannelPipeline 交互, 向上或向下传递事件或者修改 pipeline 都是通过上下文对象</p><h3 id="二-维护-Pipeline-中的-handler"><a href="#二-维护-Pipeline-中的-handler" class="headerlink" title="(二) 维护 Pipeline 中的 handler"></a>(二) 维护 Pipeline 中的 handler</h3><p>ChannelPipeline是线程安全的，ChannelHandler可以在任何时候添加或删除。</p><p>例如，你可以在即将交换敏感信息时插入加密处理程序，并在交换后删除它。</p><p>一般操作，初始化的时候增加进去，较少删除。</p><p>Pipeline 中管理 handler 的API</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>addFirst</td><td>最前面插入</td></tr><tr><td>addLast</td><td>最后面插入</td></tr><tr><td>addBefore</td><td>插入到指定处理器前面</td></tr><tr><td>addAfter</td><td>插入到指定处理器后面</td></tr><tr><td>remove</td><td>移除指定处理器</td></tr><tr><td>removeFirst</td><td>移除第一个处理器</td></tr><tr><td>removeLast</td><td>移除最后一个处理器</td></tr><tr><td>replace</td><td>替换指定的处理器</td></tr></tbody></table><p>伪代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ...;<br>p.addLast(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerA</span>());<br>p.addLast(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutboundHandlerB</span>());<br>p.addLast(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InboundOutboundHandlerX</span>()); <span class="hljs-comment">// 聚合处理器</span><br></code></pre></td></tr></table></figure><h3 id="三-handler-的执行分析"><a href="#三-handler-的执行分析" class="headerlink" title="(三) handler 的执行分析"></a>(三) handler 的执行分析</h3><p>按之前伪代码逻辑, 现在的责任链如图所示</p><pre><code class=" mermaid">graph TDE[ChannelDuplexHandler5] --- D[Outbound Handler 4] --- C[Outbound Handler 3] --- B[Inbound Handler 2] --- A[Inbound Handler 1] </code></pre><p>由此可以推断 : </p><ul><li>当入站事件时, 执行顺序是 : 1 &#x3D;&gt; 2 &#x3D;&gt; 3 &#x3D;&gt; 4 &#x3D;&gt; 5</li><li>当出站事件时, 执行顺序是 : 5 &#x3D;&gt; 4 &#x3D;&gt; 3 &#x3D;&gt; 2 &#x3D;&gt; 1</li></ul><p>在这一原则之上, ChannelPipeline在执行时会进行选择3和4为出站处理器, 因此, 实际执行是 :</p><ul><li>入站事件的执行顺序是 1 &#x3D;&gt; 2 &#x3D;&gt; 5, 1和2为入站处理器</li><li>出站事件的执行顺序是 5 &#x3D;&gt; 4 &#x3D;&gt; 3</li></ul><p>不同的入站事件会触发handler不同的方法执行 : </p><ul><li><p>上下文对象中 <code>fire**</code> 开头的方法, 代表<strong>入站</strong>事件传播和处理</p></li><li><p>其余的方法代表<strong>出站</strong>事件的传播和处理。</p></li></ul><h2 id="四-分析"><a href="#四-分析" class="headerlink" title="四 : 分析"></a>四 : 分析</h2><h3 id="一-分析-registered-入站事件的处理"><a href="#一-分析-registered-入站事件的处理" class="headerlink" title="(一) 分析 registered 入站事件的处理"></a>(一) 分析 registered 入站事件的处理</h3><p><img src="/../java/image-2020072402.png"> </p><p>ServerSocketChannel.pipeline的变化</p><p><img src="/../java/image-2020072403.png" alt="image-2020072403"> </p><h3 id="二-分析-bind-出站事件的处理"><a href="#二-分析-bind-出站事件的处理" class="headerlink" title="(二) 分析 bind 出站事件的处理"></a>(二) 分析 bind 出站事件的处理</h3><p><img src="/../java/image-2020072404.png" alt="image-2020072404"> </p><h3 id="三-分析-accept-入站事件的处理"><a href="#三-分析-accept-入站事件的处理" class="headerlink" title="(三) 分析 accept 入站事件的处理"></a>(三) 分析 accept 入站事件的处理</h3><p><img src="/../java/image-2020072405.png" alt="image-2020072405"> </p><p>这是一个分配的过程，main Group负责accept，然后分配sub Group负责read</p><h3 id="四-分析-read-入站事件的处理"><a href="#四-分析-read-入站事件的处理" class="headerlink" title="(四) 分析 read 入站事件的处理"></a>(四) 分析 read 入站事件的处理</h3><p>pipeline分析的关键4要素:什么事件、有哪些处理器、哪些会被触发、执行顺序</p><p><img src="/../java/image-2020072406.png" alt="image-2020072406"> </p><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五 : 小结"></a>五 : 小结</h2><p>用户在管道中有一个或多个 channelhandler 来接收 I&#x2F;O 事件(例如读取)和请求 I&#x2F;O 操作(例如写入和关闭)</p><p>一个典型的服务器在每个通道的管道中都有以下处理程序, 但是根据协议和业务逻辑的复杂性和特征, 可能会有所不同</p><ul><li><p>协议解码器 : 将二进制数据(例如 ByteBuf)转换为 Java 对象</p></li><li><p>协议编码器 : 将 Java 对象转换为二进制数据</p></li><li><p>业务逻辑处理程序 : 执行实际的业务逻辑(例如数据库访问)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty线程模型</title>
    <link href="/2020/07/17/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/17/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Netty-简介"><a href="#一-Netty-简介" class="headerlink" title="一 : Netty 简介"></a>一 : Netty 简介</h2><p>Netty 是一个高性能, 高可扩展性的异步事件驱动的<strong>网络应用程序框架</strong>, 它极大地简化了 TCP 和 UDP 客户端和服务器开发等网络编程</p><p>官网 : <a href="https://netty.io/">https://netty.io/</a></p><p>Netty 重要的四个内容</p><ol><li>Reactor 线程模型 : 一种高性能的多线程程序设计思路</li><li>Netty 中自己定义的 Channel 概念 : 增强版的通道概念</li><li>ChannelPipeline 责任链设计模式 : 事件处理机制</li><li>内存管理 : 增强的 ByteBuffer 缓冲区</li></ol><h2 id="二-Netty-整体结构"><a href="#二-Netty-整体结构" class="headerlink" title="二 : Netty 整体结构"></a>二 : Netty 整体结构</h2><p><img src="/../java/image-2020071701.png" alt="image-2020071701"> </p><p>可以看出包含三大块 </p><ol><li>支持 Socket 等多种传输方式</li><li>提供了多种协议的编解码实现</li><li>核心设计包含<strong>事件处理模型, API的使用, ByteBuffer 的增强</strong></li></ol><h2 id="三-Netty-线程模型"><a href="#三-Netty-线程模型" class="headerlink" title="三 : Netty 线程模型"></a>三 : Netty 线程模型</h2><p>为了让 NIO 处理更好的利用多线程特性, Netty 实现了 Reactor 线程模型</p><p><img src="/../java/image-2020071702.png" alt="image-2020071702"> </p><p>Reactor 模型中有四个核心概念 : </p><ol><li>Resources 资源(请求&#x2F;任务)</li><li>Synchronous Event Demutiplexer 同步事件复用器</li><li>Dispatcher 分配器</li><li>Request Handler 请求处理器</li></ol><h2 id="四-EventLoopGroup-初始化过程"><a href="#四-EventLoopGroup-初始化过程" class="headerlink" title="四 : EventLoopGroup 初始化过程"></a>四 : EventLoopGroup 初始化过程</h2><p>如图所示, 两组 EventLoopGroup (Main&amp;Sub) 处理不同通道的事件</p><p><img src="/../java/image-2020071703.png" alt="image-2020071703"> </p><p>源码示例 : example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SslContext</span> <span class="hljs-variable">sslCtx</span> <span class="hljs-operator">=</span> ServerUtil.buildSslContext();<br><br>        <span class="hljs-comment">// Configure the server.</span><br>        <span class="hljs-comment">// 创建EventLoopGroup: accept线程组 NioEventLoop</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 指定线程数量,否则采用默认值</span><br>        <span class="hljs-comment">// 创建EventLoopGroup: I/O线程组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">EchoServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServerHandler</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 服务端启动引导工具类</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">// 配置服务端处理的reactor线程组以及服务端的其他配置</span><br>            b.group(bossGroup, workerGroup)<br>                .channel(NioServerSocketChannel.class)<br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                        <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>                            p.addLast(sslCtx.newHandler(ch.alloc()));<br>                        &#125;<br>                        <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                        p.addLast(serverHandler);<br>                    &#125;<br>                &#125;);<br><br>            <span class="hljs-comment">// Start the server. 通过bind启动服务</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.bind(PORT).sync();<br><br>            <span class="hljs-comment">// Wait until the server socket is closed. 阻塞主线程,知道网络服务被关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Shut down all event loops to terminate all threads. 关闭线程组</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-EventLoop-的启动"><a href="#五-EventLoop-的启动" class="headerlink" title="五 : EventLoop 的启动"></a>五 : EventLoop 的启动</h2><p>EventLoop 自身实现了 Executor 接口, 当调用 executor 方法提交任务时, 则判断是否启动, 未启动则调用内置的 executor 创建新线程来触发 run() 执行</p><p><img src="/../java/image-2020071704.png" alt="image-2020071704"> </p><h2 id="六-Bind-绑定端口过程"><a href="#六-Bind-绑定端口过程" class="headerlink" title="六 : Bind 绑定端口过程"></a>六 : Bind 绑定端口过程</h2><p>如图所示</p><p><img src="/../java/image-2020071705.png" alt="image-2020071705">  </p><h2 id="七-Channel-概念"><a href="#七-Channel-概念" class="headerlink" title="七 : Channel 概念"></a>七 : Channel 概念</h2><p>netty 中的 Channel 是一个抽象的概念, 可以理解为对 JDK NIO Channel 的增强和拓展; </p><p>增强了很多属性和方法, 完整信息可以看源码, 下面罗列几个常见的属性和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultAttributeMap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Channel</span> &#123;<br>    <span class="hljs-comment">// 通道内时间处理链路</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultChannelPipeline pipeline; <br>    <span class="hljs-comment">// 绑定的EventLoop,用于执行操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AbstractChannel.PausableChannelEventLoop eventLoop;<br>    <span class="hljs-comment">// 提供IO相关操作的封装</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><br>    <span class="hljs-comment">// 父类方法,返回通道配置信息</span><br>    ChannelConfig <span class="hljs-title function_">config</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 开始读数据,触发读取链路调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Channel <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        pipeline.read();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 写数据,触发链路调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> pipeline.write(msg);<br>    &#125;<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> &#123;<br>        <span class="hljs-keyword">return</span> pipeline.bind(localAddress);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八 : 小结"></a>八 : 小结</h2><p>毕竟抽象的设计模式, 在学习过程中会有难懂的地方, 所以着重需要结合代码理解</p><p>这里的目的有两个 : 领会 Reactor 的理念, 掌握代码示例中具体的写法</p><p><strong>重点关注服务端开发,</strong> 因为服务端要应对海量连接, 难度大, 而客户端仅仅是一个连接</p><p><strong>Reactor 多线程模式的设计, 是 Netty 高性能很重要的一个原因</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO非阻塞网络编程</title>
    <link href="/2020/07/10/NIO/"/>
    <url>/2020/07/10/NIO/</url>
    
    <content type="html"><![CDATA[<h2 id="一-java-NIO"><a href="#一-java-NIO" class="headerlink" title="一 : java NIO"></a>一 : java NIO</h2><p>始于 java 1.4, 提供了新的 JAVA IO 操作非阻塞 API; 用意是替代 Java IO 和 Java Networking 相关的 API</p><p>NIO 中有三个核心组件 : Buffer, Channel, Selector</p><h2 id="二-Buffer-缓冲区"><a href="#二-Buffer-缓冲区" class="headerlink" title="二 : Buffer 缓冲区"></a>二 : Buffer 缓冲区</h2><p><strong>缓冲区</strong>本质上是一个可以写入数据的内存块(类似数组), 然后可以再次读取; 此内存块包含在 NIO Buffer 对象中, 该对象提供了一组方法, 可以更轻松地使用内存块; </p><p>相比较直接对数组的操作, <strong>Buffer API 更加容易操作和管理;</strong> </p><p>使用 Buffer 进行数据写入与读取, 需要进行如下<strong>四个步骤</strong> : </p><ol><li>将数据写入缓冲区</li><li>调用 <code>buffer.flip()</code>, 转换为读取模式</li><li>缓冲区读取数据</li><li>调用 <code>buffer.clear()</code> 或 <code>buffer.compact()</code> 清除缓冲区</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 构建一个byte字节缓冲区，容量是4</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 默认写入模式，查看三个重要的指标</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;初始化：capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br>        <span class="hljs-comment">// 写入2字节的数据</span><br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">1</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">2</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 再看数据</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)</span><br>        System.out.println(<span class="hljs-string">&quot;#######开始读取&quot;</span>);<br>        byteBuffer.flip();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> byteBuffer.get();<br>        System.out.println(a);<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> byteBuffer.get();<br>        System.out.println(b);<br>        System.out.println(String.format(<span class="hljs-string">&quot;读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据</span><br>        <span class="hljs-comment">// clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式</span><br>        byteBuffer.compact(); <span class="hljs-comment">// buffer : 1 , 3</span><br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">3</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">4</span>);<br>        byteBuffer.put((<span class="hljs-type">byte</span>) <span class="hljs-number">5</span>);<br>        System.out.println(String.format(<span class="hljs-string">&quot;最终的情况，capacity容量：%s, position位置：%s, limit限制：%s&quot;</span>, byteBuffer.capacity(),<br>                byteBuffer.position(), byteBuffer.limit()));<br><br>        <span class="hljs-comment">// rewind() 重置position为0</span><br>        <span class="hljs-comment">// mark() 标记position的位置</span><br>        <span class="hljs-comment">// reset() 重置position为上次mark()标记的位置</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一-Buffer-工作原理"><a href="#一-Buffer-工作原理" class="headerlink" title="(一) Buffer 工作原理"></a>(一) Buffer 工作原理</h3><p>Buffer <strong>三个重要属性</strong> </p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>capacity</td><td>作为一个内存块, Buffer 具有一定的固定大小, 也称为<strong>容量</strong></td></tr><tr><td>position</td><td>写入模式时代表写数据的<strong>位置</strong>; 读取模式时代表读取数据的<strong>位置</strong></td></tr><tr><td>limit</td><td>写入模式, <strong>限制</strong>等于 buffer 的容量; 读取模式下, limit 等于写入的数据量</td></tr></tbody></table><p>读写模式</p><p><img src="/../java/image-2020071001.png" alt="读写模式"> </p><h3 id="二-ByteBuffer-内存类型"><a href="#二-ByteBuffer-内存类型" class="headerlink" title="(二) ByteBuffer 内存类型"></a>(二) ByteBuffer 内存类型</h3><p>ByteBuffer 为性能关键型代码提供了**直接内存(direct堆外)<strong>和</strong>非直接内存(heap堆)**两种实现</p><p>堆外内存获取的方式: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//堆内存(非直接内存)</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//直接内存(堆外内存)</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">directByteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>好处 : </p><ol><li>进行网络 IO 或者文件 IO 时比 heapBuffer 少一次拷贝(file&#x2F;socket &#x3D;&gt; OS memory &#x3D;&gt; jvm heap); GC 会移动对象内存, 在写 file 或 socket 的过程中, jvm 的实现中, 会先把数据复制到堆外, 再进行写入</li><li>GC 范围之外, 降低 GC 压力, 但实现了自动管理; DirectByteBuffer 中有一个 Cleaner 对象(PhantomReference), Cleaner 被 GC 前会执行 clean(), 触发 DirectByteBuffer 中定义的 Deallocator</li></ol><p><strong>建议 :</strong> </p><ol><li>性能确实可观的时候才去使用; 分配给大型, 长寿命的对象或应用(网络传输, 文件读写场景)</li><li>通过虚拟机参数 MaxDirectMemorySize 限制大小, 防止耗尽整个及其的内存</li></ol><h2 id="三-Channel-通道"><a href="#三-Channel-通道" class="headerlink" title="三 : Channel 通道"></a>三 : Channel 通道</h2><p>在 BIO 编程中一切网络操作是通过 socket + io 两者组合进行操作的, 也就是需要 io 包和 net 包; </p><pre><code class=" mermaid">graph LRA1[代码] --byte数据写入--&gt; outputStream ---|网络| inputStream --代码读取内容,read阻塞读取--&gt; B1[代码]</code></pre><p>而在 NIO 中则只需要 nio 包即可</p><pre><code class=" mermaid">graph LRA2[代码] --&gt; B2[buffer] --&gt;|缓冲区数据写入通道| C2[channel] ---|网络| D2[channel] --&gt;|通道数据写入缓冲区| E2[buffer] --&gt; F2[代码] </code></pre><p>Channel 的 API 涵盖了 UDP&#x2F;TCP 网络和文件 IO</p><ul><li>FileChannel</li><li><strong>DatagramChannel</strong></li><li><strong>SocketChannel</strong></li><li><strong>ServerSocketChannel</strong></li></ul><p>和标准 IO Stream 操作的区别</p><ul><li>在一个通道内进行读取和写入</li><li>stream 通常是单向的(inupt 或 ouput)</li><li>可以非阻塞读取和写入通道</li><li>通道始终读取或写入缓冲区</li></ul><h3 id="一-SocketChannel"><a href="#一-SocketChannel" class="headerlink" title="(一) SocketChannel"></a>(一) SocketChannel</h3><p>SocketChannel 用于建立 TCP 网络连接, 类似 java.net.Socket; </p><p>有两种创建 SocketChannel 形式 :</p><ol><li>客户端主动发起和服务器的连接</li><li>服务端获取的新连接</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 客户端主动发起连接的方式</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br>        socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-keyword">while</span> (!socketChannel.finishConnect()) &#123;<br>            <span class="hljs-comment">// 没连接上,则一直等待</span><br>            Thread.<span class="hljs-keyword">yield</span>();<br>        &#125;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>        <span class="hljs-comment">// 发送内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(msg.getBytes());<br>        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>            <span class="hljs-comment">// 发送请求数据 - 向通道写入数据</span><br>            socketChannel.write(buffer);<br>        &#125;<br>        <span class="hljs-comment">// 读取响应</span><br>        System.out.println(<span class="hljs-string">&quot;收到服务端响应:&quot;</span>);<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">// 读取服务端返回 - 读取缓冲区的数据: int bytesRead = socketChannel.read(byteBuffer)</span><br>        <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>            <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        requestBuffer.flip();<br>        <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>        requestBuffer.get(content);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>        scanner.close();<br>        <span class="hljs-comment">// 关闭连接</span><br>        socketChannel.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>write 写 : write() 在尚未写入任何内容时就可能返回了; 需要在循环中调用 write()</li><li>read 读 : read() 可能直接返回而根本不读取任何数据, 根据返回的 int 值判断读取了多少字节</li></ul><h3 id="二-ServerSocketChannel"><a href="#二-ServerSocketChannel" class="headerlink" title="(二) ServerSocketChannel"></a>(二) ServerSocketChannel</h3><p>ServerSocketChannel 可以监听新建的 TCP 连接通道, 类似 ServerSocket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建网络服务端</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>)); <span class="hljs-comment">// 绑定端口</span><br>        System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept(); <span class="hljs-comment">// 获取新tcp连接通道</span><br>            <span class="hljs-comment">// tcp请求 读取/响应</span><br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认是阻塞的,一定要设置为非阻塞</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ socketChannel.getRemoteAddress());<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        socketChannel.write(buffer);<span class="hljs-comment">// 非阻塞</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这种低效的循环检查,会是NIO服务端的正确开发方式吗 ?</span><br><span class="hljs-comment">         * 用到了非阻塞的API,在设计上,和BIO可以有很大的不同,需要仅需改进</span><br><span class="hljs-comment">         * 其实可以有这样一种思路,如果有连接,则将连接存起来,在没有连接的时候进行数据的读取和处理</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serverSocketChannel.accept()</code>, 如果该通道处于非阻塞模式, 那么如果没有挂起的连接, 该方法将立即返回 null ; <strong>必须检查</strong>返回的 SocketChannel 是否为 null</p><h2 id="四-Selector-选择器"><a href="#四-Selector-选择器" class="headerlink" title="四 : Selector 选择器"></a>四 : Selector 选择器</h2><p>Selector 是一个 java NIO 组件, 可以检查一个或多个 NIO 通道, 并确定哪些通道已准备好进行读取或写入; <strong>实现单个线程可以管理多个通道, 从而管理多个网络连接</strong></p><pre><code class=" mermaid">graph LRThread --&gt; Selector Selector --&gt; A1[Channel]Selector --&gt; A2[Channel]Selector --&gt; A3[Channel]  </code></pre><p>一个线程使用 Selector 监听多个 channel 的不同事件(四个事件分别对应 SelectionKey 四个常量) : </p><table><thead><tr><th>名称</th><th>描述</th><th>常量</th></tr></thead><tbody><tr><td>OP_CONNECT</td><td>Connect 连接</td><td>SelectionKey.OP_CONNECT</td></tr><tr><td>OP_ACCEPT</td><td>Accept 准备就绪</td><td>SelectionKey.OP_ACCEPT</td></tr><tr><td>OP_READ</td><td>Read 读取</td><td>SelectionKey.OP_READ</td></tr><tr><td>OP_WRITE</td><td>Write 写入</td><td>SelectionKey.OP_WRITE</td></tr></tbody></table><p>实现一个线程处理多个通道的核心概念理解 : <strong>事件驱动机制</strong></p><p>非阻塞的网络通道下, 开发者通过 Selector 注册对于通道感兴趣的事件类型, 线程通过监听事件来触发相应的代码执行</p><p><strong>拓展 : 更底层是操作系统的多路复用机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 注册感兴趣的事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br><span class="hljs-comment">// 由 accept 轮询, 变成了事件通知的方式</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// select 收到新的事件, 方法才会返回</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br>    <span class="hljs-keyword">if</span>(readyChannels == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKey();<br>    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br>    <span class="hljs-keyword">while</span>(keyIterator.hasNext())&#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-comment">// 判断不同的事件类型, 执行对应的逻辑处理</span><br>        <span class="hljs-comment">// key.isAcceptable()</span><br>        <span class="hljs-comment">// key.isConnectable()</span><br>        <span class="hljs-comment">// key.isReadable()</span><br>        <span class="hljs-comment">// key.isWritable()</span><br>        keyIterator.remove()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例(服务端)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServerV2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建网络服务端ServerSocketChannel</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br><br>        <span class="hljs-comment">// 2. 构建一个Selector选择器,并且将channel注册上去</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 将serverSocketChannel注册到selector</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, serverSocketChannel);<br>        <span class="hljs-comment">// 对serverSocketChannel上面的accept事件感兴趣(serverSocketChannel只能支持accept操作)</span><br>        selectionKey.interestOps(SelectionKey.OP_ACCEPT); <br><br>        <span class="hljs-comment">// 3. 绑定端口</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 不再轮询通道,改用下面轮询事件的方式.select方法有阻塞效果,直到有事件通知才会有返回</span><br>            selector.select();<br>            <span class="hljs-comment">// 获取事件</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-comment">// 遍历查询结果e</span><br>            Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-comment">// 被封装的查询结果</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.attachment();<br>                    <span class="hljs-comment">// 将拿到的客户端连接通道,注册到selector上面</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSocketChannel</span> <span class="hljs-operator">=</span> server.accept(); <span class="hljs-comment">// mainReactor 轮询accept</span><br>                    clientSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    clientSocketChannel.register(selector, SelectionKey.OP_READ, clientSocketChannel);<br>                    System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + clientSocketChannel.getRemoteAddress());<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.attachment();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                        <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                            <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束(此处做一个简单的判断:超过0字节就认为请求结束了)</span><br>                            <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                        requestBuffer.flip();<br>                        <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                        requestBuffer.get(content);<br>                        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                        System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span> + socketChannel.getRemoteAddress());<br>                        <span class="hljs-comment">// TODO 业务操作 数据库 接口调用等等</span><br><br>                        <span class="hljs-comment">// 响应结果 200</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                                <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                                <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                            socketChannel.write(buffer);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        <span class="hljs-comment">// e.printStackTrace();</span><br>                        key.cancel(); <span class="hljs-comment">// 取消事件订阅</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            selector.selectNow();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题: 此处一个selector监听所有事件,一个线程处理所有请求事件. 会成为瓶颈! 要有多线程的运用</p><h2 id="五-NIO-对比-BIO"><a href="#五-NIO-对比-BIO" class="headerlink" title="五 : NIO 对比 BIO"></a>五 : NIO 对比 BIO</h2><p>BIO 线程模型</p><p><img src="/../java/image-2020071002.png"> </p><ul><li>阻塞 IO , 线程等待时间长</li><li>一个线程负责一个连接处理</li><li>线程多且利用率低</li></ul><p>NIO 线程模型</p><p><img src="/../java/image-2020071003.png"> </p><ul><li>非阻塞 IO , 线程利用率更高</li><li>一个线程处理多个连接事件</li><li>性能更强大</li></ul><p>总结 : 如果你的程序需要支撑大量的连接, 使用 NIO 是最好的方式; Tomcat8 中, 已经完全取出 BIO 相关的网络处理代码, 默认采用 NIO 进行网络处理</p><h2 id="六-NIO-与多线程结合的改进方案"><a href="#六-NIO-与多线程结合的改进方案" class="headerlink" title="六 : NIO 与多线程结合的改进方案"></a>六 : NIO 与多线程结合的改进方案</h2><p>Doug Lea 的著名文章《Scalable IO in Java》; 地址 : <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p><strong>Worker Thread Pools</strong> : Reactor 线程接收请求 &#x3D;&gt; 分发给线程池处理请求</p><p><img src="/../java/image-2020071004.png"> </p><p><strong>Using Multiple Reactors</strong> : mainReactor 接收 &#x3D;&gt; 分发给 subReactor 读写 &#x3D;&gt; 具体业务逻辑分发给单独的线程池处理</p><p><img src="/../java/image-2020071005.png"> </p><p>代码示例 : NIO selector 多路复用reactor线程模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServerV3</span> &#123;<br>    <span class="hljs-comment">/** 处理业务操作的线程 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">workPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装了selector.select()等事件轮询的代码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        Selector selector;<br>        LinkedBlockingQueue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Selector监听到有事件后,调用这个方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">ReactorThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            selector = Selector.open();<br>        &#125;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 轮询Selector事件</span><br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 执行队列中的任务</span><br>                    Runnable task;<br>                    <span class="hljs-keyword">while</span> ((task = taskQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    selector.select(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">// 获取查询结果</span><br>                    Set&lt;SelectionKey&gt; selected = selector.selectedKeys();<br>                    <span class="hljs-comment">// 遍历查询结果</span><br>                    Iterator&lt;SelectionKey&gt; iter = selected.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-comment">// 被封装的查询结果</span><br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> key.readyOps();<br>                        <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>                        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">SelectableChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SelectableChannel) key.attachment();<br>                                channel.configureBlocking(<span class="hljs-literal">false</span>);<br>                                handler(channel);<br>                                <span class="hljs-keyword">if</span> (!channel.isOpen()) &#123;<br>                                    key.cancel(); <span class="hljs-comment">// 如果关闭了,就取消这个KEY的订阅</span><br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                                key.cancel(); <span class="hljs-comment">// 如果有异常,就取消这个KEY的订阅</span><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    selector.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-comment">// 为什么register要以任务提交的形式，让reactor线程去处理？</span><br>            <span class="hljs-comment">// 因为线程在执行channel注册到selector的过程中，会和调用selector.select()方法的线程争用同一把锁</span><br>            <span class="hljs-comment">// 而select()方法实在eventLoop中通过while循环调用的，争抢的可能性很高，为了让register能更快的执行，就放到同一个线程来处理</span><br>            FutureTask&lt;SelectionKey&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; channel.register(selector, <span class="hljs-number">0</span>, channel));<br>            taskQueue.add(futureTask);<br>            <span class="hljs-keyword">return</span> futureTask.get();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!running) &#123;<br>                running = <span class="hljs-literal">true</span>;<br>                start();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel serverSocketChannel;<br>    <span class="hljs-comment">// 1、创建多个线程 - accept处理reactor线程 (accept线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] mainReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 2、创建多个线程 - io处理reactor线程  (I/O线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] subReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">8</span>];<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化线程组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newGroup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建IO线程,负责处理客户端连接以后socketChannel的IO读写</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subReactorThreads.length; i++) &#123;<br>            subReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    <span class="hljs-comment">// work线程只负责处理IO处理，不处理accept事件</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (SocketChannel) channel;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (ch.isOpen() &amp;&amp; ch.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到数据,来自：&quot;</span> + ch.getRemoteAddress());<br><br>                    <span class="hljs-comment">// TODO 业务操作 数据库、接口...</span><br>                    workPool.submit(() -&gt; &#123;<br>                    &#125;);<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        ch.write(buffer);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建mainReactor线程, 只负责处理serverSocketChannel</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mainReactorThreads.length; i++) &#123;<br>            mainReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">incr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 只做请求分发，不做具体的数据读取</span><br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (ServerSocketChannel) channel;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ch.accept();<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 收到连接建立的通知之后，分发给I/O线程继续去读取数据</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> incr.getAndIncrement() % subReactorThreads.length;<br>                    <span class="hljs-type">ReactorThread</span> <span class="hljs-variable">workEventLoop</span> <span class="hljs-operator">=</span> subReactorThreads[index];<br>                    workEventLoop.doStart();<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> workEventLoop.register(socketChannel);<br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                &#125;<br>            &#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化channel,并且绑定一个eventLoop线程</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、 创建ServerSocketChannel</span><br>        serverSocketChannel = ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 2、 将serverSocketChannel注册到selector</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(mainReactorThreads.length);<br>        mainReactorThreads[index].doStart();<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> mainReactorThreads[index].register(serverSocketChannel);<br>        selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定端口</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//  1、 正式绑定端口，对外服务</span><br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        System.out.println(<span class="hljs-string">&quot;启动完成，端口8080&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NIOServerV3</span> <span class="hljs-variable">nioServerV3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NIOServerV3</span>();<br>        <span class="hljs-comment">// 1.创建main和sub两组线程</span><br>        nioServerV3.newGroup(); <br>        <span class="hljs-comment">// 2.创建serverSocketChannel，注册到mainReactor线程上的selector上</span><br>        nioServerV3.initAndRegister();<br>        <span class="hljs-comment">// 3.为serverSocketChannel绑定端口</span><br>        nioServerV3.bind(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七 : 小结"></a>七 : 小结</h2><p>NIO 为开发者提供了功能丰富及强大的 IO 处理 API, 但是在应用于网络应用开发的过程中, 直接使用 JDK 提供的 API, 比较繁琐; 而且要想将性能进行提升, 光有 NIO 还不够, 还需要将多线程技术与之结合起来</p><p>因为网络编程本身的复杂性, 以及 JDK API 开发的使用难度较高, 所以在开源社区中, 捅出来很多 JDK NIO 进行封装, 增强后的网络编程框架, 例如 : Netty, Mina等 </p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIO阻塞式网络编程</title>
    <link href="/2020/07/03/BIO/"/>
    <url>/2020/07/03/BIO/</url>
    
    <content type="html"><![CDATA[<h2 id="一-简单-C-x2F-S-程序"><a href="#一-简单-C-x2F-S-程序" class="headerlink" title="一 : 简单 C&#x2F;S 程序"></a>一 : 简单 C&#x2F;S 程序</h2><p>服务端示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<span class="hljs-comment">// 阻塞</span><br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 接收数据、打印</span><br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream(); <span class="hljs-comment">// net + i/o</span><br>                <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                String msg;<br>                <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 没有数据，阻塞</span><br>                    <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    System.out.println(msg);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    request.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOClient</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> s.getOutputStream();<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        out.write(msg.getBytes(charset)); <span class="hljs-comment">// 阻塞，写完成</span><br>        scanner.close();<br>        s.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-Http-协议"><a href="#二-Http-协议" class="headerlink" title="二 : Http 协议"></a>二 : Http 协议</h2><p>代码示例(和浏览器交互)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用多线程技术</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;tomcat 服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 接收数据、打印</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    String msg;<br>                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 阻塞</span><br>                        <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        System.out.println(msg);<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        request.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求数据包解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一部分: 请求行,请求类型,资源路径以及HTTP版本</span><br>GET /servlet-demo-1.0.0/index HTTP/1.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二部分: 请求头部,紧接着请求行(即第一行)之后的部分,用来说明服务器要使用的附加信息</span><br>Cache-Control: max-age=O<br>Accept: text/html<br>Accept-Language: zh-Hans-CN,zh-Hans;q=0.5<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Chrome/64.0.3282.140<br>Accept-Encoding: gzip, deflate<br>Host: 127.0.0.1:8080<br>Connection: Keep-Alive<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三部分: 空行,请求头部后面的空行是必须的请求头部和数据主体之间必须有换行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第四部分: 请求数据也叫主体,可以添加任意的数据(没有则不显示)</span><br></code></pre></td></tr></table></figure><p>响应数据包解析 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一部分: 状态行。HTTP版本、状态码、状态消息</span><br>HTTP/1.1 200 OK<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二部分: 响应报头部,紧接着请求行（即第一行)之后的部分,用来说明服务器要使用的附加信息</span><br>Content-Length: 11<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三部分:空行,头部后面的空行是必须的头部和数据主体之间必须有换行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第四部分:响应正文。可以添加任意的数据。例如“Hello World”</span><br>Hello World<br></code></pre></td></tr></table></figure><p>响应状态码</p><table><thead><tr><th>状态码</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>临时响应</td><td>表示临时响应并需要请求者继续执行操作的状态代码</td></tr><tr><td>2xx</td><td>成功</td><td>表示成功处理了请求的状态代码</td></tr><tr><td>3xx</td><td>重定向</td><td>表示要完成请求,需要进一步操作; 通常这些状态代码用来重定向</td></tr><tr><td>4xx</td><td>请求错误</td><td>这些状态代码表示请求可能出错,妨碍了服务器的处理</td></tr><tr><td>5xx</td><td>服务器错误</td><td>这些状态码表示服务器在尝试处理请求时发生内部错误; 这些错误可能是服务器本身的错误, 而不是请求出错</td></tr></tbody></table><h2 id="三-服务端升级版"><a href="#三-服务端升级版" class="headerlink" title="三 : 服务端升级版"></a>三 : 服务端升级版</h2><p>代码示例(和浏览器交互, 返回 Http 内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 接收数据、打印</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    String msg;<br>                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        System.out.println(msg);<br>                    &#125;<br><br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> request.getOutputStream();<br>                    outputStream.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>                    outputStream.write(<span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span>.getBytes());<br>                    outputStream.write(<span class="hljs-string">&quot;Hello World&quot;</span>.getBytes());<br>                    outputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        request.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-BIO-阻塞IO的含义"><a href="#四-BIO-阻塞IO的含义" class="headerlink" title="四 : BIO - 阻塞IO的含义"></a>四 : BIO - 阻塞IO的含义</h2><p><strong>阻塞(blocking) IO</strong> : 资源不可用时, IO 请求一致阻塞, 直到反馈结果(有数据或超时)</p><p><strong>非阻塞(non-blocking) IO</strong> : 资源不可用时, IO 请求离开返回, 返回数据标识资源不可用</p><p><strong>同步(synchronous) IO</strong> : 应用阻塞在发送或接受数据的状态, 直到数据成功传输或返回失败</p><p><strong>异步(asynchronous) IO</strong> : 应用发送或接受数据后立刻返回, 实际处理时异步执行的</p><p><strong>总结</strong> : 阻塞和非阻塞是<u>获取资源</u>的方式, 同步和异步是程序如何<u>处理资源</u>的逻辑设计; </p><ul><li>代码中使用的 API: ServerSocket#accept, InputStream#read 都是阻塞的 API</li><li>操作系统地层 API 中, 默认 Socket 操作都是 Blocking 型, send&#x2F;recv 等接口都是阻塞的</li></ul><p><strong>带来的问题</strong> : 阻塞导致在处理网络 I&#x2F;O 时, 一个线程只能处理一个网络连接</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/UDP协议</title>
    <link href="/2020/06/19/TCP&amp;UDP/"/>
    <url>/2020/06/19/TCP&amp;UDP/</url>
    
    <content type="html"><![CDATA[<h2 id="一-OSI-网络七层模型"><a href="#一-OSI-网络七层模型" class="headerlink" title="一 : OSI 网络七层模型"></a>一 : OSI 网络七层模型</h2><p>为使不同计算机厂家的计算机能够互相通信, 以便在更大的范围内建立计算机网络, 有必要建立一个国际范围的网络体系结构标准</p><p><img src="/../java/image-2020061901.png" alt="OSI 网络七层模型"> </p><p>也就是说 101010111100 中包含的数据内容为 : MAC 头部 + LLC 头部 + IP 头部 + TCP 头部 + 数据</p><h2 id="二-各层的主要功能"><a href="#二-各层的主要功能" class="headerlink" title="二 : 各层的主要功能"></a>二 : 各层的主要功能</h2><p><strong>低三层</strong> </p><ul><li>物理层 : 使原始的数据比特流能在物理介质上传输</li><li>数据链路层 : 通过校验, 确认和反馈重发等手段, 形成稳定的数据链路(01010101)</li><li>网络层 : 进行路由选择和流量控制(IP 协议)</li></ul><p><strong>中间层</strong></p><ul><li>传输层 : 提供可靠的端口到端口的数据传输服务(TCP&#x2F;UDP协议)</li></ul><p><strong>高三层</strong></p><ul><li>会话层 : 负责建立 , 管理和终止进程之间的会话和数据交换</li><li>表示层 : 负责数据格式转换, 数据加密与解密, 压缩与解压缩等</li><li>应用层 : 为用户的应用进程提供网络服务</li></ul><h2 id="三-传输控制协议-TCP"><a href="#三-传输控制协议-TCP" class="headerlink" title="三 : 传输控制协议 TCP"></a>三 : 传输控制协议 TCP</h2><p>传输控制协议(TCP) 使 Internet 一个重要的传输层协议; TCP 提供面向连接, 可靠, 有序, 字节流传输服务; 应用程序在使用 TCP 之前, 必须先建立 TCP 连接</p><p><img src="/../java/image-2020061902.png"> </p><p>标志位说明</p><table><thead><tr><th>标志位</th><th>说明</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针</td></tr><tr><td><strong>ACK</strong></td><td>确认序号</td></tr><tr><td>PSH</td><td>有 DATA 数据传输</td></tr><tr><td>RST</td><td>连接重置</td></tr><tr><td><strong>SYN</strong></td><td>建立连接</td></tr><tr><td><strong>FIN</strong></td><td>关闭连接</td></tr></tbody></table><h2 id="四-TCP-握手机制"><a href="#四-TCP-握手机制" class="headerlink" title="四 : TCP 握手机制"></a>四 : TCP 握手机制</h2><p>三次握手过程</p><p><img src="/../java/image-2020061903.png" alt="三次握手">  </p><p>四次挥手过程</p><p><img src="/../java/image-2020061904.png" alt="四次挥手"> </p><h2 id="五-用户数据报协议-UDP"><a href="#五-用户数据报协议-UDP" class="headerlink" title="五 : 用户数据报协议 UDP"></a>五 : 用户数据报协议 UDP</h2><p>用户数据报协议 UDP 是 Internet 传输层协议; 提供无连接, 不可靠, 数据报尽力传输服务</p><p><img src="/../java/image-2020061905.png" alt="UDP数据结构"> </p><p>开发应用人员在 <strong>UDP 上构建应用, 关注以下几点 :</strong> </p><ol><li>应用进程更容易控制发送什么数据以及何时发送</li><li>无需建立连接</li><li>无连接状态</li><li>首部开销小</li></ol><h2 id="六-UDP-和-TCP-比较"><a href="#六-UDP-和-TCP-比较" class="headerlink" title="六 : UDP 和 TCP 比较"></a>六 : UDP 和 TCP 比较</h2><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>无连接</td></tr><tr><td>提供可靠性保证</td><td>不可靠</td></tr><tr><td>慢</td><td>快</td></tr><tr><td>资源占用多</td><td>资源占用少</td></tr></tbody></table><p>什么时候会用到UDP呢? 对数据可靠性要求不高的情况, 例如音视频聊天, 物联网数据上报之类; 也就是说我们的关注点是现在发生了什么而不是过去发生了什么</p><h2 id="七-Socket-编程"><a href="#七-Socket-编程" class="headerlink" title="七 : Socket 编程"></a>七 : Socket 编程</h2><p>Internet 中应用最广泛的网络应用编程接口, 实现与 3 种底层协议接口:</p><ul><li>数据报类型套接字 SOCK_DGRAM (面向 UDP 接口)</li><li>流式套接字 SOCK_STREAM (面向 TCP 接口)</li><li>原始套接字 SOCK_RAW (面向网络层协议接口 IP, ICMP 等)</li></ul><p>主要 socket API 及其调用过程 :</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">创建套接字 <span class="hljs-operator">=</span>&gt; 端点绑定 <span class="hljs-operator">=</span>&gt; 发送数据 <span class="hljs-operator">=</span>&gt; 接收数据 <span class="hljs-operator">=</span>&gt; 释放套接字<br></code></pre></td></tr></table></figure><p>Socket API 函数定义</p><ul><li>listen(), accept() 函数只能用于服务器端</li><li>connect() 函数只能用于客户端</li><li>socket(), bind(), send(), recv(), sendto(), recvfrom(), close()</li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发网络编程</tag>
      
      <tag>NIO网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FutureTask源码剖析</title>
    <link href="/2020/06/12/FutureTask/"/>
    <url>/2020/06/12/FutureTask/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Future"><a href="#一-Future" class="headerlink" title="一 : Future"></a>一 : Future</h2><p>Future 表示异步计算的结果, 提供了用于检查计算是否完成, 等待计算完成以及获取结果的方法</p><p><img src="/../java/image-2020061201.png" alt="image-2020061201"></p><p>Future 和 Callable</p><ol><li><p>Callable 和 Runnable 一样的业务定义, 但本质上有区别(返回值, 异常定义), 表面的区别并不是最重要的, 重要的是我们要看内在, <strong>内在的一个本质上的点是 Callable 是被 Runnable 调用的, 也就是说 <code>call()</code> 运行在 <code>run()</code> 里面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread并不能传入Callable, 但是我们可以通过FutureTask来使用callable</span><br>Callable&lt;Object&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callalbe</span>&lt;Object&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object call <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>FutureTask&lt;Object&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当然也可以用线程池直接使用</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>executorService.submit(callable);<br></code></pre></td></tr></table></figure></li><li><p>在线程执行完后可以直接在 futureTask 中拿结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">futureTask.get();<br></code></pre></td></tr></table></figure></li></ol><h2 id="二-FutureTask-应用"><a href="#二-FutureTask-应用" class="headerlink" title="二 : FutureTask 应用"></a>二 : FutureTask 应用</h2><p><img src="/../java/image-2020061202.png" alt="image-2020061202"> </p><p>总的执行时间, 取决于执行最慢的逻辑</p><p>逻辑之间无依赖关系, 可同时执行, 则可以应用<strong>多线程技术进行优化</strong></p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceFutureTask</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-comment">// Future &lt; &gt;  Callable</span><br>        <span class="hljs-comment">// 和runnable一样的业务定义,但是本质上是有区别的: 返回值 异常 call run.</span><br>        Callable&lt;JSONObject&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;JSONObject&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-comment">// 1. 先从调用获取用户基础信息的http接口</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://www.tony.com/userinfo-api/get?userId=&quot;</span> + userId, String.class);<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(value);<br>                System.out.println(<span class="hljs-string">&quot;userinfo-api用户基本信息接口调用时间为&quot;</span> + (System.currentTimeMillis() - userinfoTime));<br>                <span class="hljs-keyword">return</span> userInfo;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 通过多线程运行callable</span><br>        FutureTask&lt;JSONObject&gt; userInfoFutureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(userInfoFutureTask).start();<br><br>        FutureTask&lt;JSONObject&gt; intergralInfoTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 2. 再调用获取用户积分信息的接口</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">integralApiTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">intergral</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://www.tony.com/integral-api/get?userId=&quot;</span> + userId,<br>                    String.class);<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">intergralInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(intergral);<br>            System.out.println(<span class="hljs-string">&quot;integral-api积分接口调用时间为&quot;</span> + (System.currentTimeMillis() - integralApiTime));<br>            <span class="hljs-keyword">return</span> intergralInfo;<br>        &#125;);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(intergralInfoTask).start();<br><br>        <span class="hljs-comment">// 3. 合并为一个json对象</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        result.putAll(userInfoFutureTask.get()); <span class="hljs-comment">// 会等待任务执行结束</span><br>        result.putAll(intergralInfoTask.get());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-线程安全性级别"><a href="#三-线程安全性级别" class="headerlink" title="三 : 线程安全性级别"></a>三 : 线程安全性级别</h2><p>《Effective Java》- Joshua J.Block 提到, 工具类需要显示的说明它的安全性级别 :</p><ol><li><strong>不可变的</strong> : 这个类的实例是不可变的; 这样的例子包括 String, Long, BigInteger</li><li><strong>无条件的线程安全</strong> : 这个类的实例是可变的, 但是这个类有组偶的内部同步; 例子包括 Random, ConcurrentHashMap</li><li><strong>有条件的线程安全</strong> : 除了有些方法为进行安全的并发使用而需要外部同步之外, 这种线程安全级别与无条件相同; 例如包括: Collections.synchronized 包装返回的集合, 他们的迭代器要求外部同步</li><li><strong>非线程安全</strong> : 这个类的实例是可变的; 为了并发使用它们, 客户必须利用自己选择的外部同步包围每个方法调用, 例子包括 ArrayList</li><li><strong>线程对立</strong> : 这个类不能安全地被多个线程并发使用, 即使所有的方法调用都被外围同步包围</li></ol><h2 id="四-JDK-学习思路汇总"><a href="#四-JDK-学习思路汇总" class="headerlink" title="四 : JDK 学习思路汇总"></a>四 : JDK 学习思路汇总</h2><p>积累 : 由基层知识再到封装的工具类, 足够多的 “因” 才能推理出 “果”; 基层不代表基础, 不代表简单;</p><p>思路 : 从顶层看使用, 从底层看原理</p><p>结语 : 多线程编程中, 不变的是<strong>内存模型</strong>和<strong>线程通信</strong>两个核心技术点, 变化的是各种程序设计想法(算法)</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fork/Join并发处理框架</title>
    <link href="/2020/06/05/Fork&amp;Join/"/>
    <url>/2020/06/05/Fork&amp;Join/</url>
    
    <content type="html"><![CDATA[<h2 id="一-用来做什么"><a href="#一-用来做什么" class="headerlink" title="一 : 用来做什么"></a>一 : 用来做什么</h2><p>ForkJoinPool 是 ExecutorService 接口的实现, 它专为可以递归分解成小块的工作而设计; </p><p>fork&#x2F;join 框架将任务分配给线程池中的工作线程, 充分利用多处理器的优势, 提高程序性能</p><p>使用 fork&#x2F;join 框架的第一步是编写执行一部分工作的代码; 类似的伪代码如下</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">如果<span class="hljs-comment">(当前工作部分足够小)</span><br>直接做这项工作<br>其他<br>把当前工作分成两部分<br>调用这两个部分并等待结果<br></code></pre></td></tr></table></figure><p>将此代码包装在 ForkJoinTask 子类中, 通常是 RecursiveTask (可以返回结果) 或 RecursiveAction</p><h2 id="二-意图梳理"><a href="#二-意图梳理" class="headerlink" title="二 : 意图梳理"></a>二 : 意图梳理</h2><p>关键点 :  : 分解任务fork出新任务, 汇集join任务执行结果</p><pre><code class=" mermaid">graph TD提交任务 --&gt; ForkJoinTaskForkJoinTask --fork--&gt; process-1process-1 --&gt; process-1.1process-1 --&gt; process-1.2ForkJoinTask --fork--&gt; process-2process-2 --&gt; process-2.1process-2 --&gt; process-2.2process-2.1 -. join .-&gt; process-2process-2.2 -. join .-&gt; process-2</code></pre><h2 id="三-经典网关场景-查询多个系统数据"><a href="#三-经典网关场景-查询多个系统数据" class="headerlink" title="三 : 经典网关场景, 查询多个系统数据"></a>三 : 经典网关场景, 查询多个系统数据</h2><p>移动互联网的情况</p><ul><li>一个接口请求要获取很多信息</li><li>后端分布式系统, 拆分成多个子系统</li></ul><p>后端接口执行(大概流程)</p><ol><li>收到一个请求</li><li>调用多个服务接口获取其他系统的数据</li><li>最后汇总返回</li></ol><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-comment">// 1. 先从调用获取用户基础信息的http接口</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://172.16.0.1/userinfo-api/get?userId=&quot;</span> + userId, String.class);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(value);<br>        System.out.println(<span class="hljs-string">&quot;userinfo-api用户基本信息接口调用时间为&quot;</span> + (System.currentTimeMillis() - userinfoTime));<br><br>        <span class="hljs-comment">// 2. 再调用获取用户积分信息的接口</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">integralApiTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">intergral</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://172.16.0.1/integral-api/get?userId=&quot;</span> + userId,<br>                String.class);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">intergralInfo</span> <span class="hljs-operator">=</span> JSONObject.parseObject(intergral);<br>        System.out.println(<span class="hljs-string">&quot;integral-api积分接口调用时间为&quot;</span> + (System.currentTimeMillis() - integralApiTime));<br><br>        <span class="hljs-comment">// 再调用一个接口 +n秒</span><br><br>        <span class="hljs-comment">// 3. 合并为一个json对象</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        result.putAll(userInfo);<br>        result.putAll(intergralInfo);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意 : 代码逻辑涉及到串行的过程, 运行时间会发生累计, 随着需要调用的接口的数量的增多, 响应时间会越来越长</p><p>针对于<strong>响应时间限制</strong>, 通常开发公司会有明确规定, 例如 : 内部调用的核心接口的响应时间通常为10ms, 对外可以扩展到50ms</p><p>代码优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpJsonRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;JSONObject&gt; &#123;<br><br>    RestTemplate restTemplate;<br>    ArrayList&lt;String&gt; urls;<br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br><br>    HttpJsonRequest(RestTemplate restTemplate, ArrayList&lt;String&gt; urls, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>        <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>        <span class="hljs-built_in">this</span>.urls = urls;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-comment">// 就是实际去执行的一个方法入口(任务拆分)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> JSONObject <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> end - start; <span class="hljs-comment">// 代表当前这个task需要处理多少数据</span><br>        <span class="hljs-comment">// 自行根据业务场景去判断是否是大任务,是否需要拆分</span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.get(start);<br>            <span class="hljs-comment">// TODO 如果只有一个接口调用,立刻调用</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">userinfoTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> restTemplate.getForObject(url, String.class);<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> JSONObject.parseObject(response);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 接口调用完毕&quot;</span> + (System.currentTimeMillis() - userinfoTime) + <span class="hljs-string">&quot; #&quot;</span> + url);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果是多个接口调用,拆分成子任务  7,8,   9,10</span><br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;任务拆分一次&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, start, x);<span class="hljs-comment">// 负责处理哪一部分?</span><br>            httpJsonRequest.fork();<br><br>            <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, x + <span class="hljs-number">1</span>, end);<span class="hljs-comment">// 负责处理哪一部分?</span><br>            httpJsonRequest1.fork();<br><br>            <span class="hljs-comment">// join获取处理结果</span><br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            result.putAll(httpJsonRequest.join());<br>            result.putAll(httpJsonRequest1.join());<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并行调用http接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceForkJoin</span> &#123;<br>    <span class="hljs-comment">// 本质是一个线程池,默认的线程数量:CPU的核数</span><br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">10</span>, ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>            <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询多个系统的数据，合并返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// fork/join</span><br>        <span class="hljs-comment">// forkJoinPool.submit()</span><br>        ArrayList&lt;String&gt; urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        urls.add(<span class="hljs-string">&quot;http://172.16.0.1/userinfo-api/get?userId=&quot;</span> + userId);<br>        urls.add(<span class="hljs-string">&quot;http://172.16.0.1/integral-api/get?userId=&quot;</span> + userId);<br><br>        <span class="hljs-type">HttpJsonRequest</span> <span class="hljs-variable">httpJsonRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpJsonRequest</span>(restTemplate, urls, <span class="hljs-number">0</span>, urls.size() - <span class="hljs-number">1</span>);<br>        ForkJoinTask&lt;JSONObject&gt; forkJoinTask = forkJoinPool.submit(httpJsonRequest);<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinTask.get();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-实现思路"><a href="#四-实现思路" class="headerlink" title="四 : 实现思路"></a>四 : 实现思路</h2><p>每个 Worker 线程都维护一个任务队列, 即 ForkJoinWorkerThread 中的任务队列</p><p>任务队列是双向队列, 这样可以同时实现 LIFO(last in first out, 后进先出) 和 FIFO(first in first out, 先进先出)</p><p>子任务会被加入到原先任务所在 worker 线程的任务队列(workQueue); worker 线程用 LIFO 的方法取出任务, 后进队列的任务先取出来(子任务总是后加入队列, 但是需要先执行); <strong>当任务队列为空, 会随机从其他的 worker 的队列中拿走一个任务执行</strong>(工作窃取: steal work);</p><p>如果一个 worker 线程遇到了 join 操作, 而这时候, 正在处理其他任务, 会等到这个任务结束; 否则直接返回</p><p>如果一个 worker 线程窃取任务失败, 它会用 yield 或者 sleep 之类的方法休息一会儿, 再尝试(如果所有线程都是空闲状态, 即没有任务运行, 那么该线程也会进入阻塞状态等待新任务的到来)</p><h2 id="五-适用"><a href="#五-适用" class="headerlink" title="五 : 适用"></a>五 : 适用</h2><p><strong>使用尽可能少的线程池</strong> : 再大多数情况下, 最好的决定是为每个应用程序或系统使用一个线程池</p><p>如果不需要特定调整, 请使用默认的公共线程池</p><p>使用合理的阈值将 ForkJoinTask 拆分为子任务</p><p>避免在 ForkJoinTask 中出现任何阻塞</p><p><strong>适用场景</strong> : 数据处理, 结果汇总, 统计等; </p><p><strong>java8实例 :</strong> java.util.Arrays 类用于其 parallelSort() 方法就用到了 fork&#x2F;join; 其目的是进行内存运算方面的操作, 因此<strong>不适合</strong>用于网络接口调用, 数据库查询, 文件操作等; 所以如果需要使用, 只定义一个 ForkJoinPool 就好, 线程数量尽量和 CPU 核数差不多, 主要进行非阻塞的代码处理</p><h2 id="六-结语"><a href="#六-结语" class="headerlink" title="六 : 结语"></a>六 : 结语</h2><p>总结 :</p><ol><li>本质上是一个线程池, 如果需要使用, 只需要定义一个 ForkJoinPool 即可</li><li>线程数量尽量和 CPU 核心数差不多; 例如 8 核 CPU 就设置 8 个线程</li><li>适用于非阻塞(non blocking)的代码处理; 如网络接口调用, 数据库查询, 文件操作等操作<strong>并不适用</strong></li></ol><p>工作窃取带来的性能提升偏理论, API 的复杂性高, 实际研发中可控性来说不如其他 API, <strong>非内存操作并不适用</strong></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器类(二)</title>
    <link href="/2020/05/29/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB2/"/>
    <url>/2020/05/29/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB2/</url>
    
    <content type="html"><![CDATA[<h2 id="一-List"><a href="#一-List" class="headerlink" title="一 : List"></a>一 : List</h2><p>单纯的 List 如果实际操作过程中, 不可以一边遍历一边删除, 这时就可以用到 CopyOnWriteArrayList</p><p>CopyOnWriteArrayList 容器即<strong>写时复制</strong>的容器, 实现原理 :</p><ol><li>对当前 List 加锁</li><li>将原先的 array 复制一个新的数组(newElements)</li><li>对复制的数组进行修改</li><li>对原有数组进行替换</li></ol><p>和 ArrayList 比较, 优点是并发安全, 缺点有两个 :</p><ol><li>多了内存占用: 写数据是 copy 一份完整的数据, 单独进行操作; 占用双份内存</li><li>数据一致性: 数据写完之后, 其他线程不一定是马上读取到最新内容</li></ol><h2 id="二-Set"><a href="#二-Set" class="headerlink" title="二 : Set"></a>二 : Set</h2><p>set 和 list 重要区别 : <strong>不重复</strong>; 重要 API 实现原理及特点</p><table><thead><tr><th>实现</th><th>原理</th><th>特点</th></tr></thead><tbody><tr><td>HashSet</td><td>通过 HashMap 进行存储, 将 value 作为 key, 从而实现了 Set 数据不重复的作用</td><td>非线程安全</td></tr><tr><td>CopyOnWriteArraySet</td><td>基于 CopyOnWriteArrayList</td><td>线程安全</td></tr><tr><td>ConcurrentSkipListSet</td><td>基于 ConcurrentSkipListMap</td><td>线程安全, 有序, 查询快</td></tr></tbody></table><h2 id="三-Queue"><a href="#三-Queue" class="headerlink" title="三 : Queue"></a>三 : Queue</h2><p>重要 API 介绍</p><table><thead><tr><th>方法</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>add</td><td>增加一个元素</td><td>如果队列已满, 则抛出一个 illealStateException 异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空, 则抛出一个 NoSuchElementException 异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空, 则抛出一个 NoSuchElementException 异常</td></tr><tr><td>offer</td><td>添加一个元素并返回 true</td><td>如果队列已满, 则返回 false</td></tr><tr><td>poll</td><td>移除并返回队列头部的元素</td><td>如果队列为空, 则返回 null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空, 则返回 null</td></tr><tr><td>put</td><td>添加一个元素</td><td><strong>如果队列满, 则阻塞</strong></td></tr><tr><td>take</td><td>移除并返回队列头部的元素</td><td><strong>如果队列为空, 则阻塞</strong></td></tr></tbody></table><p><strong>ArrayBlockingQueue :</strong> 基于数组的阻塞循环队列, 此队列按FIFO(先进先出)原则对元素进行排序; 注意put和offer的区别: put会阻塞, offer不会阻塞直接返回false</p><p><strong>LinkedBlockingQueue :</strong> 基于链表的队列,此队列按 FIFO 排序; 如果有阻塞需求,用这个; 类似生产者消费者模式</p><p><strong>ConcurrentLinkedQueue :</strong> 优势: 无锁; 注意: 批量操作不提供原子性保证(addAll,removeAll,retainAll,containsAll,equals,and toArray); 坑: size() 每次都是便利整个链表,最好不要频繁调用; 如果没有阻塞要求,用这个挺好(堆积数据)</p><p><strong>PriorityQueue :</strong> 是一个带优先级的队列,而不是先进先出; 元素按优先级顺序被移除,该队列也没有上限; 没有容量限制,自动扩容; 虽然在逻辑上是无界的,但是由于资源被耗尽,所以试图执行添加操作可能会导致OutOfMemoryError; 如果队列为空,那么取出元素的take操作就会阻塞,所以它的检索操作take是受阻的; 另外,加入该队列的元素要具有比较能力</p><p><strong>PriorityBlockingQueue :</strong> 封装了 PriorityQueue; 是一个带优先级的队列, 而不是先进先出队列; 元素按优先级顺序被移除, 该队列也没有上限; 没有容量限制的, 自动扩容; 芮苒此队列逻辑上是无界的, 但是由于资源被耗尽, 所以试图执行添加操作可能会导致 OutOfMemoryError; 但如果队列为空, 那么取元素的操作take就会阻塞, 所以它的检索操作take是受阻的; 另外, 加入队列中的元素要具有比较能力</p><p><strong>DelayQueue :</strong> 基于PriorityQueue来实现的, 是一个存放Delayed 元素的无界阻塞队列; 只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素; 如果延迟都还没有期满，则队列没有头部，并且poll将返回null; 当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时; 则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素</p><p><strong>SynchronousQueue :</strong> 这是一个神奇的队列, 因为他不存数据, 手把手的交互数据; 非阻塞方法无效, 只能使用阻塞方法 put&#x2F;take</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器类</title>
    <link href="/2020/05/22/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <url>/2020/05/22/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-学习方法"><a href="#一-学习方法" class="headerlink" title="一 : 学习方法"></a>一 : 学习方法</h2><p><strong>逻辑思维能力是梳理学习方法的基础</strong>; 养成线程思维: 两个或者多个给概念,像一条线串起来</p><p>首先要经过<strong>演绎推导法</strong>进行<strong>因果推理</strong>; 比如java中网络编程只提供了BIO和NIO两种方式, 所以一切框架中, 涉及到网络处理的, 都可以用这两个知识点去探究原理</p><p>然后采用<strong>归纳总结法</strong>提出可能正确的<strong>猜想</strong>; 比如线上10台服务器, 有三台总是每天会自动重启, 收集相关信息后, 发现是运维在修改监控系统配置的时候, 漏掉了提高这三台服务器的重启阈值</p><p>最后要使用<strong>类比法</strong>进行思维固化; 比如<strong>集群</strong>概念就好像是马在拉车,一匹马拉不动的时候,就是用多匹马去拉; <strong>分布式</strong>的概念, 就像是理发的过程中, 洗头发和剪头发是不同的人负责的</p><h2 id="二-推理-HashMap-的实现"><a href="#二-推理-HashMap-的实现" class="headerlink" title="二 : 推理 HashMap 的实现"></a>二 : 推理 HashMap 的实现</h2><p>数据要存储</p><ul><li>涉及到数据结构 : <strong>数组</strong>, <strong>链表</strong>, <strong>栈</strong>, <strong>树</strong>, <strong>队列</strong></li></ul><p>数组的插入和查找</p><ul><li><strong>顺序查找 :</strong> 插入时按先后顺序插入, 查找时轮询扫描进行对比</li><li><strong>二分查找 :</strong> 插入时进行排序; 查找时将 n 个元素分成大致相等的两部分, 减少复杂度</li><li><strong>分块查找 :</strong> 分块查找是二分查找和顺序查找的一种改进</li><li><strong>哈希表 :</strong> 对元素的关键信息进行 hash 计算, 求出下标后直接插入或查找; 常用的实现是除留余数法</li></ul><p>哈希冲突, 数组位置已存在值</p><ul><li>hash(key2) &#x3D; hash(key1); 链地址法; ReHash1(key2) 再次计算 hash;</li></ul><p>合理控制数组和链表的长度</p><ul><li>动态扩容 resize()</li></ul><h2 id="三-HashMap"><a href="#三-HashMap" class="headerlink" title="三 : HashMap"></a>三 : HashMap</h2><p>jdk1.7:</p><ul><li>数据结构 : 数组 + 链表, Entry&lt;K,V&gt;[] table;</li><li>实现原理 : 计算key的hash值,然后根据数组长度进行除留余数法确定数组位置; 如果是存入,先判定key存在不存在,若存在覆盖value的值;若不存在,则放在链表的最后, 如果是读取采用顺序查找法进行比对</li><li>扩容规则 : 初始容量 16, 扩容因子 0.75;<ol><li>如果有初始长度, 则会以最靠近指定长度的2的幂次进行定容,例如: 519则会定为1024</li><li>如果储存的值超过容量的 0.75 倍, 以 2 倍方式进行扩容, 存储的元素会重新排列</li></ol></li></ul><p>jdk1.8:</p><ul><li>数据结构: Node&lt;K,V&gt;[] table; 别以为有啥变化, Node 和 Entry 结构一样; 在jdk1.7的基础上进行了改进,在数据结构上引入了树形结构</li><li>链表阈值8, 最小容量 64<ol><li>如果单个链表容量超过 8, 该链表则自动转为红黑树</li><li>如果链表达到8, 但是数组没有超过 64, 只会 resize 而不会生成树</li></ol></li><li>由于有扩容机制的存在, 所以用到红黑树的概率很低, 同时, 维护树也是对性能的消耗</li></ul><h2 id="四-ConcurrentHashMap"><a href="#四-ConcurrentHashMap" class="headerlink" title="四 : ConcurrentHashMap"></a>四 : ConcurrentHashMap</h2><p>jdk1.7</p><ul><li>数据结构 : Segment&lt;K,V&gt;[] segments;<ul><li>Segment是个啥? 每个存储单元称为segment, 结构上没有任何区别, 但是它继承了ReentrantLock, 每个segment中包含一个 HashEntry[]</li><li>那HashEntry又是个啥? 主要包含hash值, key, value 和 next, 就是HashMap中的Entry呀! 那 Segment 不就是个map吗, 也就是说每个 segment 就是一个 HashMap</li></ul></li><li>设计原理 :<ul><li>也就是说 ConcurrentHashMap 不能扩容,但是 Segment 可以扩容</li><li>这不是有病吗? 这设计太鬼才了! 是否会存在设计过度的嫌疑, 我感觉有点绕弯; Segment 的数量定死就是16个,还高大上的起了个名字叫<strong>分段锁</strong>, 但实质上也就只能支持16个并发量</li><li>既然是为了提高并发操作的安全性, 那我为什么不在每个 HashMap 中的每个 Entry 上加一把锁呢</li></ul></li><li>扩容规则 : 和 HashMap 稍微有些区别, 数组的容量是固定的16个</li></ul><p>jdk1.8</p><ul><li>数据结构 : Node&lt;K,V&gt; table; 数组 + 链表</li><li>初始容量16, 扩容银子 0.75, 阈值也是 8, 最小容量 64</li><li>设计原理 : 设计思路完全改变, 和HashMap是一样的; 那怎么保证线程安全和并发量的? synchronized? Lock接口? CAS?; 查看源码,初始化是通过CAS实现的, put 是 sync</li><li>但是它是怎么保证线程安全的呢?<ol><li>初始化采用 cas 机制</li><li>put 的时候, 如果当前位置为 null, 采用 cas 机制</li><li>如果不为 null, 则使用同步关键字</li></ol></li></ul><h2 id="五-ConcurrentSkipListMap"><a href="#五-ConcurrentSkipListMap" class="headerlink" title="五 : ConcurrentSkipListMap"></a>五 : ConcurrentSkipListMap</h2><p>特点 : <strong>有序链表</strong>实现, <strong>无锁</strong>实现; value 不能为空; 层级越高跳跃性越大, 数据越少, 查询理论变快;</p><p>和 HashMap 的结构完全不一样, 跳表中包含了一个 index, 在 index 中存储 Node 节点的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index</span> &#123;<br>    Node node;<br>    Index right; <span class="hljs-comment">//先比对入口索引, 如果大于入口索引,则向右进行比对</span><br>    Index down;  <span class="hljs-comment">//如果小于右边的索引, 则向下比对</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    String key;<br>    String value;<br>    Node next;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入 Node 节点的时候, 随机创建索引(创建一个随机数, 如果是偶数, 就创建索引); 如果数据量大, 索引量大也会导致查询效率降低, 这时候引入索引分级的概念</p><p>索引分级: 根据生成的随机数的<strong>二进制数的连续为 1 的数量</strong>来确定 level ; 每层的元素, headIndex 固定为所有 node 中最小的</p><p>查找数据时, 按照<strong>先从左到右, 后从上到下</strong>的顺序查找; 时间复杂度O(log n), 空间复杂度O(n); 性能提升思路就是常说的空间换时间, 数据库索引类似的概念, skiplist 在很多开源组件中有使用 (level DB, Redis)</p><p>关于线程安全方面, 依然还是采用 CAS 机制</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程工具类</title>
    <link href="/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Semaphore"><a href="#一-Semaphore" class="headerlink" title="一 : Semaphore"></a>一 : Semaphore</h2><p>又称<strong>信号量</strong>, 控制多个线程争抢许可</p><p>核心API : </p><ul><li>acquire : 获取一个许可, 如果没有就等待</li><li>release : 释放一个许可</li><li>availablePermits : 方法得到可用的数目</li></ul><p><strong>经典场景 :</strong> 代码并发处理限流</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 4个客人2个技师</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;来到红浪漫, 现有技师: &quot;</span> + semaphore.availablePermits());<br>                    <span class="hljs-keyword">if</span> (semaphore.availablePermits() == <span class="hljs-number">0</span>) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;没技师了...&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 开始等</span><br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;有技师, 准备按摩...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000L</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;按摩结束, 离开...&quot;</span>);<br>                    semaphore.release();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;, i + <span class="hljs-string">&quot;哥: &quot;</span>).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-CountDownLatch"><a href="#二-CountDownLatch" class="headerlink" title="二 : CountDownLatch"></a>二 : CountDownLatch</h2><p>java1.5 被引入的一个工具类, 常被成为<strong>倒计数器</strong>; 创建对象时, 传入指定数值作为线程参与的数量</p><p>API</p><ul><li>await : 方法等待计数器值变为 0, 在这之前, 线程进入等待状态</li><li>countdown : 计数器数值减一, 直到为 0</li></ul><p><strong>适用场景 :</strong> 经常用于等待其他线程执行到某一节点, 再继续执行当前线程代码</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 4个运动员赛跑,未比完人数为0时,公布成绩</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: 起跑...&quot;</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> + random.nextInt(<span class="hljs-number">3</span>);<br>                    Thread.sleep(s * <span class="hljs-number">1000L</span>);<br>                    countDownLatch.countDown();<br>                    record.put(Thread.currentThread().getName(), s);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: 跑完了...&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;, i + <span class="hljs-string">&quot;号运动员&quot;</span>).start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<br>            System.out.println(<span class="hljs-string">&quot;比赛结束, 公布成绩: &quot;</span> + record.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实场景</p><ol><li>统计线程执行情况</li><li>压力测试中, 使用 countDownLatch 实现最大程度的并发处理</li><li>多线程之间, 相互通信, 比如线程异步调用完接口, 结果通知</li></ol><h2 id="三-CyclicBarrier"><a href="#三-CyclicBarrier" class="headerlink" title="三 : CyclicBarrier"></a>三 : CyclicBarrier</h2><p>java1.5 加入, 又称为<strong>线程栅栏</strong>; 创建对象时, 指定展览线程数量</p><p>API</p><ul><li>await : 等指定数量的线程都处于等待状态时, 继续执行后续代码</li><li>barrierAction : 线程数量到了指定量之后, 自动出发执行指定任务</li></ul><p>和 CountDownLatch 重要区别在于, CyclicBarrier 对象可以多次出发执行</p><p><strong>经典场景 :</strong></p><ol><li>数据量比较大时, 实现批量插入数据到数据库</li><li>数据统计, 30 个线程统计 30 天数据, 全部统计完毕后, 执行汇总</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS抽象队列同步器</title>
    <link href="/2020/05/08/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <url>/2020/05/08/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-同步锁的本质-排队"><a href="#一-同步锁的本质-排队" class="headerlink" title="一 : 同步锁的本质 - 排队"></a>一 : 同步锁的本质 - 排队</h2><p>同步的方式 : 独享锁 - 单个队列窗口, 共享锁 - 多个队列窗口</p><p>抢锁的方式 : 公平锁(先来后到抢锁), 非公平锁(插队抢)</p><p>没抢到锁的处理方式 : 快速尝试多次(CAS自旋), 阻塞等待</p><p>唤醒阻塞线程的方式(叫号器) : 全部通知, 通知下一个</p><h2 id="二-AQS-抽象队列同步器"><a href="#二-AQS-抽象队列同步器" class="headerlink" title="二 : AQS 抽象队列同步器"></a>二 : AQS 抽象队列同步器</h2><p>提供了对资源占用, 释放; 线程的等待, 唤醒等等接口和具体实现</p><p>可以用在各种需要控制资源争用的场景中(ReentrantLock&#x2F;CountDownLatch&#x2F;Semahpore)</p><p><img src="/../java/image-2020050801.png" alt="image-2020050801"></p><p>其中定义的接口可以分为<strong>独占资源</strong>接口和<strong>共享资源</strong>接口两类; 其中独占资源接口包括 acquire, release, tryAcquire(未实现), tryRelease(未实现); 而共享资源接口则包括 acquireShared, releaseShared, tryAcquireShared(未实现), tryReleaseShared(未实现)</p><ul><li>acquire, acquireShared : 定义了资源争用的逻辑, 如果没拿到, 则等待</li><li><strong>tryAcquire, tryAcquireShared :</strong> 实际执行占用资源的操作, 如何判定一个由使用者具体去实现</li><li>release, releaseShared : 定义释放资源的逻辑, 释放之后, 通知后续节点进行争抢</li><li><strong>tryRelease, tryReleaseShared :</strong> 实际执行资源释放的操作, 具体的 AQS 使用者去实现</li></ul><p>AQS 内部主体 : state(状态), exclusiveOwner(占有者), Node(锁的等待者链表, 从head &#x3D;&gt; tail)</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AQSdemo</span> &#123;<br>    <span class="hljs-comment">// 同步资源状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 当前锁的拥有者</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <span class="hljs-comment">// java q 线程安全</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">addQ</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!tryAcquire()) &#123;<br>            <span class="hljs-keyword">if</span> (addQ) &#123;<br>                <span class="hljs-comment">// 塞到等待锁的集合中</span><br>                waiters.offer(Thread.currentThread());<br>                addQ = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 挂起这个线程</span><br>                LockSupport.park();<br>                <span class="hljs-comment">// 后续，等待其他线程释放锁，收到通知之后继续循环</span><br>            &#125;<br>        &#125;<br>        waiters.remove(Thread.currentThread());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// cas 修改 owner 拥有者</span><br>        <span class="hljs-keyword">if</span> (tryRelease()) &#123;<br>            Iterator&lt;Thread&gt; iterator = waiters.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">waiter</span> <span class="hljs-operator">=</span> iterator.next();<br>                LockSupport.unpark(waiter); <span class="hljs-comment">// 唤醒线程继续 抢锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断量够不够</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">addQ</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (tryAcquireShared() &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (addQ) &#123;<br>                <span class="hljs-comment">// 塞到等待锁的集合中</span><br>                waiters.offer(Thread.currentThread());<br>                addQ = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 挂起这个线程</span><br>                LockSupport.park();<br>                <span class="hljs-comment">// 后续，等待其他线程释放锁，收到通知之后继续循环</span><br>            &#125;<br>        &#125;<br>        waiters.remove(Thread.currentThread());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// cas 修改 owner 拥有者</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared()) &#123;<br>            Iterator&lt;Thread&gt; iterator = waiters.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">waiter</span> <span class="hljs-operator">=</span> iterator.next();<br>                LockSupport.unpark(waiter); <span class="hljs-comment">// 唤醒线程继续 抢锁</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> AtomicInteger <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(AtomicInteger state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-资源占用流程-acquire"><a href="#三-资源占用流程-acquire" class="headerlink" title="三 : 资源占用流程(acquire)"></a>三 : 资源占用流程(acquire)</h2><p><img src="/../java/image-2020050802.jpg" alt="image-2020050802"></p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>J.U.C并发编程包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock接口和ReentrantLock/ReadWriteLock</title>
    <link href="/2020/04/24/Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/04/24/Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Lock-的核心API"><a href="#一-Lock-的核心API" class="headerlink" title="一 : Lock 的核心API"></a>一 : Lock 的核心API</h2><p>synchronized 关键字使用固然简单, 但是我们<strong>无法控制同步代码停止</strong>, 除非抛异常; </p><p>Lock 提供了很丰富的 API : </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>lock</td><td>获取锁的方法, 若锁被其他线程获取, 则等待(阻塞)</td></tr><tr><td>lockInterruptibly</td><td>在锁的获取过程中可以中断当前线程</td></tr><tr><td>tryLock</td><td>尝试非阻塞的获取锁, 立即返回</td></tr><tr><td>unlock</td><td>释放锁</td></tr></tbody></table><h2 id="二-ReentrantLock"><a href="#二-ReentrantLock" class="headerlink" title="二 : ReentrantLock"></a>二 : ReentrantLock</h2><p><strong>独享锁; 可重入锁</strong>; 支持公平锁, 非公平锁两种模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果需要正确中断等待锁的线程,必须将获取锁放在try&#123;&#125;外面;</span><br><span class="hljs-comment">         * 否则会抛出 IllegalMonitorStateException,</span><br><span class="hljs-comment">         * 由于finally却无论如何都要执行,而等待线程根本就没有拿到锁,也就是锁没有锁定监视器</span><br><span class="hljs-comment">         */</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...method body</span><br>            b(); <span class="hljs-comment">// 此方法带锁, 同一线程可以重复进入</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 这里必须用finally将锁释放掉,否则一旦出现异常容易出现死锁</span><br>            lock.unlock(); <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-comment">//...</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行过程 :</strong></p><ul><li>初始化 : 未锁, ReentrantLock, 持有者(null), 计数(0)</li><li>调用 a() : 第一次锁, ReentrantLock, 持有者(线程-0), 计数(1) </li><li>a() 中又调用 b() : 第二次锁, ReentrantLock, 持有者(线程-0), 计数(2)</li><li>b() 执行完毕 : 解锁, ReentrantLock, 持有者(线程-0), 计数(1)</li><li>a() 执行完毕 : 解锁, ReentrantLock, 持有者(null), 计数(0)</li></ul><h2 id="三-ReadWriteLock"><a href="#三-ReadWriteLock" class="headerlink" title="三 : ReadWriteLock"></a>三 : ReadWriteLock</h2><p>维护一对关联锁, 一个用于只读操作, 一个用于写入; 读锁可以由多个读线程同时持有, 写锁是排他的; </p><ul><li><strong>适用场景 :</strong> 适合读取线程比写入线程多的场景(读多写少), 改进互斥锁的性能</li><li><strong>示例场景 :</strong> 缓存组件, 集合的并发线程安全性改造</li></ul><p>代码示例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        <span class="hljs-comment">// 多线程同时读/写</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.read(Thread.currentThread());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.read(Thread.currentThread());<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            demo.write(Thread.currentThread());<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">// 多线程读,共享锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        readWriteLock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;正在进行“读”操作&quot;</span>);<br>            &#125;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;“读”操作完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 写,独占锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        readWriteLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;正在进行“写”操作&quot;</span>);<br>            &#125;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;“写”操作完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>锁降级</strong>指的是写锁降级成为读锁; 把持住当前拥有的写锁的同时, 再获取到读锁, 然后释放写锁的过程</p><p>写锁是线程独占, 读锁是共享, 所以, <strong>写 &#x3D;&gt; 读是升级</strong>(读 &#x3D;&gt; 写, 是不能实现的)</p><h2 id="四-Condition"><a href="#四-Condition" class="headerlink" title="四 : Condition"></a>四 : Condition</h2><p>Object 中的 wait(), notify(), notifyAll() 方法是和 synchronized 配合使用的, 可以唤醒一个或者全部(单个等待集);</p><p>Condition 是需要与 Lock 配合使用的, 提供多个等待集合, 更精确的控制; <strong>底层是 park&#x2F;unpark 机制</strong>; 用于替代 wait&#x2F;notify; </p><p>经典场景 : JDK 中的队列实现</p><ul><li>多线程读写队列 : 写入数据时, 唤醒读取线程继续执行; 读取数据后, 通知写入队列继续执行</li></ul><p>代码示例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * condition 实现队列线程安全</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueDemo</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 指定条件的等待 - 等待有空位</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 指定条件的等待 - 等待不为空</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 定义数组存储数据</span><br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> putptr, takeptr, count;<br><br>    <span class="hljs-comment">// 写入数据的线程,写入进来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) <span class="hljs-comment">// 数据写满了</span><br>                notFull.await(); <span class="hljs-comment">// 写入数据的线程,进入阻塞</span><br>            items[putptr] = x;<br>            <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>            ++count;<br>            notEmpty.signal(); <span class="hljs-comment">// 唤醒指定的读取线程</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 读取数据的线程,调用take</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                notEmpty.await(); <span class="hljs-comment">// 线程阻塞在这里,等待被唤醒</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>            <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>            --count;<br>            notFull.signal(); <span class="hljs-comment">// 通知写入数据的线程,告诉他们取走了数据,继续写入</span><br>            <span class="hljs-keyword">return</span> x;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA锁相关术语及同步关键字synchronized</title>
    <link href="/2020/04/17/synchronized%E5%92%8C%E9%94%81/"/>
    <url>/2020/04/17/synchronized%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-java-中锁的概念"><a href="#一-java-中锁的概念" class="headerlink" title="一 : java 中锁的概念"></a>一 : java 中锁的概念</h2><p><strong>自旋锁 :</strong> 为了不放弃 CPU 执行事件, 循环的使用 CAS 技术对数据尝试进行更新, 直至成功</p><p><strong>悲观锁 :</strong> 假定会发生并发冲突, 同步所有对数据的相关操作, 从读数据就开始上锁</p><p><strong>乐观锁 :</strong> 假定没有冲突, 在修改数据时如果发现数据和之前获取的不一致, 则读最新的数据, 修改后重试修改</p><p><strong>独享锁(写) :</strong> 给资源加上写锁, 线程可以修改资源, 其他线程不能再加锁;(单写)</p><p><strong>共享锁(读) :</strong> 给资源加上读锁后只能读不能改, 其他线程也只能加读锁, 不能加写锁;(多读)</p><p><strong>可重入锁, 不可重入锁 :</strong> 线程拿到一把锁之后, 可以自由进入同一把锁所同步的其他代码</p><p><strong>公平锁, 非公平锁 :</strong> 争抢锁的顺序, 如果是按先来后到, 则为公平</p><p>几种重要的锁实现方式 : <code>synchronized</code>, <code>ReentrantLock</code>, <code>ReentrantReadWriteLock</code></p><h2 id="二-同步关键字-synchronized"><a href="#二-同步关键字-synchronized" class="headerlink" title="二 : 同步关键字 synchronized"></a>二 : 同步关键字 synchronized</h2><p>属于最基本的线程通信机制, 基于<strong>对像监视器</strong>实现的; java中的每一个对象都与一个监视器相关联, 一个线程可以锁定或者解锁监视器; <strong>一次只有一个线程可以锁定监视器;</strong> 试图锁定该监视器的任何其他线程都会被阻塞, 直到它们可以获得该监视器上的锁定为止</p><p><strong>特性 :</strong> 可重入, 独享, 悲观锁</p><p><strong>锁的范围 :</strong> 类锁, 对象锁, 锁消除, 锁粗化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-comment">/*static*/</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 我开始执行&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">3000L</span>);<br>            System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; 我执行结束&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncDemo</span>().test()).start();<br>        Thread.sleep(<span class="hljs-number">1000L</span>); <span class="hljs-comment">// 等1秒钟,让前一个线程启动起来</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncDemo</span>().test()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果 :</strong> 线程不会同步</p><p><strong>原理分析 :</strong> <code>synchronized</code> 的加锁原理是锁定<strong>对象监视器</strong>, 每个对象都对应各自的监视器</p><p><strong>解决方案 :</strong> </p><ol><li>加静态关键字 <code>static</code>, 提升为类锁</li><li>为临界区添加同步代码块, 指定共用的锁, 但需要是类锁</li></ol><p><strong>提示 :</strong> 同步关键字, 不仅是实现同步, 根据 JMM 规定还能保证可见性(读取最新主内存数据, 结束后写入主内存)</p><h2 id="三-同步关键字加锁原理"><a href="#三-同步关键字加锁原理" class="headerlink" title="三 : 同步关键字加锁原理"></a>三 : 同步关键字加锁原理</h2><p>HotSpot 中, 对象在内存中存储的布局可以分为三块区域 : <strong>对象头</strong>(Header), <strong>实例数据</strong>(Instance Data)和<strong>对齐填充</strong>(Padding)</p><p>普通对象的<strong>对象头</strong>(Header)包括两部分 : <strong>Mark Word</strong> 和 <strong>Class Metadata Address</strong> (类型指针), 如果是数组对象还包括一个额外的 <strong>Array length</strong> 数组长度部分</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64bit</td><td><strong>Mark Word</strong></td><td>存储对象hashCode或锁信息等运行时数据。</td></tr><tr><td>32&#x2F;64bit</td><td><strong>Class Metadata Address</strong></td><td>存储到对象类型数据的指针</td></tr><tr><td>32&#x2F;64bit</td><td><strong>Array length</strong></td><td>数组的长度(如果当前对象是数组)</td></tr></tbody></table><p>其中 <strong>mark word</strong> 用于存储对象自身的运行时数据, 如: 哈希码(HashCode), GC分代年龄(age), 是否偏向锁(0&#x2F;1), 锁标志位(tag), 线程持有的锁状态(state), 偏向线程ID(Thread ID), 偏向时间戳等等(epoch); 占用内存大小与虚拟机位长一致(32&#x2F;64bit)</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">Bitfield</span>|<span class="hljs-string">Tag</span>|<span class="hljs-string">State</span>|<br>|<span class="hljs-string">HashCode</span>|<span class="hljs-string">age</span>|<span class="hljs-string">0</span>|<span class="hljs-string">01</span>|<span class="hljs-string">Unlocked</span>|<br>|<span class="hljs-string">Lock record address</span>|<span class="hljs-string">00</span>|<span class="hljs-string">Light-weight locked</span>|<br>|<span class="hljs-string">Monitor address</span>|<span class="hljs-string">10</span>|<span class="hljs-string">heavy-weight locked</span>|<br>|<span class="hljs-string">Forwarding address, etc</span>|<span class="hljs-string">11</span>|<span class="hljs-string">marked for GC</span>|<br>|<span class="hljs-string">Thread ID</span>|<span class="hljs-string">epoch</span>|<span class="hljs-string">age</span>|<span class="hljs-string">1</span>|<span class="hljs-string">01</span>|<span class="hljs-string">biased/biasable</span>|<br></code></pre></td></tr></table></figure><p><strong>默认情况下 jvm 锁会经历 :</strong> 偏向锁 &#x3D;&gt; 轻量级锁 &#x3D;&gt; 重量级锁</p><p>参考文献 : </p><ul><li><a href="https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf">https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf</a> </li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></li></ul><h3 id="一-轻量级锁"><a href="#一-轻量级锁" class="headerlink" title="(一) 轻量级锁"></a>(一) 轻量级锁</h3><p>对象初始化的时候是无锁的, mark word 记录的是 hashCode, age 和偏移状态</p><p><strong>加锁原理 :</strong> 线程栈开辟一个空间, 存储当前锁定对象的 mark word 信息; 这个空间就是 lock record, 它可以存储多个锁定的对象信息, 如果对象被锁定了, mark word 的内容会变为 lock record address</p><p>加锁前</p><p><img src="D:\blog\source\java\image-2020041701.png"> </p><p>加锁后</p><p><img src="/../java/image-2020041702.png"> </p><p>使用 CAS 修改 mark word 完毕, 则 mark word 中的 tag 进入 00 状态</p><p>解锁的过程, 则是一个逆向恢复 mark word 的过程</p><h3 id="二-偏向锁到轻量级锁"><a href="#二-偏向锁到轻量级锁" class="headerlink" title="(二) 偏向锁到轻量级锁"></a>(二) 偏向锁到轻量级锁</h3><p>偏向锁默认是开启的, <strong>偏向锁其实也是无锁</strong>, tag 值和无锁对象一样, 都是 01, 若出现锁竞争会升迁到轻量级锁</p><p><img src="/../java/image-2020041703.png"></p><p>未锁定或不可偏向对象经过自旋重锁之后, 会升迁为轻量级锁, mark word 的内容会修改为线程栈的 lock record address, 同时 tag 会修改为 00, 如果锁再次升级, 就会编程重量级锁, mark word 内容会修改为 monitor address , 同时 tag 会修改为 10</p><p>开启偏向锁的对象 mark word 内容为 thread ID|age|1 , tag 值仍然是 01, 这里需要注意的是 Thread ID 初始值为 0, 当第一个线程进行操作的时候, 会将 Thread ID 修改为自己的线程 ID, 一旦出现争抢会出现两种情况: 一种情况是如果对象没锁定, 则会变成未锁定且不偏向的对象, 也就是无锁对象; 如果对象已经锁定, 则会直接变成被轻量级锁定的对象</p><p><strong>总结 :</strong></p><ul><li><p>偏向标记第一次有用, 出现过争用后就没有用了; </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX: -UseBiasedLocking # 禁用使用偏置锁定<br></code></pre></td></tr></table></figure></li><li><p>偏向锁, 本质就是无锁, 如果没有发生过任何多线程争抢锁的情况, jvm 认为就是单线程, 无需做同步(jvm 为了少干活: 同步在 jvm 底层是有很多操作来实现的, 如果是没有争用, 就不需要去做同步)</p></li></ul><h3 id="三-重量级锁-监视器-monitor"><a href="#三-重量级锁-监视器-monitor" class="headerlink" title="(三) 重量级锁 - 监视器(monitor)"></a>(三) 重量级锁 - 监视器(monitor)</h3><p>修改 mark word 如果失败, 会自旋 CAS 一定次数, 该次数可以通过参数配置</p><p>超过次数, 仍未抢到锁, 则锁升级为重量级锁, 进入阻塞</p><p><img src="/../java/image-2020041704.png"></p><p>monitor 也叫做管程, 计算机操作系统原理中有提及类似概念, 一个对象会有一个对应的 monitor</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS机制和Atomic相关类</title>
    <link href="/2020/04/10/CAS%E6%9C%BA%E5%88%B6%E5%92%8CAtomic%E7%9B%B8%E5%85%B3%E7%B1%BB/"/>
    <url>/2020/04/10/CAS%E6%9C%BA%E5%88%B6%E5%92%8CAtomic%E7%9B%B8%E5%85%B3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h2 id="一-CAS-机制"><a href="#一-CAS-机制" class="headerlink" title="一 : CAS 机制"></a>一 : CAS 机制</h2><p>Compare and swap 比较和交换; 属于硬件同步原语, 处理器提供了基本内存操作的原子性保证</p><p>CAS 操作需要输入两个数值, 一个旧值 A (期望操作前的值)和一个新值 B, 在操作期间先比较下旧值有没有发生变化, 如果没有发生变化, 才交换成新值, 发生了变化则不交换</p><p><img src="/../java/image-2020041001.png" alt="image-2020041001"> </p><p>JAVA 中的 sun.misc.Unsafe 类, 提供了 <code>compareAndSwapInt()</code> 和 <code>compareAndSwapLong()</code> 等几个方法实现 CAS</p><h2 id="二-JUC包内的原子操作封装类"><a href="#二-JUC包内的原子操作封装类" class="headerlink" title="二 : JUC包内的原子操作封装类"></a>二 : JUC包内的原子操作封装类</h2><p>数值</p><ul><li>AtomicBoolean : 原子更新布尔类型</li><li>AtomicInteger : 原子更新整型</li><li>AtomicLong : 原子更新长整型</li></ul><p>数组</p><ul><li>AtomicIntegerArray : 原子更新整型数组数组里的元素</li><li>AtomicLongArray : 原子更新长整型数组里的元素</li><li>AtomicReferenceArray : 原子更新引用类型数组里的元素</li></ul><p>字段</p><ul><li>AtomicIntegerFieldUpdate : 原子更新整形的字段的更新器</li><li>AtomicLongFieldUpdate : 原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdate : 原子更新引用类型里的字段</li></ul><p>引用类型</p><ul><li>AtomicReference : 原子更新引用类型</li><li>AtomicStampedReference : 原子更新带有版本号的引用类型</li><li>AtomicMarkableReference : 原子更新带有标记为的引用类型</li></ul><p>jdk1.8 更新</p><ul><li>更新器 : DoubleAccumulator, LongAccumulator</li><li>计数器 : DoubleAdder, LongAdder</li><li>计数器增强版, 高并发下性能更好</li><li>频繁更新但不太频繁读取的汇总统计信息时使用</li><li>分成多个操作单元, 不同线程更新不同的单元</li><li>只有需要汇总的时候才计算所有单元的操作</li></ul><h2 id="三-CAS-的三个问题"><a href="#三-CAS-的三个问题" class="headerlink" title="三 : CAS 的三个问题"></a>三 : CAS 的三个问题</h2><ol><li>循环 + CAS, 自旋的实现让所有线程都处于高频运行, 争抢 CPU 执行事件的状态; 如果操作长时间不成功, 会带来很大的 CPU 资源消耗</li><li>仅针对单个变量的操作, 不能用于多个变量来实现原子操作</li><li>ABA 问题 : 简单来说就是 value&#x3D;A, 线程1将A改成B, 线程2又将B改成A, 这是线程3将A改成C, 这时线程3是不知道 value 的值曾经有过变动的</li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之原子操作</title>
    <link href="/2020/04/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/04/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>原子操作操作可以是一个步骤, 也可以是多个操作步骤, 但是其顺序不可以被打乱, 也不可以被切割而只执行其中的一部分(不可中断性); </p><p><strong>将整个操作视作一个整体是原子性的核心特征</strong></p><h2 id="二-解决方案"><a href="#二-解决方案" class="headerlink" title="二 : 解决方案"></a>二 : 解决方案</h2><ol><li>加锁</li><li>循环 CAS</li></ol><h2 id="三-示例"><a href="#三-示例" class="headerlink" title="三 : 示例"></a>三 : 示例</h2><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>        i++; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是三个步骤 : </p><ol><li>加载 i</li><li>计算 i+1 </li><li>赋值 i</li></ol><p>存在<strong>竟态条件</strong>, 线程不安全, 需要转变为原子操作才能安全; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>    i++; <br>&#125;<br></code></pre></td></tr></table></figure><p>上例只是针对一个变量的原子操作改进, 我们也可以实现更大逻辑的原子操作</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之共享资源/不可变性/竟态条件/临界区</title>
    <link href="/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <url>/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-竟态条件与临界区"><a href="#一-竟态条件与临界区" class="headerlink" title="一 : 竟态条件与临界区"></a>一 : 竟态条件与临界区</h2><p>多个线程访问了相同的资源, 向这些资源做了写操作时, 对执行顺序有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>临界区 :</strong> <code>incr()</code> 内部就是临界区域, 关键部分代码的多线程并发执行, 会对执行结果产生影响</p><p><strong>竟态条件 :</strong> 可能发生在临界区域内的特殊条件; 多线程执行 <code>incr()</code> 中的 <code>i++</code> 关键代码时, 产生了竟态条件</p><h2 id="二-共享资源"><a href="#二-共享资源" class="headerlink" title="二 : 共享资源"></a>二 : 共享资源</h2><p>如果一段代码是线程安全的, 则它不包含竟态条件; 只有当多个线程更新共享资源时, 才会发生竟态条件</p><p>栈封闭时, 不会在线程之间共享的变量, 都是线程安全的</p><p>局部对象引用本身不共享, 但是引用的对象存储在共享堆中; 如果方法内创建的对象, 只是在方法中传递, 并且不对其他线程可用, 那么也是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">LocalObject</span> <span class="hljs-variable">localObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalObject</span>();<br>    localObject.callMethod();<br>    method2(localObject);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(LocalObject localObject)</span>&#123;<br>    localObject.setValue(<span class="hljs-string">&quot;value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则判定 :</strong> 如果创建, 使用和处理资源, 永远不会逃脱单个线程的控制, 该资源的使用时线程安全的</p><h2 id="三-不可变对象"><a href="#三-不可变对象" class="headerlink" title="三 : 不可变对象"></a>三 : 不可变对象</h2><p>创建不可变的共享对象来保证对象在线程间共享时不会被修改, 从而实现线程安全; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例被创建, value 变量就不能在被修改, 这就是不可变性</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用volatile解决可见性问题及阻止指令重排序</title>
    <link href="/2020/03/20/volatile/"/>
    <url>/2020/03/20/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="一-线程操作的定义"><a href="#一-线程操作的定义" class="headerlink" title="一 : 线程操作的定义"></a>一 : 线程操作的定义</h2><p>操作定义</p><ul><li>write : 要写的变量以及要写的值</li><li>read : 要读的变量以及可见的写入值(由此, 我们可以确定可见的值)</li><li>lock : 要锁定的管程(监视器 monitor)</li><li>unlock : 要解锁的管程</li><li>外部操作(socket等等…)</li><li>启动和终止</li></ul><p>程序顺序 : 如果一个程序没有数据竞争, 那么程序的所有执行看起来都是顺序一致的</p><h2 id="二-对于同步的规则定义"><a href="#二-对于同步的规则定义" class="headerlink" title="二 : 对于同步的规则定义"></a>二 : 对于同步的规则定义</h2><ol><li>对于监视器 m 解锁与所有后续操作对于 m 的加锁同步</li><li>对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步</li><li>启动线程的操作与线程中的第一个操作同步</li><li>对于每个属性写入默认值(0, false, null)与每个线程对其进行的操作同步</li><li>线程 T1 的最后操作与线程 T2 发现线程 T1 已经结束同步(isAlive, join可以判断线程是否终结)</li><li>如果线程 T1 中断了 T2, 那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步; 通过抛出 InterruptedException 异常, 或者调用 Thread.interrupted 或 Thread.isInterrupted</li></ol><h2 id="三-happens-before-先行发生原则"><a href="#三-happens-before-先行发生原则" class="headerlink" title="三 : happens-before 先行发生原则"></a>三 : happens-before 先行发生原则</h2><p><strong>happens-before 关系</strong>主要用于强调两个有冲突的动作之间的顺序, 以及定义数据争用的发生时机</p><p><strong>具体的虚拟机实现</strong>, 有必要确保以下原则的成立 : </p><ul><li>某个线程中的每个动作都 happens-before 该线程中该动作后面的动作</li><li>某个管程上的 unlock 动作 happens-before 同一个管程上后续的 lock 动作</li><li>对某个 volatile 字段的写操作 happens-before 每个后续对该 volatile 字段的读操作</li><li>在某个线程对象上调用 start() 方法 happens-before 该启动了线程中的任意动作</li><li>某个线程中的所有动作 happens-before 任意其他线程成功从该线程对象上的 join() 中返回</li><li>如果某个动作 a happens-before 动作 b, 且 b happens-before 动作 c, 则有 a happens-before c</li></ul><p>当程序包含两个没有被 happens-before 关系排序的冲突访问时, 就称存在<strong>数据争用</strong>; <strong>遵守了这个原则, 也就意味着有些代码不能进行重排序, 有些数据不能缓存</strong></p><h2 id="四-使用-volatile-解决可见性问题及阻止指令重排序"><a href="#四-使用-volatile-解决可见性问题及阻止指令重排序" class="headerlink" title="四 : 使用 volatile 解决可见性问题及阻止指令重排序"></a>四 : 使用 volatile 解决可见性问题及阻止指令重排序</h2><p><strong>可见性问题 :</strong> 让一个线程对共享变量的修改, 能够及时的被其他先成功看到</p><p>根据 jmm(Java Memory Model) 中规定的 happens-before 和同步原则</p><ul><li>对某个 volatile 字段的写操作 happens-before 每个后续对该 volitile 字段的读操作</li><li>对 volatile 变量 v 的写入, 与所有其他线程后续对 v 的读同步</li></ul><p>要满足这些条件, 所以 volatile 关键字就有这些功能</p><ol><li>禁止缓存 : volatile 变量的访问控制符会加 <code>ACC_VOLATILE</code></li><li>对 volatile 变量相关的指令不做重排序</li></ol><h2 id="五-final-在-JMM-中的处理"><a href="#五-final-在-JMM-中的处理" class="headerlink" title="五 : final 在 JMM 中的处理"></a>五 : final 在 JMM 中的处理</h2><p>final 在对象的构造函数中设置对象的字段, 当线程看到该对象时, 将始终看到该对象的 final 字段的正确构造版本; 伪代码实例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">static</span> FinalDemo f;<br>&#125;<br><br>f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">finalDemo</span>(); <span class="hljs-comment">//读取到的 f.x 一定最新, x 为 final 字段</span><br></code></pre></td></tr></table></figure><p>如果在构造函数中设置字段后发生读取, 则会看到该 final 字段分配的值, 否则它将看到默认值; 伪代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">finalDemo</span><span class="hljs-params">()</span>&#123;<br>    x = <span class="hljs-number">1</span>;<br>    y = x; <span class="hljs-comment">// y等于1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读取该共享对象的 final 成员变量之前, 先要读取共享对象; 伪代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceObj</span>(); <br>k = r.f; <br><span class="hljs-comment">// 这两个操作不能重排序</span><br></code></pre></td></tr></table></figure><p>通常 static final 是不可以修改的字段; 然而 System.in, System.out 和 System.err 是 static final 字段, 遗留原因, 必须允许通过 set 方法改变, 我们将这些字段称为写保护, 以区别与普通 final 字段</p><h2 id="六-word-tearing-字节处理"><a href="#六-word-tearing-字节处理" class="headerlink" title="六 : word tearing 字节处理"></a>六 : word tearing 字节处理</h2><p>一个字段或元素的更新不得与任务其他字段或元素的读取或者更新交互; 特别是, 分别更新字节数组的相邻元素的两个线程不得干涉或交互, 也不需要同步以确保顺序一致性</p><p>有些处理器(尤其是早期的 Alphas 处理器)没有提供写单个字节的功能; 在这样的处理器上更新 byte 数组, 若只是简单的读取整个额呢绒, 更新对应的字节, 然后将整个内容再写回内存, 将是不合法的</p><p>这个问题有时候被称为**”字分裂(word tearing)”**, 在单独更新单个字节有难度的处理器上, 就需要寻求其他方式了</p><p>基本不需要考虑这个, 了解就好</p><h2 id="七-double-和-long-的特殊处理"><a href="#七-double-和-long-的特殊处理" class="headerlink" title="七 : double 和 long 的特殊处理"></a>七 : double 和 long 的特殊处理</h2><p>虚拟机规范中, 写64位的 double 和 long 分成了两次32位值的操作; 由于不是原子操作, 可能导致读取到某次写操作中 64 位的前 32 位, 以及另外一次写操作的后 32 位</p><p><strong>读写 volatile 的 long 和 double 总是原子的; 读写引用也总是原子的</strong></p><p>商业 jvm 不会存在这个问题, 虽然规范没有要求实现原子性, 但是考虑到实际应用, 大部分实现了原子性</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全之可见性问题</title>
    <link href="/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-指令重排序-jit"><a href="#一-指令重排序-jit" class="headerlink" title="一 : 指令重排序(jit)"></a>一 : 指令重排序(jit)</h2><p>Java 编程语言的语义允许编译器和微处理器执行优化，这些优化可以与不正确的同步代码交互，从而产生看似矛盾的行为。</p><ul><li><p>重排序</p><p><img src="D:\blog\source\java\image-2020031301.png"> </p></li><li><p>等效交换</p><p><img src="D:\blog\source\java\image-2020031302.png"></p></li></ul><p>通常 javac 将程序源码编译, 转换成 java 字节码(.class), jvm 通过解释字节码将其翻译成相应的机器指令, 逐条读入, 逐条解释翻译; 经过解释运行, 其运行速度必定会比可运行的二进制字节码程序慢; 为了提高运行速度, 引入了 <strong>jit</strong> 技术</p><p>当 <strong>jit</strong> 编译启用时(默认是启用的), jvm 读入 <strong>.class 文件</strong>解释后, 将其发给 jit 编译器; jit 编译器将字节码编译成本机机器代码(汇编指令), 在执行时 jit 会把翻译过的机器码保存起来, 已备下次使用; 因此从理论上来说, 采用该 jit 技术能够接近曾经纯编译技术</p><p>而 java 的指令重排序优化是在 jit 编译阶段, 因此 class 文件是看不出来的, 所以 javap 命令无法帮到你; 如果想要继续向下探索, 可以查看 jit 编译后的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过设置 jvm 的参数, 可以打印出 jit 编译的内容(非class文件)</span><br>server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭jit优化</span><br>-Djava.compiler=NONE<br></code></pre></td></tr></table></figure><p>这些优化可以与不正确的同步代码交互, 从而产生看似矛盾的行为; 这些优化是以单线程为角度的, 当发生多线程运行的时候可能会出现不确定的错误</p><h2 id="二-Shared-Variables"><a href="#二-Shared-Variables" class="headerlink" title="二 : Shared Variables"></a>二 : Shared Variables</h2><p>Shared Variables : 共享变量</p><p>可以在线程之间共享的内存称为<strong>共享内存</strong>或<strong>堆内存</strong>; 所有实例字段, 静态字段和数组元素都存储在堆内存中</p><p>如果至少有一个访问是写的, 那么对同一个变量的两次访问(读或写)是冲突的</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存模型</title>
    <link href="/2020/03/06/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/03/06/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-多线程中的问题"><a href="#一-多线程中的问题" class="headerlink" title="一 : 多线程中的问题"></a>一 : 多线程中的问题</h2><ol><li>所见非所得</li><li>无法肉眼去检测程序的准确性</li><li>不同的运行平台有不同的表现</li><li>错误很难重现</li></ol><h2 id="二-从内存结构到内存模型"><a href="#二-从内存结构到内存模型" class="headerlink" title="二 : 从内存结构到内存模型"></a>二 : 从内存结构到内存模型</h2><p>每个线程都有自己的工作内存; 如果想要数据共享, 需要存放在主内存中</p><p><img src="/../java/image-2020030601.png" alt="image-2020030601"> </p><p>因为这种内存结构, 在多线程下数据交互会有各种情况出现</p><h2 id="三-工作内存缓存"><a href="#三-工作内存缓存" class="headerlink" title="三 : 工作内存缓存"></a>三 : 工作内存缓存</h2><p>cpu 运行时, 与 cpu 交互的主要是 cpu 缓存, 此时可能会出现不同 cpu 缓存中的数据不一致的情况</p><p><img src="/../java/image-2020030602.png" alt="image-2020030601"> </p><h2 id="四-内存模型的含义"><a href="#四-内存模型的含义" class="headerlink" title="四 : 内存模型的含义"></a>四 : 内存模型的含义</h2><p>内存模型描述程序的可能行为</p><p><strong>java 编程语言内存模型</strong>通过检查执行跟踪中的每个操作, 并根据某些规则检查该读操作观察到的写操作是否有效来工作</p><p>只要程序的所有执行产生结果都可以由内存模型预测; 具体的实现者任意实现, 包括操作的重新排序和删除不必要的同步</p><p>内存模型决定了在程序的每个点上可以读取什么值</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池应用及实现原理剖析</title>
    <link href="/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/2020/02/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-为什么要用线程池"><a href="#一-为什么要用线程池" class="headerlink" title="一 : 为什么要用线程池"></a>一 : 为什么要用线程池</h2><p>线程是不是越多越好?</p><ol><li>线程在 java 中是一个对象, 更是操作系统的资源, 线程创建和销毁需要时间; 如果创建时间 + 销毁时间 &gt; 执行任务时间就很不合算</li><li>java 对象占用堆内存, 操作系统线程占用系统内存, 根据 jvm 规范, 一个线程默认最大栈大小 1M , 这个栈空间是需要从系统内存中分配的; 线程过多, 会消耗很多的内存</li><li>操作系统需要频繁切换线程上下文, 影响性能</li></ol><p><strong>线程池的推出, 就是为了方便的控制线程数量</strong></p><h2 id="二-线程池-API"><a href="#二-线程池-API" class="headerlink" title="二 : 线程池 API"></a>二 : 线程池 API</h2><p>三个接口两个实现类</p><table><thead><tr><th>类型</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>接口</td><td>Executor</td><td>最上层的接口, 定义了<strong>执行任务的方法 execute</strong></td></tr><tr><td>接口</td><td>ExecutorService</td><td>继承了 Executor 接口, 拓展了 Callable, Future, 关闭方法</td></tr><tr><td>接口</td><td>ScheduledExecutorService</td><td>继承了 ExecutorService, 增加了定时任务相关的方法</td></tr><tr><td>实现类</td><td>ThreadPoolExecutor</td><td><strong>基础, 标准的线程池实现</strong></td></tr><tr><td>实现类</td><td>ScheduledThreadPoolExecutor</td><td>继承了 ThreadPoolExecutor, 实现了 ScheduledExecutorService 中相关<strong>定时任务</strong>的方法, 可以认为时最丰富的实现类</td></tr></tbody></table><h3 id="一-ExecutorService"><a href="#一-ExecutorService" class="headerlink" title="(一) ExecutorService"></a>(一) ExecutorService</h3><p>方法定义和解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。</span><br>awaitTermination(<span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。</span><br>invokeAll(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks);<br><span class="hljs-comment">// 执行给定的任务，当所有任务完成或超时期满时(无论哪个首先发生)，返回保持任务状态和结果的 Future 列表。</span><br>invokeAll(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 执行给定的任务，如果某个任务已成功完成(也就是未抛出异常)，则返回其结果。</span><br>invokeAny(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks);<br><span class="hljs-comment">// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成(也就是未抛出异常)，则返回其结果。</span><br>invokeAny(Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callable</span>&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout, TimeUnit unit);<br><span class="hljs-comment">// 如果此执行程序已关闭，则返回 true。</span><br>isShutdown();<br><span class="hljs-comment">// 如果关闭后所有任务都已完成，则返回 true。</span><br>isTerminated();<br><span class="hljs-comment">// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。</span><br>shutdown();<br><span class="hljs-comment">// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</span><br>shutdownNow();<br><span class="hljs-comment">// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。</span><br>submit(Callable&lt;T&gt; task);<br><span class="hljs-comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span><br>submit(Runnable task);<br><span class="hljs-comment">// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span><br>submit(Runnable task, T result)<br></code></pre></td></tr></table></figure><h3 id="二-ScheduledExecutorService"><a href="#二-ScheduledExecutorService" class="headerlink" title="(二) ScheduledExecutorService"></a>(二) ScheduledExecutorService</h3><p>方法定义和解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。</span><br>schedule(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行在给定延迟后启用的一次性操作。</span><br>schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span><br>scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period, TimeUnit unit);<br><span class="hljs-comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 </span><br>scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay, TimeUnit unit);<br></code></pre></td></tr></table></figure><p>schedule 方法</p><ul><li>创建并执行一个一次性任务; </li><li>过了延迟时间就会被执行</li></ul><p>scheduleAtFixedRate 方法</p><ul><li>创建并执行一个周期任务; </li><li>过了给定的初始延迟时间, 会第一次被执行; </li><li>执行过程中发生了异常, 那么任务就停止; </li><li><strong>一次任务执行时长超过了周期时间, 下一次任务会等到该次任务执行结束后, 立刻执行, 这也是它和 scheduleWithFixedDelay 的重要区别</strong></li></ul><p>scheduleWithFixedDelay 方法</p><ul><li>创建并执行一个周期性任务; </li><li>过了初始延迟时间, 第一次被执行, 后续以给定的周期时间执行; </li><li>执行过程中发生了异常, 那么任务就停止; </li><li><strong>一次任务执行时长超过了周期时间, 下一次任务会在该次任务执行结束的时间基础上, 计算执行延时;</strong></li><li><strong>对于超过周期的长时间处理任务的不同处理方式, 这是它和scheduledFixedRate的重要区别</strong></li></ul><h3 id="三-Executors-工具类"><a href="#三-Executors-工具类" class="headerlink" title="(三) Executors 工具类"></a>(三) Executors 工具类</h3><p>你可以自己实例化线程池, 也可以用 Executors 创建线程池的工厂类, 常用方法如下: </p><ul><li><strong>newFixedThreadPool(int nThreads):</strong> 创建一个固定大小, 任务队列容量无界的线程池; 推荐: <strong>核心线程数 &#x3D; 最大线程数</strong></li><li><strong>newCachedThreadPool():</strong> 创建的是一个大小无界的缓冲线程池; 它的任务队列是一个同步队列; 任务加入到池中, 如果池中有空闲线程, 则用空闲线程执行, 如无则创建新线程执行; 池中的线程空闲超过60秒, 将被销毁释放; 线程数随任务的多少变化, 适用于执行耗时较小的异步任务; 池的核心线程数为0, 最大线程数&#x3D;Integer.MAX_VALUE</li><li><strong>newSingleThreadExecutor():</strong> 只有一个线程来执行无界任务队列的单一线程池; 该线程池确保任务被加入的顺序一个一个一次执行; 当唯一的线程因任务异常中止时, 将创建一个新的线程来继续执行后续的任务; 与 newFixedThreadPool(1)的区别在于, 单一线程池的池大小在 newSingleThreadExecutor() 中硬编码, 不能在改变的</li><li><strong>newScheduledThreadPool(int corePoolSize):</strong> 能定时执行任务的线程池; 该池的核心线程数由参数指定, 最大线程数 &#x3D; Integer.MAX_VALUE</li></ul><h2 id="三-线程池原理"><a href="#三-线程池原理" class="headerlink" title="三 : 线程池原理"></a>三 : 线程池原理</h2><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="(一) 概念"></a>(一) 概念</h3><p><strong>线程池管理器 :</strong> 用于创建并管理线程池; 包括创建线程池, 销毁线程池, 添加新任务</p><p><strong>工作线程 :</strong> 线程池中线程, 在没有任务时处于等待状态, 可以循环的执行任务</p><p><strong>任务接口 :</strong> 每个任务必须实现的接口, 以供工作线程调度任务的执行, 它主要规定了任务的入口, 任务执行完后的收尾工作, 任务的执行状态等</p><p><strong>任务队列 :</strong> 用于存放没有处理的任务; 提供一种缓冲机制</p><h3 id="二-执行过程"><a href="#二-执行过程" class="headerlink" title="(二) 执行过程"></a>(二) 执行过程</h3><p>首先, 是否达到核心线程数量? </p><ul><li>没达到, 创建一个工作线程来执行任务</li><li>达到了, 进入工作队列</li></ul><p>其次, 工作队列是否已满? </p><ul><li>没满, 则将新提交的任务存储在工作队列里</li><li>满了, 创建新的线程</li></ul><p>最后, 是否达到线程池最大数量? </p><ul><li>没达到, 则创建一个新的工作线程来执行任务</li><li>达到了, 执行拒绝策略来处理这个任务</li></ul><p>过程梳理如图所示</p><pre><code class=" mermaid">graph LR执行 --&gt;  A&#123;没达到核心线程数&#125; --是--&gt; 创建新线程执行A&#123;没达到核心线程数&#125; --否--&gt; B&#123;工作队列没满?&#125;B&#123;工作队列没满?&#125; --是--&gt; 丢到队列B&#123;工作队列没满?&#125;--否--&gt; C&#123;没达到最大线程数?&#125;C&#123;没达到最大线程数?&#125; --是--&gt; 创建新线程</code></pre><h2 id="四-线程数量"><a href="#四-线程数量" class="headerlink" title="四 : 线程数量"></a>四 : 线程数量</h2><p>如何确定合适数量的线程? 要根据自己任务的类型进行判定</p><ul><li><strong>计算型任务 :</strong> cpu 数量的1~2倍数</li><li><strong>IO型任务 :</strong> 相对比计算型任务, 需要多一些线程, 要根据具体的 <strong>IO 阻塞时长</strong>进行考量决定; 如 tomcat 中默认的最大线程数为: 200</li></ul><p>也可考虑根据需要在一个<strong>最小数量和最大数量</strong>间自动增减线程数</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程封闭之ThreadLocal和栈封闭</title>
    <link href="/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/"/>
    <url>/2020/02/21/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="一-线程封闭概念"><a href="#一-线程封闭概念" class="headerlink" title="一 : 线程封闭概念"></a>一 : 线程封闭概念</h2><p>多线程访问共享可变数据时, 涉及到线程间数据同步的问题, 并不是所有时候, 都要用到共享数据, 所以线程封闭概念就提出来了</p><p>数据都被封闭在各自的线程之中, 就不需要同步, 这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong></p><p>线程封闭的具体实现有: <strong>ThreadLocal</strong>, <strong>局部变量</strong></p><h2 id="二-ThreadLocal"><a href="#二-ThreadLocal" class="headerlink" title="二 : ThreadLocal"></a>二 : ThreadLocal</h2><p><strong>ThreadLocal 是 java 里一种特殊的变量</strong>, 它是一个<strong>线程级别变量</strong>, 每个线程都有一个 ThreadLocal, 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了, 在并发模式下是绝对安全的变量</p><p><strong>用法</strong>: <code>ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;();</code> 会自动在每一个线程上创建一个 T 的副本, 副本之间彼此独立, 互不影响; 可以用 ThreadLocal 存储一些参数, 以便在线程中多个方法中使用, <strong>用来代替方法传参的做法</strong>; </p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadLocalTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    value.set(<span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> value.get();<br>    System.out.println(<span class="hljs-string">&quot;线程1执行之前,主线程取到的值: &quot;</span> + v);<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> value.get();<br>        System.out.println(<span class="hljs-string">&quot;线程1取到的值: &quot;</span> + s);<br>        value.set(<span class="hljs-string">&quot;456&quot;</span>);<br><br>        s = value.get();<br>        System.out.println(<span class="hljs-string">&quot;重新设置后,线程1取到的值: &quot;</span> + s);<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">5000L</span>);<br>    v = value.get();<br>    System.out.println(<span class="hljs-string">&quot;线程1执行之后,主线程取到的值: &quot;</span> + v);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalDemo</span>().threadLocalTest();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>实在难以理解的, 可以理解为, jvm 维护了一个 Map&lt;Thread, T&gt;, 每个线程要用这个 T 的时候, 用当前的线程去 Map 里面取, 仅作为一个概念理解</p><h2 id="三-栈封闭"><a href="#三-栈封闭" class="headerlink" title="三 : 栈封闭"></a>三 : 栈封闭</h2><p><strong>局部变量</strong>的固有属性之一就是封闭在线程中</p><p>它们位于执行线程的栈中, 其他线程无法访问这个栈</p>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程通信</title>
    <link href="/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2020/02/14/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-通信的方式"><a href="#一-通信的方式" class="headerlink" title="一 : 通信的方式"></a>一 : 通信的方式</h2><p>要想实现多个线程之间的协同, 如: 线程执行先后顺序, 获取某个线程执行的结果等等</p><p>涉及到线程之间相互通信, 分为四类:</p><ul><li>文件共享</li><li>网络共享</li><li>共享变量</li><li>JDK 提供的线程协调 API (suspend&#x2F;resume, wait&#x2F;notify, park&#x2F;unpark)</li></ul><h2 id="二-文件共享"><a href="#二-文件共享" class="headerlink" title="二 : 文件共享"></a>二 : 文件共享</h2><ul><li><p>线程1在<strong>文件</strong>中写入数据, 线程2从文件中读取数据</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1 写入数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Files.write(Paths.get(<span class="hljs-string">&quot;a.txt&quot;</span>), (<span class="hljs-string">&quot;当前时间: &quot;</span> + System.currentTimeMillis()).getBytes());<br>                Thread.sleep(<span class="hljs-number">1000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 线程2 读数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                    <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;a.txt&quot;</span>));<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三-变量共享"><a href="#三-变量共享" class="headerlink" title="三 : 变量共享"></a>三 : 变量共享</h2><ul><li><p>线程-1在<strong>内存</strong>中写入数据, 线程-2从内存中读取数据</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1 写入数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    content = <span class="hljs-string">&quot;当前时间: &quot;</span> + System.currentTimeMillis();<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">// 线程2 读取数据</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                    System.out.println(content);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="四-线程协作-JDK-API"><a href="#四-线程协作-JDK-API" class="headerlink" title="四 : 线程协作-JDK API"></a>四 : 线程协作-JDK API</h2><p>JDK 中对于需要多线程协作完成某一任务的场景, 提供了对应API支持</p><p>多线程协作的典型场景是 : 生产者 - 消费者模型(线程阻塞, 线程唤醒); </p><pre><code class=" mermaid">sequenceDiagram消费者-&gt;&gt;+包子店:买包子包子店--&gt;&gt;-消费者:没有消费者-&gt;&gt;+消费者:等待生产者-&gt;&gt;包子店:生产包子生产者-&gt;&gt;消费者:通知有包子了</code></pre><h3 id="一-suspend-x2F-resume-机制-弃用"><a href="#一-suspend-x2F-resume-机制-弃用" class="headerlink" title="(一) suspend&#x2F;resume 机制(弃用)"></a>(一) suspend&#x2F;resume 机制(弃用)</h3><ul><li><p>作用: 调用 suspend 挂起目标线程, 通过 resume 可以恢复线程执行; 被弃用的主要原因是, 容易写出死锁的代码, 所以用 wait&#x2F;notify 和 park&#x2F;unpark 机制对它进行替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 买包子 =&gt; 如果没有包子 =&gt; 则进入等待 =&gt; 当生产出包子后通知消费者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">suspendResumeTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子, 进入等待&quot;</span>);<br>            Thread.currentThread().suspend();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    <span class="hljs-comment">// 3秒后通知消费者</span><br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    thread.resume();<br>    System.out.println(<span class="hljs-string">&quot;生产出包子,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>suspend 和 resume 死锁示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * suspend并不会像wait一样释放锁,很容易出现死锁代码</span><br><span class="hljs-comment"> * 还是买包子, 但如果出现了锁竞争问题, 就会出现死锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">suspendResumeDeadLockTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                Thread.currentThread().suspend();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        thread.resume();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="二-wait-x2F-notify-机制"><a href="#二-wait-x2F-notify-机制" class="headerlink" title="(二) wait&#x2F;notify 机制"></a>(二) wait&#x2F;notify 机制</h3><ul><li><p>这些方法只能由同一对象锁的持有者线程调用, 也就是写在同步块里面, 否则会抛出 IllegalMonitorStateException 异常</p></li><li><p>wait 方法导致当前线程等待, 加入该对象的等待集合中, 并且放弃当前持有的对象锁</p></li><li><p>notify&#x2F;notifyAll 方法唤醒一个或者所有正在等待这个对象锁的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 正常的wait/notify</span><br><span class="hljs-comment"> * 还是买包子,可以有锁竞争,因为wait会释放锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotifyTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-built_in">this</span>.notify();<br>        System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意: 虽然会 wait 自动解锁, 但是<strong>对顺序有要求</strong>, 如果在 notify 被调用之后才开始wait方法的调用, 线程会永远处于 WAITING 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * wait/notify会释放锁, 但是如果出现先notify(通知)后wait(等待)</span><br><span class="hljs-comment"> * 这是线程就会一直等待, 也可以看作是另一种形式的死锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotifyWaitForeverTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">5000L</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后,生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-built_in">this</span>.notify();<br>        System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="三-park-x2F-unpark-机制"><a href="#三-park-x2F-unpark-机制" class="headerlink" title="(三) park&#x2F;unpark 机制"></a>(三) park&#x2F;unpark 机制</h3><ul><li><p>线程调用 park 则等待<strong>许可</strong>(permit), unpark 方法为指定线程提供”许可(permit)”</p></li><li><p><strong>不要求 park 和 unpark 方法的调用顺序</strong></p></li><li><p>多次调用 unpark 之后, 再调用 park , 线程会直接运行</p></li><li><p>但不会叠加, 也就是说, 连续多次调用 park 方法, 第一次会拿到”许可”直接运行, 后续调用会进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 正常的park/unPark</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnparkTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            LockSupport.park();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒后生产包子&quot;</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    LockSupport.unpark(thread);<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意: 同步代码容易写出死锁代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * park/unpark虽然没有顺序要求, 但是如果不会释放锁</span><br><span class="hljs-comment"> * 如果出现锁竞争问题,还是要考虑死锁的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnparkDeadLockTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (baozi == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;没有包子,进入等待&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                LockSupport.park();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;买到包子了&quot;</span>);<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    baozi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;休眠3秒,生产包子&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        LockSupport.unpark(thread);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;有包子了,通知消费者&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="五-伪唤醒"><a href="#五-伪唤醒" class="headerlink" title="五 : 伪唤醒"></a>五 : 伪唤醒</h2><ul><li><p>警告: 之前代码中用 if 语句来判断是否进入等待状态, 这是错误的 !</p></li><li><p>官方建议应该在循环中检查等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒, 如果不在循环中检查等待条件, 程序就会在没有满足条件的情况下退出</p></li><li><p>伪唤醒是指线程并非因为 notify, notifyAll, unpark 等 api 调用而唤醒, 是更底层原因导致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//wait</span><br><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-keyword">while</span> (&lt;条件判断&gt;)<br>        obj.wait();<br>    ...<span class="hljs-comment">//执行后续操作&#125;</span><br>&#125;<br><span class="hljs-comment">// park</span><br><span class="hljs-keyword">while</span> (&lt;条件判断&gt;)<br>    LockSupport.park();<br>...<span class="hljs-comment">//执行后续操作</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存屏障和CPU缓存</title>
    <link href="/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/"/>
    <url>/2020/02/07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8CCPU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一-CPU性能优化手段-缓存"><a href="#一-CPU性能优化手段-缓存" class="headerlink" title="一 : CPU性能优化手段-缓存"></a>一 : CPU性能优化手段-缓存</h2><p>为了提高程序运行的性能, 现代 CPU 在很多方面对程序进行了优化; 例如 : CPU 高速缓存, 尽可能地避免处理器访问主内存的时间开销, 处理器大多会利用缓存(cache)以提高性能</p><pre><code class=" mermaid">graph LRA1[CPU] --- B1[L1-L3缓存] --- 缓存一致性协议 --- 主内存A2[CPU] --- B2[L1-L3缓存] --- 缓存一致性协议A3[CPU] --- B3[L1-L3缓存] --- 缓存一致性协议</code></pre><h3 id="一-多级缓存"><a href="#一-多级缓存" class="headerlink" title="(一) 多级缓存"></a>(一) 多级缓存</h3><p>L1 Cache(一级缓存)是 CPU 第一层高速缓存, 分为数据缓存和指令缓存; 一般服务器 CPU 的 L1 缓存的容量通常在 <strong>32~4096KB</strong></p><p>L2 由于 L1 级高速缓存容量的限制, 为了再次提高CPU的运算速度, 在 CPU 外部放置一高速存储器, 即二级缓存</p><p>L3 现在的都是内置的; 作用是: L3缓存的应用可以进一步降低内存延迟, 同时提升大数据量计算时处理器的性能; 具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度; 一般是多核共享一个 L3 缓存</p><p><strong>读取顺序 :</strong> CPU 在读取数据时, 现在 L1 中寻找, 再从 L2 寻找, 再从 L3 寻找, 然后是内存, 再后是外存储器</p><h3 id="二-缓存同步协议"><a href="#二-缓存同步协议" class="headerlink" title="(二) 缓存同步协议"></a>(二) 缓存同步协议</h3><p>多 CPU 读取同样的数据进行缓存, 进行不同运算之后, 最终写入主内存以哪个 CPU 为准 ?</p><p>在这种高速缓存写的场景下, 有一个<strong>缓存一致性协议(MESI 协议)</strong>, 多数 CPU 厂商对它进行了实现; 它规定每条缓存有个状态位, 同时定义了下面四个状态 :</p><ul><li><strong>修改态(Modified)</strong> : 此 cache 行已被修改过(脏行), 内容已不同于主内存, 为此 cache 专有</li><li><strong>专有态(Exclusive)</strong> : 此 cache 行内容同于主存, 但不出现于其他 cache 中</li><li><strong>共享态(Shared)</strong> : 此 cache 行内容同于主存, 但也出现于其他 cache 中</li><li><strong>无效态(Invalid)</strong> : 此 cache 行 内容无效(空行)</li></ul><p>多处理器时, 单个 CPU 对缓存中数据进行了改动, 需要通知给其他 CPU; 也就是意味着, <strong>CPU 处理要控制自己的读写操作, 还要监听其他 CPU 发出的通知, 从而保证最终一致</strong></p><h2 id="二-CPU性能优化手段-运行时指令重排"><a href="#二-CPU性能优化手段-运行时指令重排" class="headerlink" title="二 : CPU性能优化手段-运行时指令重排"></a>二 : CPU性能优化手段-运行时指令重排</h2><p>指令重排的场景 : 当 CPU <strong>写缓存时</strong>发现缓存区块正被其他 CPU 占用, 为了提高 CPU 处理性能, 可能将后面的<strong>读缓存命令优先执行</strong></p><p><img src="D:\blog\source\java\image-2020020701.jpg"> </p><p>并非随便重排, 需要遵守 <strong>as-if-serial</strong> 语义</p><p><code>as-if-serial</code> 语义的意思指: 不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变; 编译器, runtime 和处理器都必须遵守 as-if-serial 语义</p><p>也就是说: 编译器和处理器<strong>不会对存在数据依赖关系的操作重排序</strong></p><h2 id="三-两个问题"><a href="#三-两个问题" class="headerlink" title="三 : 两个问题"></a>三 : 两个问题</h2><p>CPU 高速缓存下有一个问题 :</p><ul><li>缓存中的数据与主内存的数据并不是实时同步的, 各 CPU (或 CPU 核心) 间缓存的数据也不是实时同步;</li><li><strong>在同一个时间点, 各 CPU 所看到同一内存地址的数据的值可能时不一致的</strong></li></ul><p>CPU 执行指令重排序优化下有一个问题 :</p><ul><li>虽然遵守了 as-if-serial 语义, 但仅在单 CPU 自己执行的情况下能保证结果正确;</li><li>多核多线程中, 指令逻辑无法分辨因果关联, 可能出现<strong>乱序执行</strong>, 导致程序运行结果错误</li></ul><h2 id="四-内存屏障"><a href="#四-内存屏障" class="headerlink" title="四 : 内存屏障"></a>四 : 内存屏障</h2><p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题 : </p><ul><li><strong>写内存屏障(Store Memory Barrier)</strong>: 在指令后插入 Store Barrier, 能让写入缓存中的最新数据更新写入主内存, 让其他线程可见; 强制写入主内存, 这种显示调用, <strong>CPU 就不会因为性能考虑而去对指令重排</strong></li><li><strong>读内存屏障(Load Memory Barrier)</strong>: 在指令前插入 Load Barrier, 可以让高速缓存中的数据失效, 强制重新从主内存加载数据; 强制读取主内存内容, 让 CPU 缓存与主内存保持一致, <strong>避免了缓存导致的一致性问题</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程终止</title>
    <link href="/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/"/>
    <url>/2020/01/17/%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一-stop-不建议"><a href="#一-stop-不建议" class="headerlink" title="一 : stop(不建议)"></a>一 : stop(不建议)</h2><ul><li><p>stop : 中止线程, 并且清除监控器锁的信息, 但是可能导致线程安全问题, JDK 不建议用</p></li><li><p>destroy : JDK 未实现该方法</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">StopThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThread</span>();<br>        thread.start();<br>        <span class="hljs-comment">// 休眠1秒，确保i变量自增成功</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 暂停线程</span><br>        thread.stop(); <span class="hljs-comment">// 错误的终止</span><br>        <span class="hljs-keyword">while</span> (thread.isAlive()) &#123;<br>            <span class="hljs-comment">// 确保线程已经终止</span><br>        &#125; <br>        <span class="hljs-comment">// 输出结果</span><br>        thread.print();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 增加同步锁，确保线程安全</span><br>            ++i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 休眠10秒,模拟耗时操作</span><br>                Thread.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            ++j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印i和j</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot; j=&quot;</span> + j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-interrupt-推荐"><a href="#二-interrupt-推荐" class="headerlink" title="二 : interrupt(推荐)"></a>二 : interrupt(推荐)</h2><ul><li><p>如果目标线程在调用 Object class 的 wait(), wait(long) 或 wait(long, int) 方法, join(), join(long, int) 或者 sleep(long, int) 方法时被阻塞, 那么 interrupt 会生效, 该线程的中断状态将被清除, 抛出 InterruptedException 异常</p></li><li><p>如果目标线程是被 I&#x2F;O 或者 NIO 中的 Channel 所阻塞, 同样, I&#x2F;O 操作会被中断或者返回特殊异常值; 达到终止线程的目的</p></li><li><p>如果以上条件都不满足, 则会设置此线程的终端状态</p></li><li><p>代码示例, 修改之前的代码 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// thread.stop(); // 错误的终止</span><br>thread.interrupt(); <span class="hljs-comment">// 正确终止</span><br></code></pre></td></tr></table></figure></li><li><p>将 stop 改成 interrupt 后, 最终输出为 <code>i=1 j=1</code>, 数据一致</p></li></ul><h2 id="三-标志位-推荐"><a href="#三-标志位-推荐" class="headerlink" title="三 : 标志位(推荐)"></a>三 : 标志位(推荐)</h2><ul><li><p>代码逻辑中, 增加一个判断, 用来控制线程执行的中止</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 通过状态位来判断 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (flag) &#123; <span class="hljs-comment">// 判断是否运行</span><br>                    System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-comment">// 3秒之后，将状态标志改为False，代表不继续运行</span><br>        Thread.sleep(<span class="hljs-number">3000L</span>);<br>        flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;程序运行结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程状态</title>
    <link href="/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2020/01/10/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一-状态定义"><a href="#一-状态定义" class="headerlink" title="一 : 状态定义"></a>一 : 状态定义</h2><p>定义位置 : java.lang.Thread.State</p><p>线程状态 : 新建, 可运行, 阻塞, 等待, 超时等待, 终止</p><ul><li><strong>New</strong> : 尚未启动的线程的线程状态</li><li><strong>Runnable</strong> : 可运行线程的线程状态, 等待CPU调度</li><li><strong>Blocked</strong> : 线程阻塞, <strong>等待监视器锁定</strong>的线程状态; 处于 synchronized 同步代码块或方法中被阻塞</li><li><strong>Waiting</strong> : 等待线程的线程状态; 不带超时的方式(Object.wait, Thread.join, LockSupport.park)</li><li><strong>Time Waiting</strong> : 具有指定等待时间的等待线程的线程状态; 带超时的方式(Thread.sleep, Object.wait, Thread.join, LockSupport.parkNanos, LockSupport.parkUntil)</li><li><strong>Terminated</strong> : 终止线程的线程状态; 线程正常完成执行或者出现异常</li></ul><h2 id="二-线程状态切换"><a href="#二-线程状态切换" class="headerlink" title="二 : 线程状态切换"></a>二 : 线程状态切换</h2><p>这 6 种状态在一定条件下会发生转换</p><pre><code class=" mermaid">graph LRNew新线程 --开始--&gt; Runnable可运行状态Runnable可运行状态 --等待锁---&gt; Blocked阻塞状态Blocked阻塞状态 --已拿到锁---&gt; Runnable可运行状态Runnable可运行状态 --等待其他线程的通知---&gt; Waiting等待状态Waiting等待状态 --收到通知,继续执行---&gt; Runnable可运行状态Runnable可运行状态 --有超时时间的等待其他线程通知---&gt; A[Timed Waiting等待状态]A[Timed Waiting等待状态] --等待超时或者收到通知,继续执行---&gt; Runnable可运行状态    Runnable可运行状态 --执行结束---&gt; Terminated终止 </code></pre><ul><li><code>New</code> 新线程通过调用 <code>start</code> 进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>等待锁</strong>的时候会进入 <code>Blocked</code> 阻塞状态; 一旦拿到锁, 便会从 <code>Blocked</code> 阻塞状态进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>等待其他线程的通知时</strong>会进入 <code>Waiting</code> 等待状态; 一旦收到通知,继续执行时, 便会从 <code>Waiting</code> 等待状态进入 <code>Runnable</code> 可运行状态</li><li><code>Runnable</code> 可运行状态在<strong>有超时时间的等待其他线程的通知时</strong>会进入 <code>Time Waiting</code> 定时等待状态; 一旦等待超时或者收到通知, 继续执行时则会进入 <code>Runnable</code> 状态</li><li><code>Runnable</code> 可运行状态在线程执行结束时会成为 <code>Terminated</code> 终止状态</li></ul><h2 id="三-代码演示"><a href="#三-代码演示" class="headerlink" title="三 : 代码演示"></a>三 : 代码演示</h2><ul><li><p>New &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止</span><br>    System.out.println(<span class="hljs-string">&quot;### 第一种状态切换: 新建 -&gt; 运行 -&gt; 终止 ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;thread1当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>        System.out.println(<span class="hljs-string">&quot;thread1 执行了&quot;</span>);<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;没调用start方法,thread1当前状态: &quot;</span> + thread1.getState().toString());<br>    thread1.start();<br>    Thread.sleep(<span class="hljs-number">2000L</span>); <span class="hljs-comment">// 等待thread1执行结束，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待两秒,再看thread1当前状态: &quot;</span> + thread1.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>new &#x3D;&gt; Runnable &#x3D;&gt; Timed Waiting &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)</span><br>    System.out.println(<span class="hljs-string">&quot;### 第二种: 新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式) ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 进入超时等待, 时间1.5s</span><br>            Thread.sleep(<span class="hljs-number">1500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;thread2当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>        System.out.println(<span class="hljs-string">&quot;thread2 执行了&quot;</span>);<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;没调用start方法，thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    thread2.start();<br>    System.out.println(<span class="hljs-string">&quot;调用start方法，thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    Thread.sleep(<span class="hljs-number">200L</span>); <span class="hljs-comment">// 等待200毫秒，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待200毫秒，再看thread2当前状态: &quot;</span> + thread2.getState().toString());<br>    Thread.sleep(<span class="hljs-number">3000L</span>); <span class="hljs-comment">// 再等待3秒，让thread2执行完毕，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待3秒，再看thread2当前状态: &quot;</span> + thread2.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>new &#x3D;&gt; Runnable &#x3D;&gt; Blocked &#x3D;&gt; Runnable &#x3D;&gt; Terminated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止</span><br>    System.out.println(<span class="hljs-string">&quot;### 第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止 ###&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>            System.out.println(<span class="hljs-string">&quot;thread3当前状态: &quot;</span> + Thread.currentThread().getState().toString());<br>            System.out.println(<span class="hljs-string">&quot;thread3 执行了&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">synchronized</span> (Demo.class) &#123;<br>        System.out.println(<span class="hljs-string">&quot;没调用start方法，thread3当前状态: &quot;</span> + thread3.getState().toString());<br>        thread3.start();<br>        System.out.println(<span class="hljs-string">&quot;调用start方法，thread3当前状态: &quot;</span> + thread3.getState().toString());<br>        Thread.sleep(<span class="hljs-number">200L</span>); <span class="hljs-comment">// 等待200毫秒，再看状态</span><br>        System.out.println(<span class="hljs-string">&quot;等待200毫秒，再看thread3当前状态: &quot;</span> + thread3.getState().toString());<br>    &#125;<br>    Thread.sleep(<span class="hljs-number">3000L</span>); <span class="hljs-comment">// 再等待3秒，让thread3执行完毕，再看状态</span><br>    System.out.println(<span class="hljs-string">&quot;等待3秒，让thread3抢到锁，再看thread3当前状态: &quot;</span> + thread3.getState().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java程序运行堆栈分析</title>
    <link href="/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/"/>
    <url>/2020/01/03/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 : 概述"></a>一 : 概述</h2><p>jvm 运行时数据区大致可以分为两部分 : <u>线程共享</u>部分和<u>线程独占</u>部分</p><p><img src="/../java/image-2020010301.jpg"></p><p><strong>线程共享</strong> : 所有线程能访问这块内存数据, 随虚拟机或者 <code>GC</code> 而创建和销毁; <strong>方法区</strong>和<strong>堆内存</strong>皆属此列</p><p><strong>线程独占</strong> : 每个线程都会有它的独立的空间, 随线程生命周期而创建和销毁; <strong>虚拟机栈</strong>, <strong>本地方法栈</strong>和<strong>程序计数器</strong>属于线程独占</p><h2 id="二-JVM运行时数据区"><a href="#二-JVM运行时数据区" class="headerlink" title="二 : JVM运行时数据区"></a>二 : JVM运行时数据区</h2><h3 id="一-方法区"><a href="#一-方法区" class="headerlink" title="(一) 方法区"></a>(一) 方法区</h3><p>jvm 启动时创建, 用来存储加载<u>类信息, 常量, 静态变量, 编译后的代码</u>等数据; </p><p><img src="/../java/image-2020010302.jpg"></p><p>虚拟机规范中这是一个逻辑区划, 具体实现根据不同虚拟机来实现; 例如: </p><ul><li>oracle 的 HotSpot 在 java7 中方法区放在<strong>永久代</strong>; </li><li>java8 放在<strong>元数据空间</strong> (metaspace), 并且通过 <code>GC</code> 机制对这个区域进行管理。</li></ul><h3 id="二-堆内存"><a href="#二-堆内存" class="headerlink" title="(二) 堆内存"></a>(二) 堆内存</h3><p>jvm 启动时创建, 存放<u>对象的实例</u>; <strong>垃圾回收器主要就是管理堆内存;</strong> </p><p><img src="/../java/image-2020010303.jpg"></p><p>如果满了, 就会出现 <code>OutOfMemroyError</code>; </p><p>堆内存还可以细分为 : <strong>新生代</strong>(<code>Eden</code>, <code>From Survivor(s0)</code> 和 <code>To Survivor(s1)</code>)和<strong>老年代</strong> (<code>Old</code>)</p><h3 id="三-虚拟机栈"><a href="#三-虚拟机栈" class="headerlink" title="(三) 虚拟机栈"></a>(三) 虚拟机栈</h3><p>随线程的生命周期创建和销毁, 每个线程都在在这个空间有一个私有的空间, 这个空间称为线程栈; </p><p><img src="/../java/image-2020010304.jpg"></p><p>线程栈由多个<u>栈帧 (Stack Frame)</u> 组成; 栈帧内容包含 : 局部变量表, 操作数栈, 动态链接, 方法返回地址和附加信息等; </p><p><strong>一个线程会执行一个或多个方法, 一个方法对应一个栈帧</strong>; </p><p>栈内存默认最大是 <strong>1M</strong>, 超出则抛出 <code>StackOverflowError</code></p><h3 id="四-本地方法栈"><a href="#四-本地方法栈" class="headerlink" title="(四) 本地方法栈"></a>(四) 本地方法栈</h3><p>和虚拟机栈功能类似, 虚拟机栈是为虚拟机执行java方法而准备的, 本地方法栈是为虚拟机使用 <code>Native</code> 本地方法而准备的;</p><p><img src="/../java/image-2020010305.jpg"></p><p>虚拟机规范没有规定具体的实现, 由不同的虚拟机厂商去实现;</p><p>HotSpot 虚拟机中虚拟机栈和本地方法栈的实现是一样的; 同样, 超出大小以后也会抛出 <code>StackOverflowError</code></p><h3 id="五-程序计数器"><a href="#五-程序计数器" class="headerlink" title="(五) 程序计数器"></a>(五) 程序计数器</h3><p>程序计数器 (Program Counter Register) 记录当前线程执行字节码的位置, 存储的是<u>字节码指令地址</u>, </p><p><img src="/../java/image-2020010306.jpg"></p><p>如果执行Native方法, 则计数器值为空;</p><p><strong>每个线程都在这个空间有一个私有的空间, 占用内存空间很少;</strong></p><p>CPU 同一时间, 只会执行一条线程中的指令; <code>jvm</code> 多线程会轮流切换并分配 <code>CPU</code> 执行时间; 线程切换后, 需要通过程序计数器, 来恢复正确的执行位置</p><h2 id="三-class文件内容"><a href="#三-class文件内容" class="headerlink" title="三 : class文件内容"></a>三 : class文件内容</h2><h3 id="一-概述-1"><a href="#一-概述-1" class="headerlink" title="(一) 概述"></a>(一) 概述</h3><p>class 文件包含 java 程序执行的字节码; 数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符; 文件开头有一个<code>ca fe ba be</code> (16进制)特殊的一个标志; </p><p><img src="/../java/image-2020010307.jpg"> </p><p>这个文件具有复杂且严格的格式, 专门给 jvm 读取其中的内容, 人类可以借助工具查看; 其中包含 : 版本信息, 访问标志, 常量池, 当前类, 超级类, 接口, 字段, 方法, 属性等信息</p><h3 id="二-内容分析"><a href="#二-内容分析" class="headerlink" title="(二) 内容分析"></a>(二) 内容分析</h3><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        System.out.println(a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反编译 class 文件并重定向到 txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac Demo.java</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">反编译将其写入txt文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">javap -v Demo.class &gt; Demo.txt</span><br></code></pre></td></tr></table></figure></li><li><p>版本号&#x2F;访问控制, 版本号规则 : JDK5,6,7,8 分别对应 49,50,51,52</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Demo</span><br>  <span class="hljs-symbol">minor</span> <span class="hljs-symbol">version: <span class="hljs-symbol">0</span></span> //次版本号<br>  <span class="hljs-symbol">major</span> <span class="hljs-symbol">version: <span class="hljs-symbol">52</span></span> //主版本号<br>  <span class="hljs-symbol">flags: <span class="hljs-symbol">ACC_PUBLIC</span>, <span class="hljs-symbol">ACC_SUPER</span></span> //访问标志<br></code></pre></td></tr></table></figure></li><li><p>常量池</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Constant pool:<br>   <span class="hljs-string">#1</span> = Methodref          <span class="hljs-string">#5</span>.<span class="hljs-string">#14</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-string">#2</span> = Fieldref           <span class="hljs-string">#15</span>.<span class="hljs-string">#16</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-string">#3</span> = Methodref          <span class="hljs-string">#17</span>.<span class="hljs-string">#18</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   <span class="hljs-string">#4</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#19</span>            <span class="hljs-comment">// Demo1</span><br>   <span class="hljs-string">#5</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#20</span>            <span class="hljs-comment">// java/lang/Object</span><br>   <span class="hljs-string">#6</span> = Utf8               &lt;init&gt;<br>   <span class="hljs-string">#7</span> = Utf8               ()V<br>   <span class="hljs-string">#8</span> = Utf8               Code<br>   <span class="hljs-string">#9</span> = Utf8               LineNumberTable<br>  <span class="hljs-string">#10</span> = Utf8               main<br>  <span class="hljs-string">#11</span> = Utf8               ([Ljava/lang/<span class="hljs-keyword">String</span>;)V<br>  <span class="hljs-string">#12</span> = Utf8               SourceFile<br>  <span class="hljs-string">#13</span> = Utf8               Demo1.java<br>  <span class="hljs-string">#14</span> = NameAndType        <span class="hljs-string">#6</span>:<span class="hljs-string">#7</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-string">#15</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#21</span>            <span class="hljs-comment">// java/lang/System</span><br>  <span class="hljs-string">#16</span> = NameAndType        <span class="hljs-string">#22</span>:<span class="hljs-string">#23</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  <span class="hljs-string">#17</span> = <span class="hljs-keyword">Class</span>              <span class="hljs-string">#24</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  <span class="hljs-string">#18</span> = NameAndType        <span class="hljs-string">#25</span>:<span class="hljs-string">#26</span>        <span class="hljs-comment">// println:(I)V</span><br>  <span class="hljs-string">#19</span> = Utf8               Demo1<br>  <span class="hljs-string">#20</span> = Utf8               java/lang/<span class="hljs-keyword">Object</span><br>  <span class="hljs-string">#21</span> = Utf8               java/lang/System<br>  <span class="hljs-string">#22</span> = Utf8               <span class="hljs-keyword">out</span><br>  <span class="hljs-string">#23</span> = Utf8               Ljava/io/PrintStream;<br>  <span class="hljs-string">#24</span> = Utf8               java/io/PrintStream<br>  <span class="hljs-string">#25</span> = Utf8               println<br>  <span class="hljs-string">#26</span> = Utf8               (I)V<br></code></pre></td></tr></table></figure></li><li><p>构造方法 : 示例中并没有写构造函数, 由此可见, 没有定义构造函数时, 会有隐式的无参构造函数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">Demo();</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">()V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=1,</span> <span class="hljs-string">args_size=1</span><br>      <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br>      <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>      <span class="hljs-attr">4:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 1:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>程序入口 main 方法 : stack(操作数栈), locals(为本地变量表)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><span class="hljs-string">//访问控制</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=3,</span> <span class="hljs-string">locals=5,</span> <span class="hljs-string">args_size=1</span><br>      <span class="hljs-string">/**</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">jvm执行引擎去执行这些源码编译过后的指令码</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">javap编译出来是操作符,class文件内存的是指令码</span><br>       <span class="hljs-string">*</span> <span class="hljs-string">前面的数字,是偏移量(字节),jvm根据这个去区分不同的指令(查看jvm指令码表)</span><br>       <span class="hljs-string">*/</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">sipush</span>        <span class="hljs-number">500</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">100</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">istore_2</span><br>       <span class="hljs-attr">7:</span> <span class="hljs-string">iload_1</span><br>       <span class="hljs-attr">8:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">idiv</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">istore_3</span><br>      <span class="hljs-attr">11:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">50</span><br>      <span class="hljs-attr">13:</span> <span class="hljs-string">istore</span>        <span class="hljs-number">4</span><br>      <span class="hljs-attr">15:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#2        // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-attr">18:</span> <span class="hljs-string">iload_3</span><br>      <span class="hljs-attr">19:</span> <span class="hljs-string">iload</span>         <span class="hljs-number">4</span><br>      <span class="hljs-attr">21:</span> <span class="hljs-string">iadd</span><br>      <span class="hljs-attr">22:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#3        // Method java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-attr">25:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">line 4:</span> <span class="hljs-number">4</span><br>      <span class="hljs-attr">line 5:</span> <span class="hljs-number">7</span><br>      <span class="hljs-attr">line 6:</span> <span class="hljs-number">11</span><br>      <span class="hljs-attr">line 7:</span> <span class="hljs-number">15</span><br>      <span class="hljs-attr">line 8:</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="四-程序完整运行分析"><a href="#四-程序完整运行分析" class="headerlink" title="四 : 程序完整运行分析"></a>四 : 程序完整运行分析</h2><h3 id="一-加载信息到方法区"><a href="#一-加载信息到方法区" class="headerlink" title="(一) 加载信息到方法区"></a>(一) 加载信息到方法区</h3><p>此时属于线程共享部分的<strong>方法区</strong>会存在大量的类信息, 同时还存在运行时常量池字符串常量。</p><p>HotSpot 虚拟机 : 1.7及之前称为永久代, 1.8开始称为元数据空间。</p><h3 id="二-jvm-创建线程来执行代码"><a href="#二-jvm-创建线程来执行代码" class="headerlink" title="(二) jvm 创建线程来执行代码"></a>(二) jvm 创建线程来执行代码</h3><p>在虚拟机栈, 程序计数器内存区域中创建线程独占的空间。</p><p>虚拟机栈中存放<strong>Thread栈帧</strong>, 程序计数器中存放<strong>Thread执行位置</strong>(字节码指令地址)。</p><h3 id="三-方法区程序入口"><a href="#三-方法区程序入口" class="headerlink" title="(三) 方法区程序入口"></a>(三) 方法区程序入口</h3><p>main 方法栈帧初始化 : 5个本地变量, 变量0是方法参数 args</p><p><img src="/../execute/execute_00.png"> </p><h3 id="四-程序执行过程"><a href="#四-程序执行过程" class="headerlink" title="(四) 程序执行过程"></a>(四) 程序执行过程</h3><ol><li><p>将500压入操作数栈</p><p><img src="/../execute/execute_01.png"></p></li><li><p>弹出操作数栈栈顶500保存到本地变量表1</p><p><img src="/../execute/execute_02.png"></p></li><li><p>将100压入操作数栈</p><p><img src="/../execute/execute_03.png"></p></li><li><p>弹出操作数栈栈顶100保存到本地变量表2</p><p><img src="/../execute/execute_04.png"></p></li><li><p>读取本地变量1压入操作数栈</p><p><img src="/../execute/execute_05.png"></p></li><li><p>读取本地变量2压入操作数栈</p><p><img src="/../execute/execute_06.png"></p></li><li><p>将栈顶两int类型数相除, 结果入栈 500&#x2F;100&#x3D;5</p><p><img src="/../execute/execute_07.png"></p></li><li><p>将栈顶int类型值保存到局部变量3中</p><p><img src="/../execute/execute_08.png"></p></li><li><p>将50压入操作数栈</p><p><img src="/../execute/execute_09.png"></p></li><li><p>将栈顶int类型值保存到局部变量4中</p><p><img src="/../execute/execute_10.png"></p></li><li><p>获取类或接口字段的值并将其压入操作数栈</p><p><img src="/../execute/execute_11.png"></p></li><li><p>将本地变量3取出压入操作数栈</p><p><img src="/../execute/execute_12.png"></p></li><li><p>将本地变量4取出压入操作数栈</p><p><img src="/../execute/execute_13.png"></p></li><li><p>将栈顶两int类型数相加, 结果入栈</p><p><img src="/../execute/execute_14.png"></p></li><li><p>调用静态方法; jvm会根据这个方法的描述,创建新栈帧, 方法的参数从操作数栈中弹出来,压入虚拟机栈, 然后虚拟机会开始执行虚拟机栈最上面的栈帧; 执行完毕后,再继续执行main方法对应的栈帧</p><p><img src="/../execute/execute_15.png"></p></li><li><p>void函数返回, main方法执行结束</p><p><img src="/../execute/execute_16.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程并发编程</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客图床</title>
    <link href="/2019/12/25/blog-images/"/>
    <url>/2019/12/25/blog-images/</url>
    
    <content type="html"><![CDATA[<h2 id="一-typora"><a href="#一-typora" class="headerlink" title="一 : typora"></a>一 : typora</h2><p>下载地址 : <a href="https://download2.typoraio.cn/windows/typora-setup-x64.exe">https://download2.typoraio.cn/windows/typora-setup-x64.exe</a></p><p>傻瓜式安装即可</p><h2 id="二-github"><a href="#二-github" class="headerlink" title="二 : github"></a>二 : github</h2><p>创建一个公开仓库 : blog_images</p><p>在 settings &#x3D;&gt; Developer settings &#x3D;&gt; Personal access tokens 里生成一个 token</p><h2 id="三-picgo"><a href="#三-picgo" class="headerlink" title="三 : picgo"></a>三 : picgo</h2><p>文件 &#x3D;&gt; 偏好设置 &#x3D;&gt; 图像, 做如下修改</p><p><img src="/../blog/image-2019122501.png" alt="image-2019122501"> </p><p>点击下载或更新, 下载 PicGo-Core(command-line)</p><p>下载完毕后, 点击打开配置文件, 或者手动打开 <code>C:/Users/&#123;用户名&#125;/.picgo/config.json</code>, 参考下面文件进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;current&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;github&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;github&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;repo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;info4z/blog_images&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;branch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;刚刚生成的 Personal access tokens&quot;</span><span class="hljs-punctuation">,</span>  <br>            <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;images&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;customUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/info4z/blog_images@main&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客美化</title>
    <link href="/2019/12/24/blog-theme/"/>
    <url>/2019/12/24/blog-theme/</url>
    
    <content type="html"><![CDATA[<h2 id="一-主题"><a href="#一-主题" class="headerlink" title="一 : 主题"></a>一 : 主题</h2><ul><li><p>博客搭建完毕后, 可以对其进行一定的美化, 可以使用 kaze 主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git <span class="hljs-built_in">clone</span> git@github.com:theme-kaze/hexo-theme-kaze.git themes/kaze<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-站点配置"><a href="#二-站点配置" class="headerlink" title="二 : 站点配置"></a>二 : 站点配置</h2><ul><li><p>编辑博客根目录下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">冰清阁</span><span class="hljs-comment">#标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;差不多得了, 玩什么命呀...&#x27;</span><span class="hljs-comment">#简介或者格言</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">清月明风</span><span class="hljs-comment">#作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><span class="hljs-comment">#主题语言,查看themes\next\languages下面的具体名字</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-comment">#中国的时区</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://info4z.github.io</span><br><br><span class="hljs-comment"># 代码高亮</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">kaze</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="三-主题配置"><a href="#三-主题配置" class="headerlink" title="三 : 主题配置"></a>三 : 主题配置</h2><ul><li><p>修改 kaze下的 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Header config</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">冰清阁</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">清月明风</span><br><span class="hljs-attr">logo_img:</span> <span class="hljs-string">https://img.songhn.com/img/Y67gdd.png</span><br><span class="hljs-attr">author_img:</span> <span class="hljs-string">https://img.songhn.com/img/Y67gdd.png</span><br><span class="hljs-attr">author_description:</span> <span class="hljs-string">差不多得了,</span> <span class="hljs-string">玩什么命呀...</span><br></code></pre></td></tr></table></figure></li><li><p>目录</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Navbar config</span><br><span class="hljs-attr">menus:</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories</span><br>  <span class="hljs-attr">archive:</span> <span class="hljs-string">/archives</span><br>  <span class="hljs-attr">about:</span> <span class="hljs-string">/about</span><br>  <span class="hljs-attr">friends:</span> <span class="hljs-string">/friends</span><br></code></pre></td></tr></table></figure></li><li><p>当然了, 有些目录是不存在的, 需要手动创建</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo new page tags<br>$ hexo new page categories<br>$ hexo new page about<br>$ hexo new page friends<br></code></pre></td></tr></table></figure></li><li><p>搜索</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.json</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">posts</span><br>  <span class="hljs-attr">searchContent:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2019/12/24/blog-hexo/"/>
    <url>/2019/12/24/blog-hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="一-nodejs"><a href="#一-nodejs" class="headerlink" title="一 : nodejs"></a>一 : nodejs</h2><ul><li><p>官网 : <a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p></li><li><p>下载地址 : <a href="https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi">https://nodejs.org/dist/v18.12.1/node-v18.12.1-x64.msi</a> (长期维护版即可)</p></li><li><p>安装完成后 : </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看node版本</span><br>$ node -v<br></code></pre></td></tr></table></figure></li></ul><h2 id="二-npm"><a href="#二-npm" class="headerlink" title="二 : npm"></a>二 : npm</h2><ul><li><p><code>node.js</code> 自带 <code>npm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看npm版本</span><br>$ npm -v<br></code></pre></td></tr></table></figure></li><li><p><code>npm</code> 有时候不是特别好用, 可以使用 <code>cnpm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install -g cnpm --registry=http://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></li><li><p>安装过程中可能会出现无法加载文件的问题, 解决方案如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以管理员身份运行powerShell</span><br>PS D:\Blog&gt; set-ExecutionPolicy RemoteSigned<br><br>执行策略更改<br>执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170<br>中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?<br>[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): A<br>PS D:\fore\jshERP-web&gt; get-ExecutionPolicy<br>RemoteSigned<br></code></pre></td></tr></table></figure></li><li><p>查看版本信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cnpm -v<br></code></pre></td></tr></table></figure></li></ul><h2 id="三-hexo"><a href="#三-hexo" class="headerlink" title="三 : hexo"></a>三 : hexo</h2><ul><li><p>使用 npm 安装 hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># npm和cnpm哪个好使用哪个</span><br>$ cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># init : Create a new Hexo folder</span><br>$ hexo init<br></code></pre></td></tr></table></figure></li><li><p>生成工具栏</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo new page tags <span class="hljs-comment"># 新增标签</span><br>$ hexo new page categories<span class="hljs-comment"># 新增分类</span><br></code></pre></td></tr></table></figure></li><li><p>新写文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new <span class="hljs-string">&quot;文章题目&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p>本地启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo server<br>$ hexo s<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo generate<br>$ hexo g<br></code></pre></td></tr></table></figure></li></ul><h2 id="四-github"><a href="#四-github" class="headerlink" title="四 : github"></a>四 : github</h2><ul><li><p>创建仓库, 这里只需要注意 <code>repository name</code> 的值为 : <code> 用户名.github.io</code></p></li><li><p>通过 <code>Settings</code> 查看 <code>Pages</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Your site is live at https://info4z.github.io/<span class="hljs-comment"># 这就是个人博客的地址</span><br></code></pre></td></tr></table></figure></li><li><p>编辑 <code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:info4z/info4z.github.io.git</span> <span class="hljs-comment"># 用ssh连接</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><p>安装 git 部署插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>执行如下指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 清除缓存文件db.json和已生成的静态文件public</span><br>$ hexo clean   <br><span class="hljs-comment"># 生成网站静态文件到默认设置的public文件夹(generate)</span><br>$ hexo g<br><span class="hljs-comment"># 自动生成网站静态文件,并部署到设定的仓库(deploy)</span><br>$ hexo d<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/24/hello-world/"/>
    <url>/2019/12/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
